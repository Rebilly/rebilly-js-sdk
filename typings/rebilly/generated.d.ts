/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/3dsecure": {
    get: operations["Get3DSecureCollection"];
    post: operations["Post3DSecure"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/3dsecure/{id}": {
    get: operations["Get3DSecure"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/attachments": {
    get: operations["GetAttachmentCollection"];
    post: operations["PostAttachment"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/attachments/{id}": {
    get: operations["GetAttachment"];
    put: operations["PutAttachment"];
    delete: operations["DeleteAttachment"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/authentication-options": {
    get: operations["GetAuthenticationOption"];
    put: operations["PutAuthenticationOption"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/authentication-tokens": {
    get: operations["GetAuthenticationTokenCollection"];
    post: operations["PostAuthenticationToken"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/authentication-tokens/{token}": {
    get: operations["GetAuthenticationTokenVerification"];
    delete: operations["DeleteAuthenticationToken"];
    parameters: {
      path: {
        /** The token identifier string. */
        token: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/authentication-tokens/{token}/exchange": {
    post: operations["PostAuthenticationTokenExchange"];
    parameters: {
      path: {
        /** The token identifier string. */
        token: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/bank-accounts": {
    post: operations["PostBankAccount"];
    get: operations["GetBankAccountCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/bank-accounts/{id}": {
    get: operations["GetBankAccount"];
    patch: operations["PatchBankAccount"];
    put: operations["PutBankAccount"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/bank-accounts/{id}/deactivation": {
    post: operations["PostBankAccountDeactivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/blocklists": {
    get: operations["GetBlocklistCollection"];
    post: operations["PostBlocklist"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/blocklists/{id}": {
    get: operations["GetBlocklist"];
    put: operations["PutBlocklist"];
    delete: operations["DeleteBlocklist"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons-redemptions": {
    get: operations["GetCouponRedemptionCollection"];
    post: operations["PostCouponRedemption"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons-redemptions/{id}": {
    get: operations["GetCouponRedemption"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons-redemptions/{id}/cancel": {
    post: operations["PostCouponRedemptionCancellation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons": {
    get: operations["GetCouponCollection"];
    post: operations["PostCoupon"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons/{id}": {
    get: operations["GetCoupon"];
    put: operations["PutCoupon"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/coupons/{id}/expiration": {
    post: operations["PostCouponExpiration"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credentials": {
    get: operations["GetCredentialCollection"];
    post: operations["PostCredential"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credentials/{id}": {
    get: operations["GetCredential"];
    put: operations["PutCredential"];
    delete: operations["DeleteCredential"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/custom-fields/{resource}": {
    get: operations["GetCustomFieldCollection"];
    parameters: {
      path: {
        resource: components["parameters"]["customFieldResource"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/custom-fields/{resource}/{name}": {
    get: operations["GetCustomField"];
    put: operations["PutCustomField"];
    parameters: {
      path: {
        resource: components["parameters"]["customFieldResource"];
        /** The custom field's identifier string. */
        name: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers": {
    get: operations["GetCustomerCollection"];
    post: operations["PostCustomer"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers/{id}": {
    get: operations["GetCustomer"];
    put: operations["PutCustomer"];
    delete: operations["DeleteCustomer"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customer-timeline-custom-events": {
    get: operations["GetCustomerTimelineCustomEventTypeCollection"];
    post: operations["PostCustomerTimelineCustomEventType"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customer-timeline-custom-events/{id}": {
    get: operations["GetCustomerTimelineCustomEventType"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customer-timeline-events": {
    get: operations["GetCustomerTimelineEventCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers/{id}/lead-source": {
    get: operations["GetCustomerLeadSource"];
    put: operations["PutCustomerLeadSource"];
    delete: operations["DeleteCustomerLeadSource"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers/{id}/timeline": {
    get: operations["GetCustomerTimelineCollection"];
    post: operations["PostCustomerTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers/{id}/timeline/{messageId}": {
    get: operations["GetCustomerTimeline"];
    delete: operations["DeleteCustomerTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** The Customer Timeline message ID. */
        messageId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/customers/{id}/upcoming-invoices": {
    get: operations["GetCustomerUpcomingInvoiceCollection"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/disputes": {
    get: operations["GetDisputeCollection"];
    post: operations["PostDispute"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/disputes/{id}": {
    get: operations["GetDispute"];
    put: operations["PutDispute"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/files": {
    get: operations["GetFileCollection"];
    post: operations["PostFile"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/files/{id}": {
    get: operations["GetFile"];
    put: operations["PutFile"];
    delete: operations["DeleteFile"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/files/{id}/download": {
    get: operations["GetFileDownload"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      query: {
        imageSize?: components["parameters"]["imageSize"];
      };
    };
  };
  "/files/{id}/download{extension}": {
    get: operations["GetFileDownloadExtension"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** File extension which also indicates the desired file format. */
        extension: ".png" | ".jpg" | ".gif";
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices": {
    get: operations["GetInvoiceCollection"];
    post: operations["PostInvoice"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}": {
    get: operations["GetInvoice"];
    put: operations["PutInvoice"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/abandon": {
    post: operations["PostInvoiceAbandonment"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/issue": {
    post: operations["PostInvoiceIssuance"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/items": {
    get: operations["GetInvoiceItemCollection"];
    post: operations["PostInvoiceItem"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/recalculate": {
    post: operations["PostInvoiceRecalculation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/reissue": {
    post: operations["PostInvoiceReissuance"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/timeline": {
    get: operations["GetInvoiceTimelineCollection"];
    post: operations["PostInvoiceTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/timeline/{messageId}": {
    get: operations["GetInvoiceTimeline"];
    delete: operations["DeleteInvoiceTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** The Invoice Timeline message ID. */
        messageId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/transaction-allocations": {
    get: operations["GetInvoiceTransactionAllocationCollection"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/invoices/{id}/void": {
    post: operations["PostInvoiceVoid"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/kyc-documents": {
    get: operations["GetKycDocumentCollection"];
    post: operations["PostKycDocument"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/kyc-documents/{id}": {
    get: operations["GetKycDocument"];
    put: operations["PutKycDocument"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/kyc-documents/{id}/acceptance": {
    post: operations["PostKycDocumentAcceptance"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/kyc-documents/{id}/rejection": {
    post: operations["PostKycDocumentRejection"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/kyc-documents/{id}/review": {
    post: operations["PostKycDocumentReview"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/password-tokens": {
    get: operations["GetPasswordTokenCollection"];
    post: operations["PostPasswordToken"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/password-tokens/{id}": {
    get: operations["GetPasswordToken"];
    delete: operations["DeletePasswordToken"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-instruments": {
    get: operations["GetPaymentInstrumentCollection"];
    post: operations["PostPaymentInstrument"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-instruments/{id}": {
    get: operations["GetPaymentInstrument"];
    patch: operations["PatchPaymentInstrument"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-instruments/{id}/deactivation": {
    post: operations["PostPaymentInstrumentDeactivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-cards": {
    get: operations["GetPaymentCardCollection"];
    post: operations["PostPaymentCard"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-cards/{id}": {
    get: operations["GetPaymentCard"];
    patch: operations["PatchPaymentCard"];
    put: operations["PutPaymentCard"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-cards/{id}/authorization": {
    post: operations["PostPaymentCardAuthorization"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-cards/{id}/deactivation": {
    post: operations["PostPaymentCardDeactivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payment-methods": {
    get: operations["GetPaymentMethodCollection"];
  };
  "/payment-methods/{apiName}": {
    get: operations["GetPaymentMethod"];
    parameters: {
      path: {
        /** The payment method API name. */
        apiName: components["schemas"]["PaymentMethodApiName"];
      };
    };
  };
  "/paypal-accounts": {
    get: operations["GetPayPalAccountCollection"];
    post: operations["PostPayPalAccount"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/paypal-accounts/{id}": {
    get: operations["GetPayPalAccount"];
    put: operations["PutPayPalAccount"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/paypal-accounts/{id}/activation": {
    post: operations["PostPayPalAccountActivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/paypal-accounts/{id}/deactivation": {
    post: operations["PostPayPalAccountDeactivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/permissions-emulation": {
    post: operations["PostPermissionsEmulation"];
    delete: operations["DeletePermissionsEmulation"];
  };
  "/plans": {
    get: operations["GetPlanCollection"];
    post: operations["PostPlan"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/plans/{id}": {
    get: operations["GetPlan"];
    put: operations["PutPlan"];
    delete: operations["DeletePlan"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/products": {
    get: operations["GetProductCollection"];
    post: operations["PostProduct"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/products/{id}": {
    get: operations["GetProduct"];
    put: operations["PutProduct"];
    delete: operations["DeleteProduct"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/search": {
    get: operations["GetSearch"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/shipping-zones": {
    get: operations["GetShippingZoneCollection"];
    post: operations["PostShippingZone"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/shipping-zones/{id}": {
    get: operations["GetShippingZone"];
    put: operations["PutShippingZone"];
    delete: operations["DeleteShippingZone"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscription-cancellations": {
    get: operations["GetSubscriptionCancellationCollection"];
    post: operations["PostSubscriptionCancellation"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscription-cancellations/{id}": {
    get: operations["GetSubscriptionCancellation"];
    put: operations["PutSubscriptionCancellation"];
    delete: operations["DeleteSubscriptionCancellation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscription-reactivations": {
    get: operations["GetSubscriptionReactivationCollection"];
    post: operations["PostSubscriptionReactivation"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscription-reactivations/{id}": {
    get: operations["GetSubscriptionReactivation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions": {
    get: operations["GetSubscriptionCollection"];
    post: operations["PostSubscription"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}": {
    get: operations["GetSubscription"];
    put: operations["PutSubscription"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/change-plan": {
    post: operations["PostSubscriptionPlanChange"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/interim-invoice": {
    post: operations["PostSubscriptionInterimInvoice"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/timeline": {
    get: operations["GetSubscriptionTimelineCollection"];
    post: operations["PostSubscriptionTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/timeline/{messageId}": {
    get: operations["GetSubscriptionTimeline"];
    delete: operations["DeleteSubscriptionTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** The Order Timeline message ID. */
        messageId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/upcoming-invoices": {
    get: operations["GetSubscriptionUpcomingInvoiceCollection"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{id}/upcoming-invoices/{invoiceId}/issue": {
    post: operations["PostUpcomingInvoiceIssuance"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** The Upcoming Invoice ID. */
        invoiceId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tags": {
    get: operations["GetTagCollection"];
    post: operations["PostTag"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tags/{tag}": {
    get: operations["GetTag"];
    patch: operations["PatchTag"];
    delete: operations["DeleteTag"];
    parameters: {
      path: {
        tag: components["parameters"]["tag"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tags/{tag}/customers": {
    post: operations["PostTagCustomerCollection"];
    delete: operations["DeleteTagCustomerCollection"];
    parameters: {
      path: {
        tag: components["parameters"]["tag"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tags/{tag}/customers/{customerId}": {
    post: operations["PostTagCustomer"];
    delete: operations["DeleteTagCustomer"];
    parameters: {
      path: {
        tag: components["parameters"]["tag"];
        customerId: components["parameters"]["customerId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tokens": {
    post: operations["PostToken"];
    get: operations["GetTokenCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/tokens/{token}": {
    get: operations["GetToken"];
    parameters: {
      path: {
        /** The token identifier string. */
        token: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/digital-wallets/validation": {
    post: operations["PostDigitalWalletValidation"];
  };
  "/transactions": {
    post: operations["PostTransaction"];
    get: operations["GetTransactionCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}": {
    get: operations["GetTransaction"];
    patch: operations["PatchTransaction"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/payouts": {
    post: operations["PostPayout"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}/cancel": {
    post: operations["PostTransactionCancellation"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}/gateway-logs": {
    get: operations["GetTransactionGatewayLogCollection"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}/refund": {
    post: operations["PostTransactionRefund"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}/timeline": {
    get: operations["GetTransactionTimelineCollection"];
    post: operations["PostTransactionTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/transactions/{id}/timeline/{messageId}": {
    get: operations["GetTransactionTimeline"];
    delete: operations["DeleteTransactionTimeline"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
        /** The Transaction Timeline message ID. */
        messageId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/activation/{token}": {
    post: operations["PostActivation"];
    parameters: {
      path: {
        /** The token string. */
        token: string;
      };
    };
  };
  "/api-keys": {
    get: operations["GetApiKeyCollection"];
    post: operations["PostApiKey"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/api-keys/{id}": {
    get: operations["GetApiKey"];
    put: operations["PutApiKey"];
    delete: operations["DeleteApiKey"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/broadcast-messages": {
    get: operations["GetBroadcastMessageCollection"];
    post: operations["PostBroadcastMessage"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/broadcast-messages/{id}": {
    get: operations["GetBroadcastMessage"];
    delete: operations["DeleteBroadcastMessage"];
    patch: operations["PatchBroadcastMessage"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/checkout-forms": {
    get: operations["GetCheckoutFormCollection"];
    post: operations["PostCheckoutForm"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/checkout-forms/{id}": {
    get: operations["GetCheckoutForm"];
    put: operations["PutCheckoutForm"];
    delete: operations["DeleteCheckoutForm"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/credential-hashes/aws-ses": {
    post: operations["PostAwsSesCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/aws-ses/{hash}": {
    get: operations["GetAwsSesCredentialHash"];
    patch: operations["PatchAwsSesCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/emails": {
    post: operations["PostEmailCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/emails/{hash}": {
    get: operations["GetEmailCredentialHash"];
    patch: operations["PatchEmailCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/mailgun": {
    post: operations["PostMailgunCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/mailgun/{hash}": {
    get: operations["GetMailgunCredentialHash"];
    patch: operations["PatchMailgunCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/oauth2": {
    get: operations["GetOauth2CredentialHashCollection"];
    post: operations["PostOauth2CredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/oauth2/{hash}": {
    get: operations["GetOauth2CredentialHash"];
    patch: operations["PatchOauth2CredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/oauth2/{hash}/items": {
    get: operations["GetOauth2CredentialHashItemCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/plaid": {
    get: operations["GetPlaidCredentialCollection"];
    post: operations["PostPlaidCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/plaid/{hash}": {
    get: operations["GetPlaidCredentialHash"];
    patch: operations["PatchPlaidCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/postmark": {
    post: operations["PostPostmarkCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/postmark/{hash}": {
    get: operations["GetPostmarkCredentialHash"];
    patch: operations["PatchPostmarkCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/sendgrid": {
    post: operations["PostSendGridCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/sendgrid/{hash}": {
    get: operations["GetSendGridCredentialHash"];
    patch: operations["PatchSendGridCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/webhooks": {
    post: operations["PostWebhookCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/webhooks/{hash}": {
    get: operations["GetWebhookCredentialHash"];
    patch: operations["PatchWebhookCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/credential-hashes/experian": {
    get: operations["GetExperianCredentialHashCollection"];
    post: operations["PostExperianCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/credential-hashes/experian/{hash}": {
    get: operations["GetExperianCredentialHash"];
    patch: operations["PatchExperianCredentialHash"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        hash: components["parameters"]["hash"];
      };
    };
  };
  "/email-delivery-setting-verifications/{token}": {
    put: operations["VerifyEmailDeliverySettings"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        token: components["parameters"]["token"];
      };
    };
  };
  "/email-delivery-settings": {
    get: operations["GetEmailDeliverySettingCollection"];
    post: operations["PostEmailDeliverySetting"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/email-delivery-settings/{id}": {
    get: operations["GetEmailDeliverySetting"];
    delete: operations["DeleteEmailDeliverySetting"];
    patch: operations["PatchEmailDeliverySettings"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/email-delivery-settings/{id}/resend-email-verification": {
    post: operations["ResendEmailDeliverySettingVerification"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/email-messages": {
    get: operations["GetEmailMessageCollection"];
    post: operations["PostEmailMessage"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/email-messages/{id}": {
    get: operations["GetEmailMessage"];
    delete: operations["DeleteEmailMessage"];
    patch: operations["PatchEmailMessage"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/email-notifications": {
    get: operations["GetEmailNotificationCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/events": {
    get: operations["GetEventCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/events/{eventType}": {
    get: operations["GetEvent"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        eventType: components["parameters"]["systemEventType"];
      };
    };
  };
  "/events/{eventType}/rules": {
    get: operations["GetEventRuleCollection"];
    put: operations["PutEventRuleCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        eventType: components["parameters"]["systemEventType"];
      };
    };
  };
  "/events/{eventType}/rules/history": {
    get: operations["GetEventRuleHistoryCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        eventType: components["parameters"]["systemEventType"];
      };
    };
  };
  "/events/{eventType}/rules/history/{version}": {
    get: operations["GetEventRuleHistoryVersion"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        eventType: components["parameters"]["systemEventType"];
        version: components["parameters"]["rulesVersion"];
      };
    };
  };
  "/events/{eventType}/rules/versions/{version}": {
    get: operations["GetEventRuleVersion"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        eventType: components["parameters"]["systemEventType"];
        version: components["parameters"]["rulesVersion"];
      };
    };
  };
  "/forgot-password": {
    post: operations["PostForgotPasswordRequest"];
  };
  "/gateway-accounts": {
    get: operations["GetGatewayAccountCollection"];
    post: operations["PostGatewayAccount"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/gateway-accounts/{id}": {
    get: operations["GetGatewayAccount"];
    put: operations["PutGatewayAccount"];
    patch: operations["PatchGatewayAccount"];
    delete: operations["DeleteGatewayAccount"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/close": {
    post: operations["PostGatewayAccountClosure"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/disable": {
    post: operations["PostGatewayAccountDisablement"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/downtime-schedules": {
    get: operations["GetGatewayAccountDowntimeScheduleCollection"];
    post: operations["PostGatewayAccountDowntimeSchedule"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/downtime-schedules/{downtimeId}": {
    get: operations["GetGatewayAccountDowntimeSchedule"];
    put: operations["PutGatewayAccountDowntimeSchedule"];
    delete: operations["DeleteGatewayAccountDowntimeSchedule"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
        /** The Gateway Account downtime schedule ID. */
        downtimeId: string;
      };
    };
  };
  "/gateway-accounts/{id}/enable": {
    post: operations["PostGatewayAccountEnablement"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/limits": {
    get: operations["GetGatewayAccountLimitCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/limits/{limitId}": {
    get: operations["GetGatewayAccountLimit"];
    put: operations["PutGatewayAccountLimit"];
    delete: operations["DeleteGatewayAccountLimit"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
        /** The gateway account limit ID. */
        limitId:
          | "daily-money"
          | "monthly-money"
          | "daily-count"
          | "monthly-count";
      };
    };
  };
  "/gateway-accounts/{id}/timeline": {
    get: operations["GetGatewayAccountTimelineCollection"];
    post: operations["PostGatewayAccountTimeline"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/gateway-accounts/{id}/timeline/{messageId}": {
    get: operations["GetGatewayAccountTimeline"];
    delete: operations["DeleteGatewayAccountTimeline"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
        /** The Gateway Account Timeline message ID. */
        messageId: string;
      };
    };
  };
  "/grid-segments": {
    get: operations["GetGridSegmentCollection"];
    post: operations["PostGridSegment"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/grid-segments/{id}": {
    get: operations["GetGridSegment"];
    put: operations["PutGridSegment"];
    delete: operations["DeleteGridSegment"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/integrations": {
    get: operations["GetIntegrationCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/integrations/{label}": {
    get: operations["GetIntegration"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        label: components["parameters"]["integrationLabel"];
      };
    };
  };
  "/lists": {
    get: operations["GetListCollection"];
    post: operations["PostList"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/lists/{id}": {
    get: operations["GetList"];
    put: operations["PutList"];
    delete: operations["DeleteList"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/lists/{id}/{version}": {
    get: operations["GetListVersion"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
        /** List version. */
        version: number;
      };
    };
  };
  "/logout": {
    post: operations["PostLogoutRequest"];
  };
  "/memberships": {
    get: operations["GetMembershipCollection"];
  };
  "/memberships/{organizationId}/{userId}": {
    get: operations["GetMembership"];
    put: operations["PutMembership"];
    delete: operations["DeleteMembership"];
    parameters: {
      path: {
        /** Organization identifier. */
        organizationId: components["schemas"]["ResourceId"];
        /** User identifier. */
        userId: components["schemas"]["ResourceId"];
      };
    };
  };
  "/organizations": {
    get: operations["GetOrganizationCollection"];
    post: operations["PostOrganization"];
  };
  "/organizations/{id}": {
    get: operations["GetOrganization"];
    put: operations["PutOrganization"];
    delete: operations["DeleteOrganization"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/payment-cards-bank-names": {
    get: operations["GetPaymentCardBankNameCollection"];
  };
  "/previews/rule-actions/send-email": {
    post: operations["PostPreviewRuleActionEmailSending"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/previews/rule-actions/trigger-webhook": {
    post: operations["PostPreviewRuleActionWebhookTrigger"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/previews/webhooks": {
    post: operations["PostPreviewWebhook"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/profile": {
    get: operations["GetProfile"];
    put: operations["PutProfile"];
  };
  "/profile/password": {
    post: operations["PostProfilePasswordChange"];
  };
  "/profile/totp-reset": {
    post: operations["PostProfileTotpReset"];
  };
  "/reset-password/{token}": {
    get: operations["GetPasswordResetToken"];
    post: operations["PostPasswordReset"];
    parameters: {
      path: {
        /** The token string. */
        token: string;
      };
    };
  };
  "/send-through-attribution/{eventType}": {
    get: operations["GetSendThroughAttributionCollection"];
    parameters: {
      path: {
        eventType: components["parameters"]["systemEventType"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/signin": {
    post: operations["PostSigninRequest"];
  };
  "/signup": {
    post: operations["PostSignupRequest"];
  };
  "/status": {
    get: operations["GetStatus"];
  };
  "/tracking/api": {
    get: operations["GetTrackingApiCollection"];
  };
  "/tracking/api/{id}": {
    get: operations["GetTrackingApi"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/tracking/lists": {
    get: operations["GetTrackingListCollection"];
  };
  "/tracking/webhooks": {
    get: operations["GetTrackingWebhookCollection"];
  };
  "/tracking/webhooks/{id}": {
    get: operations["GetTrackingWebhook"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/tracking/webhooks/{id}/history": {
    get: operations["GetTrackingWebhookHistoryCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/tracking/webhooks/{id}/resend": {
    post: operations["PostTrackingWebhookResendRequest"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/users": {
    get: operations["GetUserCollection"];
    post: operations["PostUser"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/users/{id}": {
    get: operations["GetUser"];
    put: operations["PutUser"];
    delete: operations["DeleteUser"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/users/{id}/password": {
    post: operations["PostUserPasswordChange"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/users/{id}/totp-reset": {
    post: operations["PostUserTotpReset"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/webhooks": {
    get: operations["GetWebhookCollection"];
    post: operations["PostWebhook"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/webhooks/{id}": {
    get: operations["GetWebhook"];
    put: operations["PutWebhook"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/websites": {
    get: operations["GetWebsiteCollection"];
    post: operations["PostWebsite"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/websites/{id}": {
    get: operations["GetWebsite"];
    put: operations["PutWebsite"];
    delete: operations["DeleteWebsite"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/customers/{customerId}/summary-metrics": {
    get: operations["GetCustomerSummaryMetricReport"];
    parameters: {
      path: {
        /** Customer's ID. */
        customerId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/data-exports": {
    post: operations["PostDataExport"];
    get: operations["GetDataExportCollection"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/data-exports/{id}": {
    get: operations["GetDataExport"];
    put: operations["PutDataExport"];
    delete: operations["DeleteDataExport"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/histograms/transactions": {
    get: operations["GetHistogramTransactionReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/experimental/organizations": {
    post: operations["ExperimentalPostOrganization"];
  };
  "/experimental/organizations/{id}": {
    patch: operations["PatchOrganization"];
    parameters: {
      path: {
        id: components["parameters"]["resourceId"];
      };
    };
  };
  "/reports/api-log-summary": {
    get: operations["GetApiLogSummaryReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/cumulative-subscriptions": {
    get: operations["GetCumulativeSubscriptionReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/dashboard": {
    get: operations["GetDashboardReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/dcc-markup": {
    get: operations["GetDccMarkupReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/disputes": {
    get: operations["GetDisputeReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/events-triggered": {
    get: operations["GetTriggeredEventReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/events-triggered/{eventType}/rules": {
    get: operations["GetTriggeredEventRuleReport"];
    parameters: {
      path: {
        /** The system event type. */
        eventType: components["schemas"]["EventType"];
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/future-renewals": {
    get: operations["GetFutureRenewalReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/renewal-sales": {
    get: operations["GetRenewalSaleReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/retention-percentage": {
    get: operations["GetRetentionPercentageReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/retention-value": {
    get: operations["GetRetentionValueReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/retry-transaction": {
    get: operations["GetTransactionRetryReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/subscription-cancellation": {
    get: operations["GetSubscriptionCancellationReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/subscription-renewal": {
    get: operations["GetSubscriptionRenewalReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/time-series-transaction": {
    get: operations["GetTimeSeriesTransactionReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/transactions-time-dispute": {
    get: operations["GetTransactionTimeDisputeReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/reports/transactions": {
    get: operations["GetTransactionReport"];
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
  "/subscriptions/{subscriptionId}/summary-metrics": {
    get: operations["GetSubscriptionSummaryMetricReport"];
    parameters: {
      path: {
        /** Order's ID. */
        subscriptionId: string;
      };
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
    };
  };
}

export interface operations {
  Get3DSecureCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ThreeDSecure"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a ThreeDSecure entry. */
  Post3DSecure: {
    requestBody: {
      "application/json": components["schemas"]["ThreeDSecure"];
    };
    responses: {
      /** ThreeDSecure entry was created. */
      201: {
        "application/json": components["schemas"]["ThreeDSecure"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a ThreeDSecure entry with specified identifier string. */
  Get3DSecure: {
    responses: {
      /** ThreeDSecure entry was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ThreeDSecure"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Retrieve a list of attachments.
   * You may sort by the id, name, relatedId, relatedType, fileId, createdTime, and updatedTime.
   */
  GetAttachmentCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        expand?: components["parameters"]["collectionExpand"];
        fields?: components["parameters"]["collectionFields"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of Attachments was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Attachment"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an Attachment. */
  PostAttachment: {
    requestBody: {};
    responses: {
      /** Attachment was created. */
      201: {
        "application/json": components["schemas"]["Attachment"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Attachment with specified identifier string. */
  GetAttachment: {
    responses: {
      /** Attachment was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Attachment"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update the Attachment with predefined ID. */
  PutAttachment: {
    requestBody: {};
    responses: {
      /** Attachment was updated. */
      200: {
        "application/json": components["schemas"]["Attachment"];
      };
      /** Attachment was created. */
      201: {
        "application/json": components["schemas"]["Attachment"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete the Attachment with predefined identifier string. */
  DeleteAttachment: {
    responses: {
      /** Attachment was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Read current authentication options. */
  GetAuthenticationOption: {
    responses: {
      /** Current authentication options was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["AuthenticationOptions"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Change options. */
  PutAuthenticationOption: {
    requestBody: {
      "application/json": components["schemas"]["AuthenticationOptions"];
    };
    responses: {
      /** Authentication Options were updated. */
      200: {
        "application/json": components["schemas"]["AuthenticationOptions"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of auth tokens. */
  GetAuthenticationTokenCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of auth tokens was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["AuthenticationToken"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Login a customer. */
  PostAuthenticationToken: {
    requestBody: {
      "application/json": components["schemas"]["AuthenticationToken"];
    };
    responses: {
      /** Login successful. */
      201: {
        "application/json": components["schemas"]["AuthenticationToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Verify an authentication token. */
  GetAuthenticationTokenVerification: {
    responses: {
      /** Authentication Token was verified. */
      200: {
        "application/json": components["schemas"]["AuthenticationToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Logout a customer. */
  DeleteAuthenticationToken: {
    responses: {
      /** Customer was logged out. */
      204: never;
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Exchange Authentication Token for JWT.
   *
   * It will also invalidate an Authentication Token by default (so it can only be exchanged once).
   */
  PostAuthenticationTokenExchange: {
    requestBody: {
      "application/json": components["schemas"]["CustomerJWT"];
    };
    responses: {
      /** Authentication Token exchanged for JWT. */
      201: {
        "application/json": components["schemas"]["CustomerJWT"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a Bank Account. */
  PostBankAccount: {
    requestBody: {
      "application/json":
        | components["schemas"]["BankAccountCreateToken"]
        | components["schemas"]["BankAccountCreatePlain"];
    };
    responses: {
      /** Bank Account was created. */
      201: {
        "application/json": components["schemas"]["BankAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of Bank Accounts. */
  GetBankAccountCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Bank Accounts was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["BankAccount"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a Bank Account with specified identifier string. */
  GetBankAccount: {
    responses: {
      /** Bank Account was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["BankAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update bank account's values except for the account number and routing. number. */
  PatchBankAccount: {
    requestBody: {
      "application/json": components["schemas"]["BankAccountUpdatePlain"];
    };
    responses: {
      /** Bank Account was updated. */
      200: {
        "application/json": components["schemas"]["BankAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create or update a BankAccount with predefined identifier string. */
  PutBankAccount: {
    requestBody: {
      "application/json":
        | components["schemas"]["BankAccountCreateToken"]
        | components["schemas"]["BankAccountCreatePlain"];
    };
    responses: {
      /** BankAccount was updated. */
      200: {
        "application/json": components["schemas"]["BankAccount"];
      };
      /** BankAccount was created. */
      201: {
        "application/json": components["schemas"]["BankAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Deactivate a Bank Account. */
  PostBankAccountDeactivation: {
    responses: {
      /** Bank Account was deactivated. */
      201: {
        "application/json": components["schemas"]["BankAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of blocklists. */
  GetBlocklistCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Blocklists was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Blocklist"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a blocklist. */
  PostBlocklist: {
    requestBody: {};
    responses: {
      /** Blocklist was created. */
      201: {
        "application/json": components["schemas"]["Blocklist"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a blocklist with specified identifier string. */
  GetBlocklist: {
    responses: {
      /** Blocklist was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Blocklist"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a blocklist with predefined identifier string. */
  PutBlocklist: {
    requestBody: {};
    responses: {
      /** Blocklist was created. */
      201: {
        "application/json": components["schemas"]["Blocklist"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Blocklist exist and cannot be updated. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a blocklist with predefined identifier string. */
  DeleteBlocklist: {
    responses: {
      /** Blocklist was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  GetCouponRedemptionCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** Coupons redemptions were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CouponRedemption"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Redeem a coupon. */
  PostCouponRedemption: {
    requestBody: {
      "application/json": components["schemas"]["CouponRedemption"];
    };
    responses: {
      /** Coupon was redeemed. */
      201: {
        "application/json": components["schemas"]["CouponRedemption"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  GetCouponRedemption: {
    responses: {
      /** Retrieve a coupon redemption with specified identifier string. */
      200: {
        "application/json": components["schemas"]["CouponRedemption"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  PostCouponRedemptionCancellation: {
    responses: {
      /** Cancel a coupon redemption. */
      201: unknown;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of coupons. */
  GetCouponCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of coupons was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Coupon"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a coupon. */
  PostCoupon: {
    requestBody: {};
    responses: {
      /** Coupon was created. */
      201: {
        "application/json": components["schemas"]["Coupon"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a coupon with specified coupon ID string. */
  GetCoupon: {
    responses: {
      /** Coupon was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Coupon"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a coupon with predefined coupon ID. */
  PutCoupon: {
    requestBody: {};
    responses: {
      /** Coupon was updated. */
      200: {
        "application/json": components["schemas"]["Coupon"];
      };
      /** Coupon was created. */
      201: {
        "application/json": components["schemas"]["Coupon"];
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Set a coupon's expiry time with the specified coupon ID.
   * The expiredTime of a coupon must be greater than its issuedTime.
   * This cannot be performed on expired coupons.
   */
  PostCouponExpiration: {
    requestBody: {
      "application/json": components["schemas"]["CouponExpiration"];
    };
    responses: {
      /** Coupon expiration was successfully set. */
      201: {
        "application/json": components["schemas"]["Coupon"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** The coupon is already expired and has been redeemed, unable to. reschedule expiration. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of credentials. */
  GetCredentialCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Credentials was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Credential"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a credential. */
  PostCredential: {
    requestBody: {};
    responses: {
      /** Credential was created. */
      201: {
        "application/json": components["schemas"]["Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a credential with specified identifier string. */
  GetCredential: {
    responses: {
      /** Credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a credential with predefined identifier string. */
  PutCredential: {
    requestBody: {};
    responses: {
      /** Credential was updated. */
      200: {
        "application/json": components["schemas"]["Credential"];
      };
      /** Credential was created. */
      201: {
        "application/json": components["schemas"]["Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a credential with predefined identifier string. */
  DeleteCredential: {
    responses: {
      /** Credential was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a schema of Custom Fields for the given resource type. */
  GetCustomFieldCollection: {
    responses: {
      /** A schema of Custom Fields was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomField"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a schema of the given Custom Field for the given resource type. */
  GetCustomField: {
    responses: {
      /** A schema of the Custom Field was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomField"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or alter a schema of the given Custom Field for the given resource. type. */
  PutCustomField: {
    requestBody: {
      "application/json": components["schemas"]["CustomField"];
    };
    responses: {
      /** The Custom Field was updated. */
      200: {
        "application/json": components["schemas"]["CustomField"];
      };
      /** The Custom Fields was created. */
      201: {
        "application/json": components["schemas"]["CustomField"];
      };
      401: components["responses"]["Unauthorized"];
      /** The schema is in use: remove all the associated data in order to remove or alter the schema. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of customers. */
  GetCustomerCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        expand?: components["parameters"]["collectionExpand"];
        fields?: components["parameters"]["collectionFields"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of Customers was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Customer"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a customer without a predefined ID.
   * The customer's primary address
   * will be used as the default address for payment
   * instruments, subscriptions and invoices if none
   * are provided.
   *
   * If you wish to create the customer with a predefined
   * ID (which we recommend to prevent duplication), you
   * may use our `PUT` request described below.
   *
   * Read our guide to [preventing duplicates](https://api-guides.rebilly.com/core-concepts/preventing-duplicates)
   * to understand more.
   */
  PostCustomer: {
    requestBody: {};
    responses: {
      201: components["responses"]["Customer"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a customer with specified identifier string. */
  GetCustomer: {
    responses: {
      /** Customer was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Customer"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create or update (upsert) a customer with predefined identifier string.
   * Read our guide to [preventing duplicates](https://api-guides.rebilly.com/core-concepts/preventing-duplicates)
   * to understand more.
   */
  PutCustomer: {
    requestBody: {};
    responses: {
      200: components["responses"]["Customer"];
      201: components["responses"]["Customer"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Merge one duplicate customer to another target customer and delete the. former. */
  DeleteCustomer: {
    parameters: {
      query: {
        /** The customer identifier to get the data of the deleted duplicate customer. */
        targetCustomerId: string;
      };
    };
    responses: {
      /** Customer has been merged and removed. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of customer timeline custom event types. */
  GetCustomerTimelineCustomEventTypeCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of customer timeline custom event types was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerTimelineCustomEvent"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create Customer Timeline custom event type. */
  PostCustomerTimelineCustomEventType: {
    requestBody: {
      "application/json": components["schemas"]["CustomerTimelineCustomEvent"];
    };
    responses: {
      /** Customer Timeline Custom Event Type was created. */
      201: {
        "application/json": components["schemas"]["CustomerTimelineCustomEvent"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve customer timeline custom event type. */
  GetCustomerTimelineCustomEventType: {
    responses: {
      /** Customer Timeline custom event type was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerTimelineCustomEvent"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a list of customer timeline messages for all customers. */
  GetCustomerTimelineEventCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of customer timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a Lead Source of given customer. */
  GetCustomerLeadSource: {
    responses: {
      /** Lead Source was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["LeadSource"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a Lead Source for a customer. */
  PutCustomerLeadSource: {
    requestBody: {
      "application/json": components["schemas"]["LeadSource"];
    };
    responses: {
      /** Lead Source was created. */
      201: {
        "application/json": components["schemas"]["LeadSource"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a Lead Source that belongs to a certain customer. */
  DeleteCustomerLeadSource: {
    responses: {
      /** Lead Source was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of customer timeline messages. */
  GetCustomerTimelineCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of customer timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a customer Timeline comment or custom defined event. */
  PostCustomerTimeline: {
    requestBody: {
      "application/json": components["schemas"]["CustomerTimeline"];
    };
    responses: {
      /** Customer Timeline comment or custom defined event was created. */
      201: {
        "application/json": components["schemas"]["CustomerTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a customer message with specified identifier string. */
  GetCustomerTimeline: {
    responses: {
      /** Customer message was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete a Customer Timeline message with predefined identifier string. */
  DeleteCustomerTimeline: {
    responses: {
      /** Customer Timeline message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /**
   * Retrieve a list of upcoming invoices from the subscriptions which belong to. the given customer.
   * The endpoint is temporary before upcoming invoices get a complete integration.
   */
  GetCustomerUpcomingInvoiceCollection: {
    parameters: {
      query: {
        expand?: components["parameters"]["collectionExpand"];
      };
    };
    responses: {
      /** Upcoming invoices are retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Invoice"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of disputes. */
  GetDisputeCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of disputes was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Dispute"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a dispute. */
  PostDispute: {
    requestBody: {};
    responses: {
      /** Dispute was created. */
      201: {
        "application/json": components["schemas"]["Dispute"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a dispute with specified identifier string. */
  GetDispute: {
    responses: {
      /** Dispute was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Dispute"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a Dispute with predefined identifier string. */
  PutDispute: {
    requestBody: {};
    responses: {
      /** Dispute was updated. */
      200: {
        "application/json": components["schemas"]["Dispute"];
      };
      /** Dispute was created. */
      201: {
        "application/json": components["schemas"]["Dispute"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of files. */
  GetFileCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        expand?: components["parameters"]["collectionExpand"];
        fields?: components["parameters"]["collectionFields"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of Files was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["File"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Additionally, a file can be sent with:.
   *  - multipart/form-data POST request: in this case all property names are the same as the JSON ones (`file` is an uploaded file)
   *  - file body request: the file body is sent as the request body, with the appropriate `Content-Type`. No additional
   *  properties can be set along the request data
   *
   * The following file types only are allowed:
   *  - jpg
   *  - png
   *  - gif
   *  - pdf
   *  - mp3
   *
   *
   * If using a Publishable Api Key, only private files can be created. The files can later on be modified or used using
   *  a secret API key.
   */
  PostFile: {
    requestBody: {
      "application/json":
        | components["schemas"]["FileCreateFromInline"]
        | components["schemas"]["FileCreateFromUrl"];
    };
    responses: {
      /** File was created. */
      201: {
        "application/json": components["schemas"]["File"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a File with specified identifier string. */
  GetFile: {
    responses: {
      /** File was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["File"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update the File with predefined ID. Note that file can be uploaded with POST. only. */
  PutFile: {
    requestBody: {
      "application/json": components["schemas"]["File"];
    };
    responses: {
      /** File was updated. */
      200: {
        "application/json": components["schemas"]["File"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete the File with predefined identifier string. */
  DeleteFile: {
    responses: {
      /** File was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Download a file. */
  GetFileDownload: {
    responses: {
      /** The file was retrieved successfully. */
      200: {
        "application/json": string;
      };
      302: components["responses"]["Found"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Download image in specific format. Images are converted server-side. */
  GetFileDownloadExtension: {
    responses: {
      /** The file was retrieved successfully. */
      200: {
        "application/json": string;
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of invoices. */
  GetInvoiceCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of invoices was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Invoice"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an invoice. */
  PostInvoice: {
    requestBody: {};
    responses: {
      /** Invoice was created. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an invoice with specified identifier string. */
  GetInvoice: {
    parameters: {
      header: {
        Accept?: components["parameters"]["mediaTypeJsonPdf"];
      };
    };
    responses: {
      /** Invoice was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Invoice"];
        "application/pdf": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update an invoice with predefined identifier string. */
  PutInvoice: {
    requestBody: {};
    responses: {
      /** Invoice was updated. */
      200: {
        "application/json": components["schemas"]["Invoice"];
      };
      /** Invoice was created. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Abandon an invoice with specified identifier string. */
  PostInvoiceAbandonment: {
    responses: {
      /** Invoice was abandoned successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Issue an invoice with specified identifier string. It must be in `draft` status. */
  PostInvoiceIssuance: {
    requestBody: {
      "application/json": components["schemas"]["InvoiceIssue"];
    };
    responses: {
      /** Invoice was issued successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve an invoice items with specified invoice identifier string. */
  GetInvoiceItemCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Invoice items were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["InvoiceItem"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create an invoice item. */
  PostInvoiceItem: {
    requestBody: {
      "application/json": components["schemas"]["InvoiceItem"];
    };
    responses: {
      /** InvoiceItem was created. */
      201: {
        "application/json": components["schemas"]["InvoiceItem"];
      };
      401: components["responses"]["Unauthorized"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Recalculate an invoice with specified identifier string.
   * It will recalculate shipping rates, taxes, discounts. It is useful when coupon was revoked or customer redeemed coupon after invoice was issued and you want to apply it to this invoice.
   */
  PostInvoiceRecalculation: {
    responses: {
      /** Invoice was recalculated successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Reissue an invoice with specified identifier string. It must be issued. (status must be `unpaid` or `past-due`). */
  PostInvoiceReissuance: {
    requestBody: {
      "application/json": components["schemas"]["InvoiceReissue"];
    };
    responses: {
      /** Invoice was reissued successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of invoice timeline messages. */
  GetInvoiceTimelineCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of invoice timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["InvoiceTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an invoice Timeline comment. */
  PostInvoiceTimeline: {
    requestBody: {
      "application/json": components["schemas"]["InvoiceTimeline"];
    };
    responses: {
      /** Invoice Timeline comment was created. */
      201: {
        "application/json": components["schemas"]["InvoiceTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a invoice message with specified identifier string. */
  GetInvoiceTimeline: {
    responses: {
      /** Invoice message was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["InvoiceTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete an Invoice Timeline message with predefined identifier string. */
  DeleteInvoiceTimeline: {
    responses: {
      /** Invoice Timeline message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Get the precise amounts from a transaction allocated as invoice payments. */
  GetInvoiceTransactionAllocationCollection: {
    responses: {
      /** List of allocations was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["InvoiceTransactionAllocation"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Void an invoice with specified identifier string. */
  PostInvoiceVoid: {
    responses: {
      /** Invoice was voided successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of KYC documents. */
  GetKycDocumentCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of KYC documents was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["KycDocument"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a KYC Document. */
  PostKycDocument: {
    requestBody: {
      "application/json": components["schemas"]["KycDocument"];
    };
    responses: {
      /** Kyc document was created. */
      201: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a KYC document with specified identifier string. */
  GetKycDocument: {
    responses: {
      /** KYC document was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a KYC document with predefined identifier string. */
  PutKycDocument: {
    requestBody: {
      "application/json": components["schemas"]["KycDocument"];
    };
    responses: {
      /** KYC document was updated. */
      200: {
        "application/json": components["schemas"]["KycDocument"];
      };
      /** KYC document was created. */
      201: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Marks that status of the document as `accepted`. Updates the review time and reviewer information. Intended to be used for manual overrides. */
  PostKycDocumentAcceptance: {
    responses: {
      /** KYC document acceptance was created. */
      201: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Marks that status of the document as `rejected`. Updates the review time and reviewer information. Intended to be used for manual overrides. */
  PostKycDocumentRejection: {
    requestBody: {
      "application/json": components["schemas"]["KycDocumentRejection"];
    };
    responses: {
      /** KYC document rejection was created. */
      201: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Mark the KYC document as reviewed. Updates the review time and reviewer. information. */
  PostKycDocumentReview: {
    responses: {
      /** KYC document was reviewed. */
      201: {
        "application/json": components["schemas"]["KycDocument"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of tokens. */
  GetPasswordTokenCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Reset Password Tokens was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ResetPasswordToken"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Reset Password Token. */
  PostPasswordToken: {
    requestBody: {
      "application/json": components["schemas"]["ResetPasswordToken"];
    };
    responses: {
      /** Reset Password Token was created. */
      201: {
        "application/json": components["schemas"]["ResetPasswordToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Reset Password Token with specified identifier string. */
  GetPasswordToken: {
    responses: {
      /** ResetPasswordToken was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ResetPasswordToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete a Reset Password Token with predefined identifier string. */
  DeletePasswordToken: {
    responses: {
      /** ResetPasswordToken was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of payment instruments. */
  GetPaymentInstrumentCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of payment instruments was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PaymentInstrument-2"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a payment instrument.
   * If such payment card or bank account payment instrument already exists then updates it instead.
   */
  PostPaymentInstrument: {
    requestBody: {};
    responses: {
      /** Payment instrument was created. */
      201: {
        "application/json": components["schemas"]["PaymentInstrument-2"];
      };
      /** Payment instrument was updated. */
      303: {
        "application/json": components["schemas"]["PaymentInstrument-2"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a payment instrument by ID. */
  GetPaymentInstrument: {
    responses: {
      /** Payment Instrument was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PaymentInstrument-2"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update allowed payment instrument's values. */
  PatchPaymentInstrument: {
    requestBody: {};
    responses: {
      /** Payment instrument was updated. */
      200: {
        "application/json": components["schemas"]["PaymentInstrument-2"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Deactivate a payment instrument. */
  PostPaymentInstrumentDeactivation: {
    responses: {
      /** Payment instrument was deactivated. */
      201: {
        "application/json": components["schemas"]["PaymentInstrument-2"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of Payments Cards. */
  GetPaymentCardCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Payment Card was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PaymentCard"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Payment Card. */
  PostPaymentCard: {
    requestBody: {
      "application/json":
        | components["schemas"]["PaymentCardCreateToken"]
        | components["schemas"]["PaymentCardCreatePlain"];
    };
    responses: {
      /** Payment Card was updated. */
      200: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      /** Payment Card was created. */
      201: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Payment Card with specified identifier string. */
  GetPaymentCard: {
    responses: {
      /** Payment card was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update any of the payment card's values except for the pan. */
  PatchPaymentCard: {
    requestBody: {
      "application/json": components["schemas"]["PaymentCardUpdatePlain"];
    };
    responses: {
      /** Payment card was updated. */
      200: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  PutPaymentCard: {
    requestBody: {
      "application/json":
        | components["schemas"]["PaymentCardCreateToken"]
        | components["schemas"]["PaymentCardCreatePlain"];
    };
    responses: {
      /** Payment card was updated. */
      200: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      /** Payment card was created. */
      201: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Payment card already exists and cannot be updated. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Authorize a Payment Card.
   *
   * Instead of using this endpoint a Payment Card will
   * be authorized on first usage (new transaction or order).
   */
  PostPaymentCardAuthorization: {
    requestBody: {
      "application/json": {
        /** The Website ID. */
        websiteId: string;
        currency: components["schemas"]["CurrencyCode"];
        /** The Gateway account ID. */
        gatewayAccountId?: string;
        /** Amount. */
        amount?: number;
        /** Redirect URL. */
        redirectUrl?: string;
      };
    };
    responses: {
      /** Payment Card was authorized. */
      201: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Deactivate a Payment Card. */
  PostPaymentCardDeactivation: {
    responses: {
      /** Payment Card was deactivated. */
      201: {
        "application/json": components["schemas"]["PaymentCard"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve payment methods metadata. */
  GetPaymentMethodCollection: {
    responses: {
      /** Payment methods metadata was received. */
      200: {
        "application/json": components["schemas"]["PaymentMethodMetadata"][];
      };
    };
  };
  /** Retrieve a specified payment method metadata. */
  GetPaymentMethod: {
    responses: {
      /** Payment method metadata was received. */
      200: {
        "application/json": components["schemas"]["PaymentMethodMetadata"];
      };
    };
  };
  /** Retrieve a list of PayPal Accounts. */
  GetPayPalAccountCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of PayPal Accounts was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PayPalAccount"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a PayPal Account. */
  PostPayPalAccount: {
    requestBody: {
      "application/json": components["schemas"]["PayPalAccount"];
    };
    responses: {
      /** PayPal Account was created. */
      201: {
        "application/json": components["schemas"]["PayPalAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a PayPal Account with specified identifier string. */
  GetPayPalAccount: {
    responses: {
      /** PayPal Account was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PayPalAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  PutPayPalAccount: {
    requestBody: {
      "application/json": components["schemas"]["PayPalAccount"];
    };
    responses: {
      /** PayPal Account was created. */
      201: {
        "application/json": components["schemas"]["PayPalAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** PayPal Account exist and cannot be updated. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Activate a PayPal Account.
   *
   * Instead of using this endpoint a PayPal Account will
   * be authorized on first usage (new transaction or order).
   */
  PostPayPalAccountActivation: {
    requestBody: {
      "application/json": components["schemas"]["PayPalAccountAuthorization"];
    };
    responses: {
      /** PayPal Account was activated. */
      201: {
        "application/json": components["schemas"]["PayPalAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Deactivate a PayPal Account. */
  PostPayPalAccountDeactivation: {
    responses: {
      /** PayPal Account was deactivated. */
      201: {
        "application/json": components["schemas"]["PayPalAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /**
   * Start permissions emulation.
   *
   * Emulation during emulation is not supported. If request sent during an ongoing emulation 403 sent in response.
   *
   * Escalation is also not supported.
   */
  PostPermissionsEmulation: {
    requestBody: {
      "application/json": {
        /** The list of permissions to be emulated. */
        permissions: components["schemas"]["AclPermissions"];
      };
    };
    responses: {
      /** Session was created. */
      201: {
        "application/json": components["schemas"]["Session"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /**
   * Stop permissions emulation.
   *
   * Session permissions would be restored to the state before emulation started.
   * If emulations was not started `403` is sent in response.
   */
  DeletePermissionsEmulation: {
    responses: {
      /** Session was restored. */
      201: {
        "application/json": components["schemas"]["Session"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a list of plans. */
  GetPlanCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Plans was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Plan"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a plan. */
  PostPlan: {
    requestBody: {};
    responses: {
      /** Plan was created. */
      201: {
        "application/json": components["schemas"]["Plan"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a plan with specified identifier string. */
  GetPlan: {
    responses: {
      /** Plan was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Plan"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a Plan with predefined identifier string. */
  PutPlan: {
    requestBody: {};
    responses: {
      /** Plan was updated. */
      200: {
        "application/json": components["schemas"]["Plan"];
      };
      /** Plan was created. */
      201: {
        "application/json": components["schemas"]["Plan"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a Plan with predefined identifier string. */
  DeletePlan: {
    responses: {
      /** Plan was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of products. */
  GetProductCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of products was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Product"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Product. */
  PostProduct: {
    requestBody: {};
    responses: {
      /** Product was created. */
      201: {
        "application/json": components["schemas"]["Product"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a product with specified identifier string. */
  GetProduct: {
    responses: {
      /** Product was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Product"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a product with predefined identifier string. */
  PutProduct: {
    requestBody: {};
    responses: {
      /** Product was updated. */
      200: {
        "application/json": components["schemas"]["Product"];
      };
      /** Product was created. */
      201: {
        "application/json": components["schemas"]["Product"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a product with predefined identifier string. */
  DeleteProduct: {
    responses: {
      /** Product was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Search merchant's data to return resources such as customers, invoices, orders, transactions. */
  GetSearch: {
    parameters: {
      query: {
        /** The default search. It will search across resources and many fields. */
        q?: string;
      };
    };
    responses: {
      /** Results keyed by resource. */
      200: {
        "application/json": components["schemas"]["Search"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a list of shipping zones. */
  GetShippingZoneCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of shipping zones was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ShippingZone"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Shipping Zone. */
  PostShippingZone: {
    requestBody: {
      "application/json": components["schemas"]["ShippingZone"];
    };
    responses: {
      /** Shipping Zone was created. */
      201: {
        "application/json": components["schemas"]["ShippingZone"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a shipping zone with specified identifier string. */
  GetShippingZone: {
    responses: {
      /** Shipping zone was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ShippingZone"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a shipping zone with predefined identifier string. */
  PutShippingZone: {
    requestBody: {
      "application/json": components["schemas"]["ShippingZone"];
    };
    responses: {
      /** Shipping zone was updated. */
      200: {
        "application/json": components["schemas"]["ShippingZone"];
      };
      /** Shipping zone was created. */
      201: {
        "application/json": components["schemas"]["ShippingZone"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a shipping zone with predefined identifier string. */
  DeleteShippingZone: {
    responses: {
      /** Shipping zone was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of cancellations for all subscriptions. */
  GetSubscriptionCancellationCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of cancellations was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionCancellation"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Cancel an order or preview the cancellation parameters before that. */
  PostSubscriptionCancellation: {
    requestBody: {};
    responses: {
      /** Cancellation was created, the order is or will be deactivated. */
      201: {
        "application/json": components["schemas"]["SubscriptionCancellation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an order ancellation with specified identifier string. */
  GetSubscriptionCancellation: {
    responses: {
      /** Cancellation was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionCancellation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Cancel a subscription. */
  PutSubscriptionCancellation: {
    requestBody: {};
    responses: {
      /** Cancellation was updated, the order is or will be deactivated. */
      200: {
        "application/json": components["schemas"]["SubscriptionCancellation"];
      };
      /** Cancellation was created, the order is or will be deactivated. */
      201: {
        "application/json": components["schemas"]["SubscriptionCancellation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete an order's cancellation. Only draft can be deleted. */
  DeleteSubscriptionCancellation: {
    responses: {
      /** Cancellaton was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of reactivations for all subscriptions. */
  GetSubscriptionReactivationCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of reactivations was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionReactivation"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Reactivate a subscription. */
  PostSubscriptionReactivation: {
    requestBody: {
      "application/json": components["schemas"]["SubscriptionReactivation"];
    };
    responses: {
      /**
       * Reactivation was created, the order is active and won't be. deactivated.
       * If there was a cancellation with status "confirmed", it is revoked.
       */
      201: {
        "application/json": components["schemas"]["SubscriptionReactivation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an order reactivation with specified identifier string. */
  GetSubscriptionReactivation: {
    responses: {
      /** Reactivation was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionReactivation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of orders. */
  GetSubscriptionCollection: {
    parameters: {
      query: {
        expand?: components["parameters"]["subscriptionExpand"];
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of subscriptions was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Subscription"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create an order. Consider using the upsert.
   * operation to accomplish this task.
   */
  PostSubscription: {
    parameters: {
      query: {
        expand?: components["parameters"]["subscriptionExpand"];
      };
    };
    requestBody: {};
    responses: {
      /** Order was created. */
      201: {
        "application/json": components["schemas"]["Subscription"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an order with specified identifier string. */
  GetSubscription: {
    parameters: {
      query: {
        expand?: components["parameters"]["subscriptionExpand"];
      };
    };
    responses: {
      /** Order was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Subscription"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update an order with predefined identifier string. */
  PutSubscription: {
    parameters: {
      query: {
        expand?: components["parameters"]["subscriptionExpand"];
      };
    };
    requestBody: {};
    responses: {
      /** Order was updated. */
      200: {
        "application/json": components["schemas"]["Subscription"];
      };
      /** Order was created. */
      201: {
        "application/json": components["schemas"]["Subscription"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Change an order's plan and designate when and if there should be pro-rata credits given.
   * Only active subscription orders with a single plan can be changed.
   * Edit pending unpaid orders directly regardless the number of plans.
   */
  PostSubscriptionPlanChange: {
    requestBody: {
      "application/json": components["schemas"]["SubscriptionChange"];
    };
    responses: {
      /** Order was changed. */
      201: {
        "application/json": components["schemas"]["Subscription"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Issue an interim invoice for a subscription, typically used in conjunction. with plan changes and pro rata adjustments.
   * This process creates an invoice, adds the subscription's line items to the invoice, and issues the invoice, and applies
   * payment to it if a transaction id is supplied.
   */
  PostSubscriptionInterimInvoice: {
    requestBody: {
      "application/json": components["schemas"]["SubscriptionInvoice"];
    };
    responses: {
      /** Invoice was created. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of order timeline messages. */
  GetSubscriptionTimelineCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of order timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["OrderTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
    };
  };
  /** Create an order Timeline comment. */
  PostSubscriptionTimeline: {
    requestBody: {
      "application/json": components["schemas"]["OrderTimeline"];
    };
    responses: {
      /** Order Timeline comment was created. */
      201: {
        "application/json": components["schemas"]["OrderTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a order message with specified identifier string. */
  GetSubscriptionTimeline: {
    responses: {
      /** Order message was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["OrderTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete an Order Timeline message with predefined identifier string. */
  DeleteSubscriptionTimeline: {
    responses: {
      /** Order Timeline message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /**
   * Retrieve an upcoming invoice from the specified subscription order.
   * The endpoint is temporary before upcoming invoices get a complete integration.
   */
  GetSubscriptionUpcomingInvoiceCollection: {
    parameters: {
      query: {
        expand?: components["parameters"]["collectionExpand"];
      };
    };
    responses: {
      /** Upcoming invoices are retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Invoice"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Issue an upcoming invoice with specified identifier string for early pay. */
  PostUpcomingInvoiceIssuance: {
    requestBody: {
      "application/json": components["schemas"]["InvoiceIssue"];
    };
    responses: {
      /** Upcoming Invoice was issued successfully. */
      201: {
        "application/json": components["schemas"]["Invoice"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of tags. */
  GetTagCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of tags was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Tag"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a tag. */
  PostTag: {
    requestBody: {};
    responses: {
      /** Tag was created. */
      201: {
        "application/json": components["schemas"]["Tag"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a tag. */
  GetTag: {
    responses: {
      /** Tag with specified name was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Tag"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a tag. */
  PatchTag: {
    requestBody: {};
    responses: {
      /** Tag was updated. */
      200: {
        "application/json": components["schemas"]["Tag"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Delete a tag.
   * It's an asynchronous operation.
   */
  DeleteTag: {
    responses: {
      /** Tag was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Tag a list of customers.
   * If the customer from the list is already tagged it will be ignored.
   * It's an asynchronous operation.
   */
  PostTagCustomerCollection: {
    requestBody: {
      "application/json": {
        /** The list of customer IDs. */
        customerIds: string[];
      };
    };
    responses: {
      /** Customers was tagged. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Untag a list of customers.
   * If the customer from the list is already untagged it will be ignored.
   * It's an asynchronous operation.
   */
  DeleteTagCustomerCollection: {
    requestBody: {
      "application/json": {
        /** The list of customer IDs. */
        customerIds: string[];
      };
    };
    responses: {
      /** Customers was untagged. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Tag a customer. */
  PostTagCustomer: {
    responses: {
      /** Customer was tagged. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Untag a customer. */
  DeleteTagCustomer: {
    responses: {
      /** Customer was untagged. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/)
   * is the recommended way to
   * create a payment token because it minimizes
   * PCI DSS compliance.  Once a payment token
   * is created, it can only be used once.
   *
   * A payment token expires upon first use
   * or within 30 minutes of the token creation
   * (whichever comes first).
   */
  PostToken: {
    requestBody: {
      "application/json": components["schemas"]["CompositeToken"];
    };
    responses: {
      /** Token was created. */
      201: {
        "application/json": components["schemas"]["CompositeToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of tokens. */
  GetTokenCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of tokens was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CompositeToken"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a token with specified identifier string. */
  GetToken: {
    responses: {
      /** Token was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CompositeToken"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/)
   * is the recommended way to use when validating a digital wallet session.
   */
  PostDigitalWalletValidation: {
    requestBody: {
      "application/json": components["schemas"]["DigitalWalletValidation"];
    };
    responses: {
      /** Digital wallet validation was made. */
      201: {
        "application/json": components["schemas"]["DigitalWalletValidation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /**
   * Create a transaction of type `sale` or `authorize`.
   * This endpoint supports two main styles of transactions:
   *   1. A real-time decision and response.
   *   2. User approval/interaction is required.
   *
   * A real-time decision is very familiar.  You send a request, and
   * inspect the `result` of the response for `approved` or `declined`.
   *
   * However, many transactions, especially those for alternative
   * methods, require the user to interact with a 3rd party.  You
   * may be able to envision PayPal, for example, the user must
   * give permission to complete the payment (or accept the
   * billing agreement).
   *
   * Even payment cards may require user approval in the case of
   * 3D secure authentication.  In the event that approval is
   * required, you will receive a response back and notice
   * that the `result` is `unknown`.  You will find that the
   * `status` is `waiting-approval`. And you will find in the
   * `_links` section of the response a link for the `approvalUrl`.
   *
   * In this case you would either open the `approvalUrl` in an
   * iframe or in a pop (better workflow for mobile).
   */
  PostTransaction: {
    requestBody: {};
    responses: {
      /** Transaction was created. */
      201: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of transactions. */
  GetTransactionCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A list of transactions was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Transaction"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Transaction with specified identifier string. */
  GetTransaction: {
    responses: {
      /** Transaction was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a transaction's custom fields. */
  PatchTransaction: {
    requestBody: {};
    responses: {
      /** Transaction was updated successfully. */
      200: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create a transaction of type `credit`. */
  PostPayout: {
    requestBody: {};
    responses: {
      /** Transaction was created. */
      201: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Cancel a scheduled transaction. Once handled a transaction cannot be canceled. */
  PostTransactionCancellation: {
    responses: {
      /** Successful cancel the payment. */
      201: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve Gateway communication Logs for Transaction with specified identifier string. */
  GetTransactionGatewayLogCollection: {
    responses: {
      /** Logs were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["TransactionGatewayLog"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Refund a Transaction with specified identifier string.
   * Note that the refund will be in the same currency as the original transaction.
   */
  PostTransactionRefund: {
    requestBody: {
      "application/json": components["schemas"]["TransactionRefund"];
    };
    responses: {
      /** Transaction was refunded successfully. */
      201: {
        "application/json": components["schemas"]["Transaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of transaction timeline messages. */
  GetTransactionTimelineCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of transaction timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["TransactionTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a transaction Timeline comment. */
  PostTransactionTimeline: {
    requestBody: {
      "application/json": components["schemas"]["TransactionTimeline"];
    };
    responses: {
      /** Transaction Timeline comment was created. */
      201: {
        "application/json": components["schemas"]["TransactionTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a timeline message with specified identifier string. */
  GetTransactionTimeline: {
    responses: {
      /** Timeline message was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["TransactionTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete a Transaction Timeline message with predefined identifier string. */
  DeleteTransactionTimeline: {
    responses: {
      /** Transaction Timeline message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Sends a token to activate user account. */
  PostActivation: {
    responses: {
      /** User account was activated. */
      204: never;
      /** Invalid token was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a list of api keys. */
  GetApiKeyCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of api keys was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ApiKey"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an api key. */
  PostApiKey: {
    requestBody: {};
    responses: {
      /** Api Key was created. */
      201: {
        "application/json": components["schemas"]["ApiKey"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve api key with specified identifier string. */
  GetApiKey: {
    responses: {
      /** Api key was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ApiKey"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update api key with predefined identifier string. */
  PutApiKey: {
    requestBody: {};
    responses: {
      /** ApiKey was updated. */
      200: {
        "application/json": components["schemas"]["ApiKey"];
      };
      /** ApiKey was created. */
      201: {
        "application/json": components["schemas"]["ApiKey"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete api key with predefined identifier string. */
  DeleteApiKey: {
    responses: {
      /** ApiKey was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** ApiKey has related resources and cannot be deleted. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  /** Retrieve a list of broadcast messages. */
  GetBroadcastMessageCollection: {
    responses: {
      /** A list of broadcast messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["BroadcastMessage"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a broadcast message. */
  PostBroadcastMessage: {
    requestBody: {
      "application/json": components["schemas"]["BroadcastMessage"];
    };
    responses: {
      /** Broadcast message was created. */
      201: {
        "application/json": components["schemas"]["BroadcastMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a broadcast message. */
  GetBroadcastMessage: {
    responses: {
      /** Broadcast message with specified identifier was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["BroadcastMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete a broadcast message. */
  DeleteBroadcastMessage: {
    responses: {
      /** Broadcast message was deleted. */
      204: never;
    };
  };
  /** Update a broadcast message. */
  PatchBroadcastMessage: {
    requestBody: {
      "application/json": components["schemas"]["BroadcastMessage"];
    };
    responses: {
      /** Broadcast message was updated. */
      200: {
        "application/json": components["schemas"]["BroadcastMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Browse a list of checkout forms. */
  GetCheckoutFormCollection: {
    responses: {
      /** A list of checkout forms was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CheckoutForm"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a checkout form. */
  PostCheckoutForm: {
    requestBody: {
      "application/json": components["schemas"]["CheckoutForm"];
    };
    responses: {
      /** Checkout form was created. */
      201: {
        "application/json": components["schemas"]["CheckoutForm"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a checkout form with specified identifier string. */
  GetCheckoutForm: {
    responses: {
      /** Checkout form was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CheckoutForm"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a checkout form with predefined identifier string. */
  PutCheckoutForm: {
    requestBody: {
      "application/json": components["schemas"]["CheckoutForm"];
    };
    responses: {
      /** Checkout form was updated. */
      200: {
        "application/json": components["schemas"]["CheckoutForm"];
      };
      /** Checkout form was created. */
      201: {
        "application/json": components["schemas"]["CheckoutForm"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a checkout form with predefined identifier string. */
  DeleteCheckoutForm: {
    responses: {
      /** Checkout form was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create an AWS SES credential. */
  PostAwsSesCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["SESCredential"];
    };
    responses: {
      /** AWS SES credential was created. */
      201: {
        "application/json": components["schemas"]["SESCredential"];
      };
      /** An existent AWS SES credential was retrieved. */
      303: {
        "application/json": components["schemas"]["SESCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an AWS SES credential with specified token identifier string. */
  GetAwsSesCredentialHash: {
    responses: {
      /** AWS SES credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SESCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update an AWS SES credential with specified token identifier string. */
  PatchAwsSesCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** AWS SES credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["SESCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create an email credential. */
  PostEmailCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["SmtpCredential"];
    };
    responses: {
      /** SMTP credential was created. */
      201: {
        "application/json": components["schemas"]["SmtpCredential"];
      };
      /** An existent SMTP credential was retrieved. */
      303: {
        "application/json": components["schemas"]["SmtpCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an email credential with specified token identifier string. */
  GetEmailCredentialHash: {
    responses: {
      /** Email credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SmtpCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update an email credential with specified token identifier string. */
  PatchEmailCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Email credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["SmtpCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create a mailgun credential. */
  PostMailgunCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["MailgunCredential"];
    };
    responses: {
      /** Mailgun credential was created. */
      201: {
        "application/json": components["schemas"]["MailgunCredential"];
      };
      /** An existent Mailgun credential was retrieved. */
      303: {
        "application/json": components["schemas"]["MailgunCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a mailgun credential with specified token identifier string. */
  GetMailgunCredentialHash: {
    responses: {
      /** Mailgun credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["MailgunCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a mailgun credential with specified token identifier string. */
  PatchMailgunCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Mailgun credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["MailgunCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of OAuth2 credentials. */
  GetOauth2CredentialHashCollection: {
    responses: {
      /** A list of OAuth2 credentials was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["OAuth2Credential"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Begins the creation of an OAuth2 credential that can be re-used within.
   * webhooks.  The result will be a `RedirectUrl` that the user must
   * authenticate and authorize Rebilly to receive the credentials.
   */
  PostOauth2CredentialHash: {
    requestBody: {};
    responses: {
      /** OAuth2 credential was created. */
      201: {
        "application/json": components["schemas"]["OAuth2Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an OAuth2 credential with specified token identifier string. */
  GetOauth2CredentialHash: {
    responses: {
      /** OAuth2 credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["OAuth2Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update an OAuth2 credential with specified token identifier string. */
  PatchOauth2CredentialHash: {
    requestBody: {};
    responses: {
      /** OAuth2 credential was updated. */
      200: {
        "application/json": components["schemas"]["OAuth2Credential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of root items available for specified credential. */
  GetOauth2CredentialHashItemCollection: {
    responses: {
      /** A list of root items available for specified credential was retrieved. successfully. */
      200: {
        "application/json": components["schemas"]["GoogleSpreadsheet"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetPlaidCredentialCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Plaid credentials was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PlaidCredential"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Plaid credential. */
  PostPlaidCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PlaidCredential"];
    };
    responses: {
      /** Plaid credential was created. */
      201: {
        "application/json": components["schemas"]["PlaidCredential"];
      };
      /** An existent Plaid credential was retrieved. */
      303: {
        "application/json": components["schemas"]["PlaidCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Plaid credential with specified token identifier string. */
  GetPlaidCredentialHash: {
    responses: {
      /** Plaid credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PlaidCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a Plaid credential with specified token identifier string. */
  PatchPlaidCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Plaid credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["PlaidCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create a Postmark credential. */
  PostPostmarkCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PostmarkCredential"];
    };
    responses: {
      /** Postmark credential was created. */
      201: {
        "application/json": components["schemas"]["PostmarkCredential"];
      };
      /** An existent Postmark credential was retrieved. */
      303: {
        "application/json": components["schemas"]["PostmarkCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a Postmark credential with specified token identifier string. */
  GetPostmarkCredentialHash: {
    responses: {
      /** Postmark credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["PostmarkCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a Postmark credential with specified token identifier string. */
  PatchPostmarkCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Postmark credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["PostmarkCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create a SendGrid credential. */
  PostSendGridCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["SendGridCredential"];
    };
    responses: {
      /** SendGrid credential was created. */
      201: {
        "application/json": components["schemas"]["SendGridCredential"];
      };
      /** An existent SendGrid credential was retrieved. */
      303: {
        "application/json": components["schemas"]["SendGridCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a SendGrid credential with specified token identifier string. */
  GetSendGridCredentialHash: {
    responses: {
      /** SendGrid credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SendGridCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a SendGrid credential with specified token identifier string. */
  PatchSendGridCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** SendGrid credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["SendGridCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Create a webhook credential. */
  PostWebhookCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["WebhookCredential"];
    };
    responses: {
      /** Webhook credential was created. */
      201: {
        "application/json": components["schemas"]["WebhookCredential"];
      };
      /** An existent Webhook credential was retrieved. */
      303: {
        "application/json": components["schemas"]["WebhookCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a webhook credential with specified token identifier string. */
  GetWebhookCredentialHash: {
    responses: {
      /** Webhook credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["WebhookCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a webhook credential with specified token identifier string. */
  PatchWebhookCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Webhook credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["WebhookCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a list of Experian credentials. */
  GetExperianCredentialHashCollection: {
    responses: {
      /** A list of Experian credentials was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ExperianCredential"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an Experian credential. */
  PostExperianCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["ExperianCredential"];
    };
    responses: {
      /** Experian credential was created. */
      201: {
        "application/json": components["schemas"]["ExperianCredential"];
      };
      /** An existent Experian credential was retrieved. */
      303: {
        "application/json": components["schemas"]["ExperianCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an Experian credential with specified token identifier string. */
  GetExperianCredentialHash: {
    responses: {
      /** Experian credential was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ExperianCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update an Experian credential with specified token identifier string. */
  PatchExperianCredentialHash: {
    requestBody: {
      "application/json": components["schemas"]["PatchCredential"];
    };
    responses: {
      /** Experian credential was updated successfully. */
      200: {
        "application/json": components["schemas"]["ExperianCredential"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Verify an email delivery setting. */
  VerifyEmailDeliverySettings: {
    responses: {
      /** Email delivery setting was verified successfully. */
      200: {
        "application/json": components["schemas"]["EmailDeliverySetting"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  GetEmailDeliverySettingCollection: {
    responses: {
      /** A list of email delivery settings was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["EmailDeliverySetting"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an email delivery setting.  The email delivery setting is used in. conjunction with email messages or templates to send emails. */
  PostEmailDeliverySetting: {
    requestBody: {
      "application/json": components["schemas"]["EmailDeliverySetting"];
    };
    responses: {
      /** Email delivery setting was created. */
      201: {
        "application/json": components["schemas"]["EmailDeliverySetting"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an email delivery setting. */
  GetEmailDeliverySetting: {
    responses: {
      /** Email delivery setting with specified identifier was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["EmailDeliverySetting"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete an email delivery setting. */
  DeleteEmailDeliverySetting: {
    responses: {
      /** Email delivery setting was deleted. */
      204: never;
      409: components["responses"]["Conflict"];
    };
  };
  /** Update an email delivery setting. */
  PatchEmailDeliverySettings: {
    requestBody: {
      "application/json": components["schemas"]["EmailDeliverySetting"];
    };
    responses: {
      /** Email delivery setting was updated successfully. */
      200: {
        "application/json": components["schemas"]["EmailDeliverySetting"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Resend verification email for an email delivery setting. */
  ResendEmailDeliverySettingVerification: {
    responses: {
      /** Verification email was sent successfully. */
      200: {
        "application/json": components["schemas"]["EmailDeliverySetting"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of email messages. */
  GetEmailMessageCollection: {
    responses: {
      /** A list of email messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["EmailMessage"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an email message. */
  PostEmailMessage: {
    requestBody: {
      "application/json": components["schemas"]["EmailMessage"];
    };
    responses: {
      /** Email message was created. */
      201: {
        "application/json": components["schemas"]["EmailMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve an email message. */
  GetEmailMessage: {
    responses: {
      /** Email message with specified identifier was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["EmailMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete an email message. */
  DeleteEmailMessage: {
    responses: {
      /** Email message was deleted. */
      204: never;
      409: components["responses"]["Conflict"];
    };
  };
  /** Send an email message. */
  PatchEmailMessage: {
    requestBody: {
      "application/json": {
        /** The email message's status. */
        status: "outbox";
      };
    };
    responses: {
      /** Email message was accepted. */
      200: {
        "application/json": components["schemas"]["EmailMessage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      422: components["responses"]["ValidationError"];
    };
  };
  GetEmailNotificationCollection: {
    responses: {
      /** A list of email notification events was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["EmailNotification"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetEventCollection: {
    responses: {
      /** A list of System Events was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SystemEvent"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetEvent: {
    responses: {
      /** Rules were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SystemEvent"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  GetEventRuleCollection: {
    responses: {
      /** Rules were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["RuleSet"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  PutEventRuleCollection: {
    requestBody: {};
    responses: {
      /** Rules were updated. */
      200: {
        "application/json": components["schemas"]["RuleSet"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /**
   * Retrieve the change history of the selected set of rules.
   * The history is updated each time you change the rules.
   */
  GetEventRuleHistoryCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        q?: components["parameters"]["collectionQuery"];
        sort?: components["parameters"]["collectionSort"];
        fields?: components["parameters"]["collectionFields"];
        expand?: components["parameters"]["collectionExpand"];
      };
    };
    responses: {
      /** History was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["RuleSetHistoryItem"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Retrieve the record from the change history of the selected set of rules.
   * A history record is created each time you change the rules.
   */
  GetEventRuleHistoryVersion: {
    parameters: {
      query: {
        fields?: components["parameters"]["collectionFields"];
        expand?: components["parameters"]["collectionExpand"];
      };
    };
    responses: {
      /** History record was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["RuleSetHistoryItem"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Retrieve the version of the selected set of rules.
   * The versions are created each time you change the rules.
   */
  GetEventRuleVersion: {
    parameters: {
      query: {
        fields?: components["parameters"]["collectionFields"];
        expand?: components["parameters"]["collectionExpand"];
      };
    };
    responses: {
      /** Rules version was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["RuleSetVersion"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Sends an email with a link containing a token to reset user password. */
  PostForgotPasswordRequest: {
    requestBody: {
      "application/json": components["schemas"]["ForgotPassword"];
    };
    responses: {
      /** Email sent successfully. */
      204: never;
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a list of gateway accounts. */
  GetGatewayAccountCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Gateway Accounts was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccount"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Gateway Account. */
  PostGatewayAccount: {
    requestBody: {};
    responses: {
      /** Gateway Account was created. */
      201: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a Gateway Account with specified identifier string. */
  GetGatewayAccount: {
    responses: {
      /** Gateway Account was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a GatewayAccount with predefined identifier string. */
  PutGatewayAccount: {
    requestBody: {};
    responses: {
      /** Gateway Account was updated. */
      200: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      /** Gateway Account was created. */
      201: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Update a GatewayAccount with predefined identifier string. */
  PatchGatewayAccount: {
    requestBody: {};
    responses: {
      /** Gateway Account was updated. */
      200: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Delete a Gateway Account with predefined identifier string. */
  DeleteGatewayAccount: {
    responses: {
      /** Gateway Account was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /**
   * Close a gateway account with specified identifier string.
   * Also known as archiving. Closing a Gateway Account cannot be undone, so use with caution. It will no longer be able
   * to process transactions. The "status" attribute will be set to "closed".
   */
  PostGatewayAccountClosure: {
    responses: {
      /** Closed successfully. */
      201: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Disable a gateway account with specified identifier string.
   * Disabled gateway accounts have their "status" attribute set to "inactive" and cannot process transactions.
   */
  PostGatewayAccountDisablement: {
    responses: {
      /** Disabled successfully. */
      201: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Gateway account is pending activation and cannot be disabled. */
      409: unknown;
    };
  };
  /** Retrieve a list of gateway account downtime schedules. */
  GetGatewayAccountDowntimeScheduleCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Gateway Account downtime schedules was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountDowntimeSchedule"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Gateway Account downtime schedule. */
  PostGatewayAccountDowntimeSchedule: {
    requestBody: {};
    responses: {
      /** Gateway Account downtime schedule was created. */
      201: {
        "application/json": components["schemas"]["GatewayAccountDowntimeSchedule"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a Gateway Downtime schedule with specified identifier string. */
  GetGatewayAccountDowntimeSchedule: {
    responses: {
      /** Gateway Downtime schedule was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountDowntimeSchedule"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a Gateway Account downtime schedule with predefined identifier string. */
  PutGatewayAccountDowntimeSchedule: {
    requestBody: {};
    responses: {
      /** Gateway Account downtime schedule was updated. */
      200: {
        "application/json": components["schemas"]["GatewayAccountDowntimeSchedule"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Delete a Gateway Account downtime schedule. */
  DeleteGatewayAccountDowntimeSchedule: {
    responses: {
      /** Gateway Account downtime schedule was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Enable a gateway account with specified identifier string.
   * Enabled gateway accounts have their "status" attribute set to "active" and can process transactions.
   */
  PostGatewayAccountEnablement: {
    responses: {
      /** Enabled successfully. */
      201: {
        "application/json": components["schemas"]["GatewayAccount"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Gateway account is pending activation and cannot be enabled. */
      409: unknown;
    };
  };
  /** Retrieve a list of gateway account limits. */
  GetGatewayAccountLimitCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of gateway account limits was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountLimit"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a gateway account limit with specified identifier string. */
  GetGatewayAccountLimit: {
    responses: {
      /** Gateway account limit was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountLimit"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a gateway account limit with predefined identifier string. */
  PutGatewayAccountLimit: {
    requestBody: {
      "application/json": components["schemas"]["GatewayAccountLimit"];
    };
    responses: {
      /** Gateway account limit was updated. */
      200: {
        "application/json": components["schemas"]["GatewayAccountLimit"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Delete a gateway account limit. */
  DeleteGatewayAccountLimit: {
    responses: {
      /** Gateway account limit was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of gateway account timeline messages. */
  GetGatewayAccountTimelineCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of Gateway Account timeline messages was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountTimeline"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a Gateway Account Timeline comment. */
  PostGatewayAccountTimeline: {
    requestBody: {
      "application/json": components["schemas"]["GatewayAccountTimeline"];
    };
    responses: {
      /** Gateway Account Timeline comment was created. */
      201: {
        "application/json": components["schemas"]["GatewayAccountTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a Gateway Timeline message with specified identifier string. */
  GetGatewayAccountTimeline: {
    responses: {
      /** Gateway Timeline message was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GatewayAccountTimeline"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Delete a Gateway Timeline message with predefined identifier string. */
  DeleteGatewayAccountTimeline: {
    responses: {
      /** Gateway Account Timeline message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a user's UI Segments. */
  GetGridSegmentCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Segments were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Segment"][];
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * Create a new Segment for oneself or to share with others within the
   * organization.
   */
  PostGridSegment: {
    requestBody: {};
    responses: {
      /** Segment was created successfully. */
      201: {
        "application/json": components["schemas"]["Segment"];
      };
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a specific UI Segment. */
  GetGridSegment: {
    responses: {
      /** Segment was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Segment"];
      };
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update a Segment. */
  PutGridSegment: {
    requestBody: {
      "application/json": components["schemas"]["Segment"];
    };
    responses: {
      /** Segment was updated successfully. */
      200: {
        "application/json": components["schemas"]["Segment"];
      };
      /** This will be sent if the user is not the owner. */
      403: {
        "application/json": components["schemas"]["Error"];
      };
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a Segment. This will also remove all shares. Only the owner may. perform this. */
  DeleteGridSegment: {
    responses: {
      /** Segment was deleted successfully. */
      204: never;
      /** This will be sent if the user is not the owner. */
      403: {
        "application/json": components["schemas"]["Error"];
      };
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of integrations. */
  GetIntegrationCollection: {
    responses: {
      /** A list of integrations was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Integration"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve an integration for specific label. */
  GetIntegration: {
    responses: {
      /** An integration with specific label was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Integration"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a collection of Lists. */
  GetListCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
        sort?: components["parameters"]["collectionSort"];
      };
    };
    responses: {
      /** A collection of Lists was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["List"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a List. */
  PostList: {
    requestBody: {};
    responses: {
      /** List was created. */
      201: {
        "application/json": components["schemas"]["List"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve latest version of List with specified identifier string. */
  GetList: {
    responses: {
      /** List was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["List"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a list with predefined identifier string. */
  PutList: {
    requestBody: {};
    responses: {
      /** List was updated. */
      200: {
        "application/json": components["schemas"]["List"];
      };
      /** List was created. */
      201: {
        "application/json": components["schemas"]["List"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a list with predefined identifier string. */
  DeleteList: {
    responses: {
      /** List was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** List is used in Rules and cannot be deleted. */
      409: unknown;
    };
  };
  GetListVersion: {
    responses: {
      /** List's exact version was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["List"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Destroys the user's current session. Endpoint must be accessed with valid. JWT Authorization header. */
  PostLogoutRequest: {
    responses: {
      /** Session was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a list of memberships. */
  GetMembershipCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** A list of memberships was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Membership"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve the membership using organization and user identifiers. */
  GetMembership: {
    responses: {
      /** Membership was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Membership"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /**
   * Create or update membership using organization and user identifiers.
   * Only membership's owner can add other users in the membership.
   */
  PutMembership: {
    requestBody: {
      "application/json": {
        isOwner?: boolean;
        /** The memberships's permissions. See the format in example. Use wildcard `*` for full access. */
        permissions?: components["schemas"]["AclPermissions"];
      };
    };
    responses: {
      /** Membership was updated. */
      200: {
        "application/json": components["schemas"]["Membership"];
      };
      /** Membership was created. */
      201: {
        "application/json": components["schemas"]["Membership"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Delete the membership using organization and user identifiers. */
  DeleteMembership: {
    responses: {
      /** Membership message was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
    };
  };
  /** Retrieve a list of organizations. */
  GetOrganizationCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of organizations was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Organization"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a organization. */
  PostOrganization: {
    requestBody: {};
    responses: {
      /** Organization was created. */
      201: {
        "application/json": components["schemas"]["Organization"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** The similar organization already exists. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a organization with specified identifier string. */
  GetOrganization: {
    responses: {
      /** Organization was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Organization"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a organization with predefined identifier string. */
  PutOrganization: {
    requestBody: {};
    responses: {
      /** Organization was updated. */
      200: {
        "application/json": components["schemas"]["Organization"];
      };
      /** Organization was created. */
      201: {
        "application/json": components["schemas"]["Organization"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** The similar organization already exists. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete a organization with predefined identifier string. */
  DeleteOrganization: {
    responses: {
      /** Organization was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Organization has related resources and cannot be deleted. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  /** Retrieve a list of payment card issuing bank names. */
  GetPaymentCardBankNameCollection: {
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      query: {
        limit?: components["parameters"]["collectionLimit"];
        q?: components["parameters"]["collectionQuery"];
      };
    };
    responses: {
      /** A list of payment card issuing bank names was retrieved successfully. */
      200: {
        "application/json": {
          /** Bank Name. */
          name?: string;
        }[];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Send a test email. */
  PostPreviewRuleActionEmailSending: {
    requestBody: {
      "application/json": components["schemas"]["SendTestEmail"];
    };
    responses: {
      /** Test email was sent. */
      200: {
        "application/json": components["schemas"]["SendTestEmail"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Trigger a test webhook. */
  PostPreviewRuleActionWebhookTrigger: {
    requestBody: {
      "application/json": components["schemas"]["SendPreviewWebhook"];
    };
    responses: {
      /** Test webhook was triggered. */
      200: {
        "application/json": components["schemas"]["SendPreviewWebhook"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Trigger a test webhook. */
  PostPreviewWebhook: {
    requestBody: {};
    responses: {
      /** Test webhook was triggered. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve user's profile. */
  GetProfile: {
    responses: {
      /** Profile was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Profile"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Update user's profile. */
  PutProfile: {
    requestBody: {
      "application/json": components["schemas"]["Profile"];
    };
    responses: {
      /** Profile was updated. */
      200: {
        "application/json": components["schemas"]["Profile"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Updates user's password with the specified newPassword. And checks if. currentPassword matches the actual one. */
  PostProfilePasswordChange: {
    requestBody: {};
    responses: {
      /** Password updated successfully. */
      201: {
        "application/json": components["schemas"]["Profile"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Reset (renew) totpSecret. */
  PostProfileTotpReset: {
    responses: {
      /** totpSecret reset (renewed) successfully. */
      201: {
        "application/json": components["schemas"]["Profile"];
      };
      404: components["responses"]["NotFound"];
    };
  };
  GetPasswordResetToken: {
    responses: {
      /** Token was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ResetPasswordTokenInfo"];
      };
      404: components["responses"]["NotFound"];
    };
  };
  /** Reset user password. */
  PostPasswordReset: {
    requestBody: {
      "application/json": components["schemas"]["ResetPassword"];
    };
    responses: {
      /** Password was reseted successfully. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  GetSendThroughAttributionCollection: {
    responses: {
      /** A list of email notification send through attributions was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SendThroughAttribution"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a session with email and password. */
  PostSigninRequest: {
    requestBody: {
      "application/json": components["schemas"]["Signin"];
    };
    responses: {
      /** Session was created. */
      201: {
        "application/json": components["schemas"]["Session"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Creates a new user and sends an email confirmation. */
  PostSignupRequest: {
    requestBody: {
      "application/json": components["schemas"]["Signup"];
    };
    responses: {
      /** User was created. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve API current status. */
  GetStatus: {
    responses: {
      /** Status was received. */
      200: {
        "application/json": components["schemas"]["Status"];
      };
    };
  };
  GetTrackingApiCollection: {
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
        /** The response media type. */
        Accept?: "application/json" | "text/csv";
      };
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Tracking API logs was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ApiTracking"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetTrackingApi: {
    responses: {
      /** Tracking API log was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ApiTracking"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  GetTrackingListCollection: {
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Lists changes history was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["List"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetTrackingWebhookCollection: {
    parameters: {
      header: {
        "Organization-Id"?: components["parameters"]["organizationId"];
      };
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Tracking webhook notifications were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["WebhookTracking"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  GetTrackingWebhook: {
    responses: {
      /** Tracking webhook notification was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["WebhookTracking"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  GetTrackingWebhookHistoryCollection: {
    responses: {
      /** Webhook tracking related attempts were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["WebhookTracking"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  PostTrackingWebhookResendRequest: {
    responses: {
      /** Webhook resend attempt was scheduled. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of users. */
  GetUserCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of users was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["User"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an user. */
  PostUser: {
    requestBody: {};
    responses: {
      /** User was created. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve user with specified identifier string. */
  GetUser: {
    responses: {
      /** User was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["User"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update user with predefined identifier string. */
  PutUser: {
    requestBody: {};
    responses: {
      /** User was updated. */
      200: {
        "application/json": components["schemas"]["User"];
      };
      /** User was created. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Delete user with predefined identifier string. */
  DeleteUser: {
    responses: {
      /** User was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** User has related resources and cannot be deleted. */
      409: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  /** Updates user's password with the specified newPassword. And checks if. currentPassword matches the actual one. */
  PostUserPasswordChange: {
    requestBody: {};
    responses: {
      /** Password updated successfully. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Reset (renew) totpSecret. */
  PostUserTotpReset: {
    responses: {
      /** totpSecret reset (renewed) successfully. */
      201: {
        "application/json": components["schemas"]["User"];
      };
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a list of webhooks. */
  GetWebhookCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Webhooks was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GlobalWebhook"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a webhook. */
  PostWebhook: {
    requestBody: {};
    responses: {
      /** Webhook was created. */
      201: {
        "application/json": components["schemas"]["GlobalWebhook"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a webhook with specified identifier string. */
  GetWebhook: {
    responses: {
      /** Webhook was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["GlobalWebhook"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a webhook with predefined identifier string. */
  PutWebhook: {
    requestBody: {};
    responses: {
      /** Webhook was updated. */
      200: {
        "application/json": components["schemas"]["GlobalWebhook"];
      };
      /** Webhook was created. */
      201: {
        "application/json": components["schemas"]["GlobalWebhook"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a list of websites. */
  GetWebsiteCollection: {
    parameters: {
      query: {
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** A list of Websites was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Website"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create a website. */
  PostWebsite: {
    requestBody: {};
    responses: {
      /** Website was created. */
      201: {
        "application/json": components["schemas"]["Website"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a website with specified identifier string. */
  GetWebsite: {
    responses: {
      /** Website was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["Website"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Create or update a website with predefined identifier string. */
  PutWebsite: {
    requestBody: {};
    responses: {
      /** Website was updated. */
      200: {
        "application/json": components["schemas"]["Website"];
      };
      /** Website was created. */
      201: {
        "application/json": components["schemas"]["Website"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Delete a website with predefined identifier string. */
  DeleteWebsite: {
    responses: {
      /** Website was deleted. */
      204: never;
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      /** Website has related resources and cannot be deleted. */
      409: unknown;
    };
  };
  /** Retrieve customer lifetime summary metrics. */
  GetCustomerSummaryMetricReport: {
    responses: {
      /** Metrics were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CustomerInformation"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Request a data export of selected resource. */
  PostDataExport: {
    requestBody: {};
    responses: {
      /** Data export request received. */
      201: {
        "application/json": components["schemas"]["DataExport"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Retrieve a list of data export requests. */
  GetDataExportCollection: {
    responses: {
      /** A list of data export requests was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["DataExport"][];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Retrieve a data export request. */
  GetDataExport: {
    responses: {
      /** Data Export request. */
      200: {
        "application/json": components["schemas"]["DataExport"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** A data export may be changed as long as it is still pending. */
  PutDataExport: {
    requestBody: {};
    responses: {
      /** Data Export was modified. */
      200: {
        "application/json": components["schemas"]["DataExport"];
      };
      /** Data Export was created. */
      201: {
        "application/json": components["schemas"]["DataExport"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      /** Invalid data was sent. */
      422: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
  };
  /** Delete an existing data export. */
  DeleteDataExport: {
    responses: {
      204: components["responses"]["NoContent"];
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
    };
  };
  /** Get Transaction histogram report data. */
  GetHistogramTransactionReport: {
    parameters: {
      query: {
        /** Report start day. */
        periodStart: string;
        /** Report end day. */
        periodEnd: string;
        /** Report aggregation field. */
        aggregationField:
          | "website"
          | "currency"
          | "bin"
          | "rebillNumber"
          | "transactionResult"
          | "transactionType"
          | "gatewayAccount"
          | "leadsAffiliate"
          | "leadsCampaign"
          | "leadsContent"
          | "leadsMedium"
          | "leadsSalesAgent"
          | "leadsSource"
          | "leadsSubAffiliate"
          | "leadsTerm";
        /** Report aggregation period. */
        aggregationPeriod: "hour" | "day" | "month";
        /** Report metric. */
        metric:
          | "ApprovalThroughput"
          | "AuthApprovalThroughput"
          | "AvgSalesPrice"
          | "Refunds"
          | "RefundCount"
          | "Sales"
          | "SalesCount";
      };
    };
    responses: {
      /** Transaction report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["HistogramData"];
      };
      403: components["responses"]["Forbidden"];
    };
  };
  /** Create an organization. */
  ExperimentalPostOrganization: {
    requestBody: {};
    responses: {
      /** Organization was created. */
      201: {
        "application/json": components["schemas"]["Organization"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Update an organization with predefined identifier string. */
  PatchOrganization: {
    requestBody: {};
    responses: {
      /** Organization was updated. */
      200: {
        "application/json": components["schemas"]["Organization"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
      422: components["responses"]["ValidationError"];
    };
  };
  /** Retrieve a API Log Summary Report. */
  GetApiLogSummaryReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["APILogSummary"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a cumulative subscriptions report. */
  GetCumulativeSubscriptionReport: {
    parameters: {
      query: {
        /** Report aggregation field. */
        aggregationField: "day" | "month";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["CumulativeSubscriptions"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve dashboard data. */
  GetDashboardReport: {
    parameters: {
      query: {
        /** Report start day. */
        periodStart: string;
        /** Report end day. */
        periodEnd: string;
        /** Comma-separated list of metrics. */
        metrics?: string;
        /** Dashboard report segments as a JSON array. */
        segments?: string;
        tz?: components["parameters"]["reportTimezone"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["DashboardResponse"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a DCC markup report. */
  GetDccMarkupReport: {
    parameters: {
      query: {
        /** Report aggregation field. */
        aggregationField:
          | "day"
          | "month"
          | "bin"
          | "country"
          | "baseCurrency"
          | "quoteCurrency";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["DccMarkup"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a disputes report. */
  GetDisputeReport: {
    parameters: {
      query: {
        /** Report will be aggregated by this field. */
        aggregationField:
          | "website"
          | "gatewayAcquirer"
          | "currency"
          | "bin"
          | "country"
          | "rebillNumber"
          | "retryNumber"
          | "gatewayAccount"
          | "transactionAmount";
        /** Report month in format YYYY-MM. */
        periodMonth: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportDisputes"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a events triggered summary report. */
  GetTriggeredEventReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportEventsTriggeredSummary"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a rules matched summary report by events triggered. */
  GetTriggeredEventRuleReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportRulesMatchedSummary"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a future renewals report. */
  GetFutureRenewalReport: {
    parameters: {
      query: {
        /** Report start date. It should be in the future. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["FutureRenewals"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a renewal sales report. */
  GetRenewalSaleReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["RenewalSales"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a retention percentage report. */
  GetRetentionPercentageReport: {
    parameters: {
      query: {
        /** Report aggregation field. */
        aggregationField: "day" | "month" | "quarter" | "year";
        /** Report aggregation period. */
        aggregationPeriod: "day" | "month" | "quarter" | "year" | "cycle";
        /** If to include switched subscriptions. */
        includeSwitchedSubscriptions?: "true" | "false";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportRetentionPercentage"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /**
   * The retention value report shows the count of new customers.
   * per aggregation bucket and the corresponding per customer value over time.
   */
  GetRetentionValueReport: {
    parameters: {
      query: {
        /** Report aggregation field. */
        aggregationField:
          | "day"
          | "month"
          | "quarter"
          | "year"
          | "leadsSource"
          | "leadsMedium"
          | "leadsCampaign"
          | "leadsContent"
          | "leadsTerm"
          | "leadsAffiliate"
          | "leadsSubAffiliate"
          | "leadsSalesAgent";
        /** Report aggregation period. */
        aggregationPeriod: "day" | "month" | "quarter" | "year";
        /** If to include refunds. */
        includeRefunds?: "true" | "false";
        /** If to include disputes. */
        includeDisputes?: "true" | "false";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportRetentionValue"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a payment retry report. */
  GetTransactionRetryReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportPaymentRetry"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve transactions with their plan data. */
  GetSubscriptionCancellationReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        /** Report aggregation field. */
        aggregationField:
          | "planId"
          | "websiteId"
          | "canceledBy"
          | "cancelCategory"
          | "leadSource.source"
          | "leadSource.medium"
          | "leadSource.campaign"
          | "leadSource.content"
          | "leadSource.term"
          | "leadSource.affiliate"
          | "leadSource.subAffiliate"
          | "leadSource.salesAgent";
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionCancellationReport"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a subscription renewal report. */
  GetSubscriptionRenewalReport: {
    parameters: {
      query: {
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionRenewal"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a transactions report aggregated by time periods. */
  GetTimeSeriesTransactionReport: {
    parameters: {
      query: {
        /** Report aggregation type. */
        type: "count" | "amount" | "approval-rate" | "incomplete-rate";
        /** Report subaggregate. */
        subaggregate:
          | "website"
          | "gateway-account"
          | "currency"
          | "plan"
          | "leads.source"
          | "leads.medium"
          | "leads.campaign"
          | "leads.content"
          | "leads.term"
          | "leads.affiliate"
          | "leads.subaffiliate"
          | "leads.sales-agent";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["TimeSeriesTransaction"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a dispute delays in days report, how much time between a. transaction and a dispute. */
  GetTransactionTimeDisputeReport: {
    parameters: {
      query: {
        /** Report will be aggregated by this field. */
        aggregationField:
          | "website"
          | "processor"
          | "currency"
          | "bin"
          | "country"
          | "rebillNumber"
          | "retryNumber"
          | "gatewayAccount"
          | "transactionAmount";
        /** Report start date. */
        periodStart: string;
        /** Report end date. */
        periodEnd: string;
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportDisputeDelays"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve a transactions report. */
  GetTransactionReport: {
    parameters: {
      query: {
        /** Report start day. */
        periodStart: string;
        /** Report end day. */
        periodEnd: string;
        /** Report aggregation field. */
        aggregationField:
          | "website"
          | "currency"
          | "bin"
          | "rebillNumber"
          | "transactionResult"
          | "transactionType"
          | "gatewayAccount"
          | "gateway"
          | "retryNumber"
          | "plan"
          | "leadSource.source"
          | "leadSource.medium"
          | "leadSource.campaign"
          | "leadSource.content"
          | "leadSource.term"
          | "leadSource.affiliate"
          | "leadSource.subAffiliate"
          | "leadSource.salesAgent";
        limit?: components["parameters"]["collectionLimit"];
        offset?: components["parameters"]["collectionOffset"];
        filter?: components["parameters"]["collectionFilter"];
      };
    };
    responses: {
      /** Report was retrieved successfully. */
      200: {
        "application/json": components["schemas"]["ReportTransactions"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
  /** Retrieve subscription order summary metrics. */
  GetSubscriptionSummaryMetricReport: {
    responses: {
      /** Metrics were retrieved successfully. */
      200: {
        "application/json": components["schemas"]["SubscriptionSummaryMetrics"];
      };
      401: components["responses"]["Unauthorized"];
      403: components["responses"]["Forbidden"];
    };
  };
}

export interface components {
  parameters: {
    /** Organization identifier in scope of which need to perform request (if not specified, the default organization will be used). */
    organizationId: components["schemas"]["ResourceId"];
    /** The collection items limit. */
    collectionLimit: number;
    /** The collection items offset. */
    collectionOffset: number;
    /** The resource identifier string. */
    resourceId: string;
    /**
     * The collection items filter requires a special format.
     * Use "," for multiple allowed values.  Use ";" for multiple fields.
     * See the [filter guide](https://api-reference.rebilly.com/#section/Using-filter-with-collections) for more options and examples about this format.
     */
    collectionFilter: string;
    /** The partial search of the text fields. */
    collectionQuery: string;
    /**
     * Expand a response to get a full related object included inside of the `_embedded` path in the response.
     * It accepts a comma-separated list of objects to expand.
     * See the [expand guide](https://api-reference.rebilly.com/#section/Expand-to-include-embedded-objects) for more info.
     */
    collectionExpand: string;
    /** Limit the returned fields to the list specified, separated by comma. Note that id is always returned. */
    collectionFields: string;
    /** The collection items sort field and order (prefix with "-" for descending sort). */
    collectionSort: string[];
    /** The resource type string. */
    customFieldResource:
      | "customers"
      | "payment-instruments"
      | "subscriptions"
      | "transactions"
      | "websites"
      | "products"
      | "plans"
      | "bump-offers";
    /** Resize image to specified size. Supports any sizes from 10x10 to 2000x2000 (format `{width}x{height}`). The image will be returned in the original size if the value is invalid. This parameter will be ignored for non-image files. */
    imageSize: string;
    /** The response media type. */
    mediaTypeJsonPdf: "application/json" | "application/pdf";
    /**
     * Expand a response to get a full related object included inside of the `_embedded` path in the response.
     * To expand multiple objects, it accepts a comma-separated list of objects (example: `expand=recentInvoice,initialInvoice`).
     * Available arguments are:
     *   - recentInvoice
     *   - initialInvoice
     *   - customer
     *   - website
     *
     * See the [expand guide](https://api-reference.rebilly.com/#section/Expand-to-include-embedded-objects) for more info.
     */
    subscriptionExpand: string;
    /** The tag name. */
    tag: string;
    /** The customer identifier string. */
    customerId: string;
    /** The token identifier string. */
    hash: string;
    /** The token string. */
    token: string;
    /** The event type. */
    systemEventType: string;
    /** The rule set version. Expand response to get full related object instead of ID.  See the expand guide for more info. */
    rulesVersion: number;
    /** The integration label. */
    integrationLabel: components["schemas"]["OAuth2CredentialService"];
    /** Report's timezone offset in minutes. */
    reportTimezone: number;
  };
  schemas: {
    /** The resource ID. Defaults to UUID v4. */
    ResourceId: string;
    /** ISO 4217 alphabetic currency code. */
    CurrencyCode: string;
    /** Read-only timestamp, automatically assigned on back-end. */
    ServerTimestamp: string;
    Link: {
      /** The link URL. */
      href: string;
    };
    SelfLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "self";
    };
    ThreeDSecure: {
      /** The 3D Secure entry identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Related customer ID. */
      customerId: components["schemas"]["ResourceId"];
      /** Related gateway account ID. */
      gatewayAccountId: components["schemas"]["ResourceId"];
      /** Related payment card ID. */
      paymentCardId: components["schemas"]["ResourceId"];
      /** Related Website ID. */
      websiteId: components["schemas"]["ResourceId"];
      /** Is the cardholder enrolled in 3DSecure. */
      enrolled: "Y" | "N" | "U";
      /** The 3D Secure entry enrollment eci. */
      enrollmentEci: string;
      /** The 3D Secure entry electronic commerce indicator. */
      eci?: number;
      /** The 3D Secure entry cardholder authentication verification value. */
      cavv?: string;
      /** The 3D Secure entry transaction Id. */
      xid?: string;
      /** The 3D Secure entry Auth Response Status. */
      payerAuthResponseStatus?: "Y" | "N" | "U" | "A";
      /** If signature was verified. */
      signatureVerification?: "Y" | "N";
      /** Transaction amount. */
      amount: number;
      currency: components["schemas"]["CurrencyCode"];
      /** The 3D Secure entry created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** The Problem Details JSON Object [[RFC7807](https://tools.ietf.org/html/rfc7807)]. */
    BlankProblem: {
      /** The HTTP status code. */
      status?: number;
      /** A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization. */
      title?: string;
    } & { [key: string]: any };
    DocumentedProblem: {
      /** A URI reference [[RFC3986](https://tools.ietf.org/html/rfc3986)] that identifies the problem type. It should provide human-readable documentation for the problem type. When this member is not present, its value is assumed to be "about:blank". */
      type?: string;
    } & components["schemas"]["BlankProblem"];
    DetailedProblem: components["schemas"]["BlankProblem"] & {
      /** A human-readable explanation specific to this occurrence of the problem. */
      detail?: string;
    };
    Problem: components["schemas"]["DocumentedProblem"] &
      components["schemas"]["DetailedProblem"];
    Error: components["schemas"]["Problem"] & {
      error?: string;
    };
    ValidationErrorExtensions: {
      invalidFields?: {
        /** The field name. Dot notation is used for nested object field names. */
        field?: string;
        message?: string;
      }[];
    };
    /** Invalid data was sent. */
    InvalidError: components["schemas"]["Error"] &
      components["schemas"]["ValidationErrorExtensions"];
    FileLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "file";
    };
    AttachmentResourceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel:
        | "customer"
        | "dispute"
        | "invoice"
        | "payment"
        | "plan"
        | "product"
        | "subscription"
        | "transaction";
    };
    FileDownloadLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "download";
    };
    SignedLinkLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "signedLink";
    };
    PermalinkLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "permalink";
    };
    File: {
      id?: components["schemas"]["ResourceId"];
      /** Original File name. */
      name?: string;
      /** The File extension. */
      extension?: string;
      /** The File description. */
      description?: string;
      /** The tags list. */
      tags?: string[];
      /** The mime type. */
      mime?:
        | "image/png"
        | "image/jpeg"
        | "image/gif"
        | "application/pdf"
        | "audio/mpeg";
      /** The File size in bytes. */
      size?: number;
      /** Image width, applicable to images only. */
      width?: number;
      /** Image height, applicable to images only. */
      height?: number;
      /** Hash sum of the file. */
      sha1?: string;
      /** The upload date/time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The latest update date/time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Is the file available publicly (without authentication). If true, the permalink in the _links section contains the public URL. */
      isPublic?: boolean;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["FileDownloadLink"]> &
        Partial<components["schemas"]["SignedLinkLink"]> &
        Partial<components["schemas"]["PermalinkLink"]>)[];
    };
    /** File object. */
    FileEmbed: {
      file?: components["schemas"]["File"];
    };
    Attachment: {
      id?: components["schemas"]["ResourceId"];
      /** Linked File object id. */
      fileId: string;
      /** Linked object type. */
      relatedType:
        | "customer"
        | "dispute"
        | "gateway-timeline-comment"
        | "invoice"
        | "organization"
        | "payment"
        | "plan"
        | "product"
        | "subscription"
        | "transaction"
        | "customer-timeline-comment"
        | "transaction-timeline-comment"
        | "order-timeline-comment";
      /** Linked object Id. */
      relatedId: string;
      /** The Original Attachment name. */
      name?: string;
      /** The Attachment description. */
      description?: string;
      /** Creation date/time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Latest update date/time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["FileLink"]> &
        Partial<components["schemas"]["AttachmentResourceLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: Partial<components["schemas"]["FileEmbed"]>[];
    };
    AuthenticationOptions: {
      /** Allowed password pattern. */
      passwordPattern?: string;
      /** The default lifetime of the credential in seconds. */
      credentialTtl?: number;
      /** The default lifetime of the auth-token in seconds. */
      authTokenTtl?: number;
      /** The default lifetime of the reset-token in seconds. */
      resetTokenTtl?: number;
      /** Should OTP be required to exchange token. */
      otpRequired?: boolean;
    };
    AuthenticationToken: {
      /** The token identifier string. */
      token?: string;
      /** The token's generation mode. */
      mode?: "password" | "passwordless";
      /** Should OTP be required to exchange this token. */
      otpRequired?: boolean;
      /** The credential's ID. */
      credentialId?: components["schemas"]["ResourceId"];
    };
    AuthenticationTokenMetadata: {
      /** Token's expired time. */
      expiredTime?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    password: components["schemas"]["AuthenticationToken"] & {
      /** The token's username. */
      username?: string;
      /** The token's password. */
      password?: string;
      /** The token's customer ID. */
      customerId?: components["schemas"]["ResourceId"];
    } & components["schemas"]["AuthenticationTokenMetadata"];
    passwordless: components["schemas"]["AuthenticationToken"] & {
      /** The token's customer ID. */
      customerId?: components["schemas"]["ResourceId"];
    } & components["schemas"]["AuthenticationTokenMetadata"];
    ApiKeyScope: {
      /** The array of account identifier strings. */
      organizationId?: components["schemas"]["ResourceId"][];
      /** The array of product identifier strings. */
      productId?: components["schemas"]["ResourceId"][];
      /** The array of plan identifier strings. */
      planId?: components["schemas"]["ResourceId"][];
      /** The array of custom field names. */
      customFieldName?: string[];
    };
    AclPermissions: string[];
    Acl: {
      /** Api Key scope. */
      scope: components["schemas"]["ApiKeyScope"];
      /** Specify individual permission here if creating a restricted API key. Use wildcard `*` for full access. */
      permissions: components["schemas"]["AclPermissions"];
    }[];
    CustomerLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "customer" | "targetCustomer";
    };
    CustomerJWT: {
      /** The session identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Session type. */
      type?: "customer";
      /** The session's token used for authentication. */
      token?: string;
      /** Whether to invalidate token after exchange or not. */
      invalidate?: boolean;
      /** The one time password sent via an email. Should contain digits only. */
      oneTimePassword?: string;
      /** The customer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      acl?: components["schemas"]["Acl"];
      customClaims?: { [key: string]: any };
      /** Session created time. */
      createdTime?: string;
      /** Session updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Session expired time. Defaults to one hour. */
      expiredTime?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["CustomerLink"][];
    };
    /** The list of phone numbers. */
    ContactPhoneNumbers: {
      /** The phone label. */
      label: string;
      /** The phone value. */
      value: string;
      /** True if phone is primary. */
      primary?: boolean;
    }[];
    /** The list of emails. */
    ContactEmails: {
      /** The email label. */
      label: string;
      /** The email value. */
      value: string;
      /** True if email is primary. */
      primary?: boolean;
    }[];
    ContactObject: {
      /** The contact first name. */
      firstName?: string | null;
      /** The contact last name. */
      lastName?: string | null;
      /** The contact organization. */
      organization?: string | null;
      /** The contact street address. */
      address?: string | null;
      /** The contact street address (second line). */
      address2?: string | null;
      /** The contact city. */
      city?: string | null;
      /** The contact region (state). */
      region?: string | null;
      /** The contact country ISO Alpha-2 code. */
      country?: string | null;
      /** The contact postal code. */
      postalCode?: string | null;
      phoneNumbers?: components["schemas"]["ContactPhoneNumbers"];
      emails?: components["schemas"]["ContactEmails"];
      /** A hash that can be used to compare multiple contacts for identical attribute values. */
      hash?: string;
    };
    /** Custom Fields list as a map `{"custom field name": "custom field value", ...}`. The format must follow the saved format (see Custom Fields section for the formats). */
    ResourceCustomFields: { [key: string]: any };
    /** Browser data used for 3DS and risk scoring. */
    BrowserData: {
      /** The browser's accept header value. */
      acceptHeader?: string;
      /** The browser's color depth in bits per pixel obtained using the `screen.colorDepth` property. */
      colorDepth: 1 | 4 | 8 | 15 | 16 | 24 | 32 | 48;
      /** The browser's IP address (ipv4 or ipv6). */
      ipAddress?: string;
      /** Whether Java is enabled in a browser or not. Value is returned from the `navigator.javaEnabled` property. */
      javaEnabled: boolean;
      /** The browser's language settings returned from the `navigator.language` property. */
      language: string;
      /** The browser's screen height returned from the `screen.height` property. */
      screenHeight: number;
      /** The browser's screen width returned from the `screen.width` property. */
      screenWidth: number;
      /**
       * The browser's time zone offset in minutes from UTC.
       * A positive offset indicates the local time is behind UTC, and negative is ahead.
       * Can find it with `(new Date()).getTimezoneOffset()` property.
       */
      timeZoneOffset: number;
      /** The user-agent header. */
      userAgent?: string;
      /** The device fingerprint hash. See [Valve's fingerprintjs2](https://github.com/Valve/fingerprintjs2). */
      deviceFingerprintHash?: string;
    };
    CommonBankAccount: {
      /** The payment instrument ID. */
      id?: components["schemas"]["ResourceId"];
      /** The method of payment instrument. */
      method?: "ach";
      /** The customer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /** Bank's name. */
      bankName?: string;
      /** Bank's routing number. */
      routingNumber?: string;
      /** Bank's account number type. A valid value is basic bank account number (BBAN) or international bank account number (IBAN). */
      accountNumberType?: "BBAN" | "IBAN";
      /** Bank's account type. */
      accountType?: "checking" | "savings" | "other";
      /** Bank Identifier Code. */
      bic?: string;
      /** The billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      /** A unique value to identify the bank account. It contains alphanumeric values. */
      fingerprint?: string;
      /** The last 4 digits of the bank account. */
      last4?: string;
      /** Bank account status. */
      status?: "active" | "deactivated";
      /** Bank account created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Bank account updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    /** The payment method. */
    PaymentMethod:
      | "payment-card"
      | "ach"
      | "cash"
      | "check"
      | "paypal"
      | "AdvCash"
      | "Airpay"
      | "Alfa-click"
      | "Alipay"
      | "APAR"
      | "Apple Pay"
      | "AstroPay Card"
      | "bank-transfer"
      | "bank-transfer-2"
      | "bank-transfer-3"
      | "bank-transfer-4"
      | "bank-transfer-5"
      | "bank-transfer-6"
      | "bank-transfer-7"
      | "bank-transfer-8"
      | "bank-transfer-9"
      | "Beeline"
      | "Belfius-direct-net"
      | "bitcoin"
      | "Boleto"
      | "Boleto-2"
      | "Boleto-3"
      | "cash-deposit"
      | "CASHlib"
      | "CashToCode"
      | "CCAvenue"
      | "China UnionPay"
      | "CODVoucher"
      | "Conekta-oxxo"
      | "Conekta-spei"
      | "cryptocurrency"
      | "Cupon-de-pagos"
      | "domestic-cards"
      | "echeck"
      | "ecoPayz"
      | "ecoVoucher"
      | "EPS"
      | "ePay.bg"
      | "Ethereum"
      | "e-wallet"
      | "eZeeWallet"
      | "Flexepin"
      | "Giropay"
      | "Google Pay"
      | "Gpaysafe"
      | "iDebit"
      | "iDEAL"
      | "ING-homepay"
      | "INOVAPAY-pin"
      | "INOVAPAY-wallet"
      | "InstaDebit"
      | "instant-bank-transfer"
      | "Interac-online"
      | "Interac-eTransfer"
      | "Interac-express-connect"
      | "Interac"
      | "invoice"
      | "Jeton"
      | "jpay"
      | "Khelocard"
      | "Klarna"
      | "Litecoin"
      | "LPG-online"
      | "LPG-payment-card"
      | "Megafon"
      | "miscellaneous"
      | "Mistercash"
      | "MTS"
      | "MuchBetter"
      | "MyFatoorah"
      | "Neosurf"
      | "Netbanking"
      | "Neteller"
      | "Nordea-Solo"
      | "OchaPay"
      | "online-bank-transfer"
      | "Onlineueberweisen"
      | "oriental-wallet"
      | "OXXO"
      | "Pagsmile-lottery"
      | "Pagsmile-deposit-express"
      | "PayCash"
      | "Payeer"
      | "Paysafecard"
      | "Pay4Fun"
      | "Paymero"
      | "Paymero-QR"
      | "PayULatam"
      | "Perfect-money"
      | "Piastrix"
      | "PIX"
      | "PinPay"
      | "phone"
      | "POLi"
      | "Przelewy24"
      | "QIWI"
      | "QQPay"
      | "Resurs"
      | "SEPA"
      | "Siirto"
      | "Skrill"
      | "Skrill Rapid Transfer"
      | "SMSVoucher"
      | "Sofort"
      | "SparkPay"
      | "swift-dbt"
      | "Tele2"
      | "Terminaly-RF"
      | "Tether"
      | "ToditoCash-card"
      | "Trustly"
      | "TWINT"
      | "UniCrypt"
      | "UPayCard"
      | "VCreditos"
      | "voucher"
      | "voucher-2"
      | "voucher-3"
      | "voucher-4"
      | "Webmoney"
      | "Webpay"
      | "Webpay-2"
      | "Webpay Card"
      | "WeChat Pay"
      | "Yandex-money"
      | "Zotapay"
      | "Zimpler";
    /** Vaulted payment instrument. */
    VaultedInstrument: {
      /**
       * The payment method supported vault.
       * See [Payment Instruments API](https://api-reference.rebilly.com/tag/Payment-Instruments).
       */
      method: "payment-card" | "ach" | "paypal";
      /** The payment instrument identifier. */
      paymentInstrumentId: components["schemas"]["ResourceId"];
    };
    /** Alternative payment method instrument. */
    AlternativePaymentInstrument: {
      method: components["schemas"]["PaymentMethod"];
    };
    /** Cash payment instrument object. */
    CashInstrument: {
      method: "cash";
      /** The receiver's name. */
      receivedBy?: string;
    };
    /** Check payment instrument object. */
    CheckInstrument: {
      method: "cash";
      /** Reference data. */
      reference?: string;
    };
    PaymentInstrument:
      | components["schemas"]["VaultedInstrument"]
      | components["schemas"]["AlternativePaymentInstrument"]
      | components["schemas"]["CashInstrument"]
      | components["schemas"]["CheckInstrument"];
    CustomerAverageValue: {
      /** Merchant's reporting currency. */
      currency?: components["schemas"]["CurrencyCode"];
      /** Average approved payment amount in Merchant's reporting currency. */
      amount?: number;
      /** Average approved payment amount in USD. */
      amountUsd?: number;
    };
    CustomerLifetimeRevenue: {
      /** Merchant's reporting currency. */
      currency?: components["schemas"]["CurrencyCode"];
      /** Revenue amount in Merchant's reporting currency. */
      amount?: number;
      /** Revenue amount in USD. */
      amountUsd?: number;
    };
    /** Tag. */
    Tag: {
      /** The tag's identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The tag is unique name, which is case-insensitive. */
      name: string;
      /** The tag's created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The tag's updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: Partial<components["schemas"]["SelfLink"]>[];
    };
    DefaultPaymentInstrumentLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "defaultPaymentInstrument";
    };
    LeadSourceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "leadSource";
    };
    WebsiteLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "website";
    };
    LeadSourceData: {
      /** Lead source medium (eg search, display). */
      medium?: string;
      /** Lead source origin (eg google, yahoo). */
      source?: string;
      /** Lead source campaign (eg go-big-123). */
      campaign?: string;
      /** Lead source term (eg salt shakers). */
      term?: string;
      /** Lead source content (eg smiley faces). */
      content?: string;
      /** Lead source affiliate (eg 123, Bob Smith). */
      affiliate?: string;
      /** Lead source sub-affiliate also called a sub-id or click id in some circles (eg 123456). */
      subAffiliate?: string;
      /** Lead source sales agent (eg James Bond). */
      salesAgent?: string;
      /** Lead source click id (may come from an ad server). */
      clickId?: string;
      /** Lead source path url (eg www.example.com/some/landing/path). */
      path?: string;
      /** Lead source [`referer` url](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) as determined (eg www.example.com/some/landing/path). */
      referrer?: string;
      /** Lead source created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
    };
    LeadSource: components["schemas"]["LeadSourceData"] & {
      original?: components["schemas"]["LeadSourceData"];
    };
    /** Lead Source object. */
    LeadSourceEmbed: {
      leadSource?: components["schemas"]["LeadSource"];
    };
    Customer: {
      /** The customer identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The website's ID. */
      websiteId?: components["schemas"]["ResourceId"];
      /**
       * A write-only payment token; if supplied, it will be converted into a
       * payment instrument and be set as the `defaultPaymentInstrument`. The
       * value of this property will override the `defaultPaymentInstrument`
       * in the case that both are supplied. The token may only be used once
       * before it is expired.
       */
      paymentToken?: string;
      defaultPaymentInstrument?: components["schemas"]["PaymentInstrument"];
      /** The customer created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The customer updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      primaryAddress?: components["schemas"]["ContactObject"];
      averageValue?: components["schemas"]["CustomerAverageValue"];
      /** The number of approved payments for the customer. */
      paymentCount?: number;
      /** The most recent time of an approved payment for the customer. */
      lastPaymentTime?: components["schemas"]["ServerTimestamp"];
      lifetimeRevenue?: components["schemas"]["CustomerLifetimeRevenue"];
      /** An auto-incrementing number based on the sequence of invoices. If set to 0, then this record is a Lead, otherwise is a Customer. */
      invoiceCount?: number;
      /** A list of customer's tags. */
      tags?: components["schemas"]["Tag"][];
      /**
       * The number of times the customer data has been modified.
       * The revision is useful when analyzing webhook data to determine if the change takes precedence over the current representation.
       */
      revision?: number;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["DefaultPaymentInstrumentLink"]> &
        Partial<components["schemas"]["LeadSourceLink"]> &
        Partial<components["schemas"]["WebsiteLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: Partial<components["schemas"]["LeadSourceEmbed"]>[];
    };
    /** Customer object. */
    CustomerEmbed: {
      customer?: components["schemas"]["Customer"];
    };
    BankAccount: components["schemas"]["CommonBankAccount"] & {
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: Partial<components["schemas"]["CustomerEmbed"]>[];
    };
    BankAccountCreateToken: {
      /** The Customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** BankAccountToken ID. */
      token: string;
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    /** BBAN type object. */
    BBANType: {
      /** The method of payment instrument. */
      method: "ach";
      /** Customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /**
       * Bank's Account Number type. A valid value is basic bank account number (BBAN) or international bank account number (IBAN).
       * This is the object for the BBAN.
       */
      accountNumberType: "IBAN" | "BBAN";
      /** Bank's account number. */
      accountNumber: string;
      /** Bank's routing number. */
      routingNumber: string;
      /** Bank's account type. */
      accountType: "checking" | "savings" | "other";
      /** Bank's name. */
      bankName?: string;
      /** Bank Identifier Code. */
      bic?: string;
      /** The billing address. */
      billingAddress: components["schemas"]["ContactObject"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    /** IBAN type object. */
    IBANType: {
      /** The method of payment instrument. */
      method: "ach";
      /** Customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /**
       * Bank's Account Number type. A valid value is basic bank account number (BBAN) or international bank account number (IBAN).
       * This is the object for the IBAN.
       */
      accountNumberType: "IBAN" | "BBAN";
      /** Bank's account number. Detailed information about all ISO 13616-compliant national IBAN formats is available in the [SWIFT IBAN Registry](https://www.swift.com/standards/data-standards/iban). */
      accountNumber: string;
      /** Bank's name. */
      bankName?: string;
      /** Bank Identifier Code. */
      bic?: string;
      /** The billing address. */
      billingAddress: components["schemas"]["ContactObject"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    BankAccountCreatePlain: Partial<components["schemas"]["BBANType"]> &
      Partial<components["schemas"]["IBANType"]>;
    BankAccountUpdatePlain: {
      /** Bank's name. */
      bankName?: string;
      /** Bank's account type. */
      accountType?: "checking" | "savings" | "other";
      /** The billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    Blocklist: {
      /** The blocklist identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The blocklist type. */
      type:
        | "payment-card"
        | "bank-account"
        | "customer-id"
        | "email"
        | "email-domain"
        | "ip-address"
        | "country"
        | "fingerprint"
        | "bin"
        | "address";
      /** The blocklist value. */
      value: string;
      /** The blocklist expiration time. */
      expirationTime?: string;
      /** The blocklist created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The blocklist updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** discounts-per-redemption restrictions. */
    "discounts-per-redemption": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Restriction quantity. */
        quantity: number;
      };
    /** Coupon restrictions. */
    CouponRestriction: {
      /** Coupon's restriction type. */
      type:
        | "discounts-per-redemption"
        | "minimum-order-amount"
        | "redemptions-per-customer"
        | "restrict-to-invoices"
        | "restrict-to-plans"
        | "restrict-to-subscriptions"
        | "restrict-to-products"
        | "total-redemptions"
        | "paid-by-time";
    };
    /** Redemption restrictions. */
    RedemptionRestriction: {
      /** Redemption's additional restriction type. */
      type:
        | "discounts-per-redemption"
        | "minimum-order-amount"
        | "restrict-to-invoices"
        | "restrict-to-plans"
        | "restrict-to-subscriptions"
        | "restrict-to-products"
        | "paid-by-time";
    };
    /** minimum-order-amount restrictions. */
    "minimum-order-amount": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Minimum order quantity. */
        amount: number;
        currency: components["schemas"]["CurrencyCode"];
      };
    /** paid-by-time restrictions. */
    "paid-by-time": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** The time when the coupon's redemption is no longer valid and removed from unpaid invoices if applied. Note that this datetime cannot be changed. */
        time: string;
      };
    /** Quantity per Customer restrictions. */
    "redemptions-per-customer": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Restriction value. */
        quantity: number;
      };
    /** restrict-to-invoices restrictions. */
    "restrict-to-invoices": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Invoice IDs coupon can be applied to. */
        invoiceIds: string[];
      };
    /** restrict-to-plans restrictions. */
    "restrict-to-plans": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Plan IDs coupon can be applied to. */
        planIds: string[];
      };
    /** restrict-to-products restrictions. */
    "restrict-to-products": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Product IDs coupon can be applied to. */
        productIds: string[];
      };
    /** restrict-to-subscriptions restrictions. */
    "restrict-to-subscriptions": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Order IDs coupon can be applied to. */
        subscriptionIds: string[];
      };
    /** total-redemptions restrictions. */
    "total-redemptions": components["schemas"]["CouponRestriction"] &
      components["schemas"]["RedemptionRestriction"] & {
        /** Total redemptions quantity. */
        quantity: number;
      };
    /** Coupons redemption log. */
    CouponRedemption: {
      id?: components["schemas"]["ResourceId"];
      /** Coupon's ID. */
      couponId?: components["schemas"]["ResourceId"];
      /** Customer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /** Additional restrictions for coupon's redemptions. */
      additionalRestrictions?: components["schemas"]["RedemptionRestriction"][];
      /** Coupon redeem time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Coupon redemption canceled time. */
      canceledTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Discount: {
      /** Discount type. */
      type?: "fixed" | "percent";
    };
    /** Coupon fixed amount discount. */
    fixed: components["schemas"]["Discount"] & {
      /** Discount amount. */
      amount: number;
      currency: components["schemas"]["CurrencyCode"];
    };
    /** Coupon percent discount. */
    percent: components["schemas"]["Discount"] & {
      /** Discount percent. */
      value: number;
    };
    /** Coupons and Discounts. */
    Coupon: {
      /** Coupon's ID a.k.a redemption code. */
      id?: components["schemas"]["ResourceId"];
      discount: components["schemas"]["Discount"];
      /** Coupon restrictions. */
      restrictions?: components["schemas"]["CouponRestriction"][];
      /** Coupon's redemptions count. */
      redemptionsCount?: number;
      /** If coupon enabled. */
      status?: "draft" | "issued" | "expired";
      /** Your coupon description. When it is not empty this is used for invoice discount item description, otherwise the item's description uses coupon's ID like 'Coupon "COUPON-ID"'. */
      description?: string;
      /** Coupon's issued time (start time). */
      issuedTime: string;
      /** Coupon's expire time (end time). */
      expiredTime?: string;
      /** Coupon created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Coupon updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    CouponExpiration: {
      /** The coupon's expiry time, must be greater than the issued time. Null or empty string will immediately expire the coupon. */
      expiredTime: string;
    };
    Credential: {
      /** The credential identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Credential's username. */
      username: string;
      /** The credential's password. */
      password: string;
      /** The credential's customer ID. */
      customerId: string;
      /** The credential's expired time. */
      expiredTime?: string;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
    };
    /** A separate Custom Field schema. */
    CustomField: {
      /** The name of the custom field. */
      name?: string;
      /**
       * Type value    | Description
       * ------------- | -------------
       * array         | An array of strings up to 255 characters, maximum size is 1000 elements boolean       | true or false date          | String of format "full-date" (YYYY-MM-DD) from RFC-3339 (full-date) datetime      | String of format "date-time" (YYYY-MM-DDTHH:MM:SSZ) from RFC-3339 (date-time) integer       | Cardinal value of -2^31..2^31-1 number        | Float value. It can take cardinal values also which are interpreted as float string        | Regular string up to 255 characters monetary      | A map of 3-letters currency code and amount, e.g. {"currency": "EUR", "amount": 25.30}
       * The type cannot be changed.
       */
      type:
        | "array"
        | "boolean"
        | "datetime"
        | "integer"
        | "number"
        | "string"
        | "monetary";
      /** The custom field description. */
      description?: string;
      /**
       * Additional parameters which can be added according to type:
       * Parameter Name | Types         | Description
       * -------------- | ------------- | -------------
       * allowedValues  | string, array | List of allowed values maxLength      | string        | Maximum allowed length for the string, 255 by default, up to 4000
       * The additional schema adds additional constrains for values.
       */
      additionalSchema?: { [key: string]: any };
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    CustomerTimelineCustomEvent: {
      /** Customer Timeline Custom Event identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Customer Timeline Custom Event type name. It must not be similar to any Rebilly system event. */
      name: string;
      /** Customer Timeline Custom event created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Customer Timeline Custom event updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    TimelineAction: {
      action?: "resend-email" | "redemption-cancel";
    };
    /** Cancel Redemption. */
    "redemption-cancel": components["schemas"]["TimelineAction"] & {
      redemptionId?: components["schemas"]["ResourceId"];
    };
    /** Resend Email action. */
    "resend-email": components["schemas"]["TimelineAction"] & {
      messageId?: components["schemas"]["ResourceId"];
    };
    /** Additional information about Timeline message. */
    TimelineTable: {
      type?: "two-columns" | "three-columns";
      /** Data table title. */
      title?: string;
      /** Data table footer. */
      footer?: string;
    };
    "three-columns": components["schemas"]["TimelineTable"] & {
      /** Table data. Each array element represents a table row. */
      data?: {
        attribute?: string;
        previousValue?: string;
        newValue?: string;
      }[];
    };
    "two-columns": components["schemas"]["TimelineTable"] & {
      /** Table data. Each array element represents a table row. */
      data?: {
        attribute?: string;
        value?: string;
      }[];
    };
    /** Additional data. */
    TimelineExtraData: {
      /** Actions available to a Timeline message. Can be empty in case no actions are available for a message. */
      actions?: components["schemas"]["TimelineAction"][];
      tables?: components["schemas"]["TimelineTable"][];
      /** Timeline comment author data. */
      author?: {
        userFullName?: string;
        userId?: string;
      };
      mentions?: { [key: string]: string };
      links?: {
        resourceType?:
          | "kyc-document"
          | "invoice"
          | "subscription"
          | "transaction"
          | "email-message"
          | "dispute"
          | "credit-memo"
          | "coupon";
        resourceId?: components["schemas"]["ResourceId"];
        placeholder?: string;
      }[];
    };
    CustomerTimeline: {
      /** The Timeline message identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Timeline message type. */
      type?:
        | "customer-comment-created"
        | "customer-created"
        | "primary-address-changed"
        | "default-payment-instrument-changed"
        | "lead-source-changed"
        | "custom-fields-changed"
        | "coupon-applied"
        | "coupon-redeemed"
        | "coupon-redemption-canceled"
        | "kyc-document-created"
        | "kyc-document-accepted"
        | "kyc-document-manually-accepted"
        | "kyc-document-rejected"
        | "kyc-document-manually-rejected"
        | "payment-card-expired"
        | "payment-instrument-created"
        | "payment-instrument-deactivated"
        | "customer-bank-account-blocked"
        | "customer-blocked"
        | "customer-payment-card-blocked"
        | "invoice-created"
        | "invoice-issued"
        | "invoice-abandoned"
        | "invoice-voided"
        | "invoice-past-due"
        | "invoice-paid"
        | "invoice-partially-paid"
        | "invoice-disputed"
        | "invoice-refunded"
        | "invoice-partially-refunded"
        | "order-created"
        | "order-renewed"
        | "order-activated"
        | "order-completed"
        | "order-reactivated"
        | "order-canceled"
        | "order-upgraded"
        | "order-downgraded"
        | "order-churned"
        | "order-paid-early"
        | "transaction-approved"
        | "transaction-canceled"
        | "transaction-declined"
        | "transaction-abandoned"
        | "transaction-refunded"
        | "transaction-voided"
        | "transaction-discrepancy-found"
        | "transaction-amount-discrepancy-found"
        | "email-message-sent"
        | "custom-event-processed"
        | "custom-event"
        | "transaction-waiting-gateway"
        | "aml-list-was-possibly-matched"
        | "experian-check-performed";
      /** Timeline custom event type. Used with `custom-event` type. Must be defined using [Customer Timeline custom event API](#operation/PostCustomerTimelineCustomEventType). */
      customEventType?: string | null;
      /** Timeline custom event data. Used with `custom-event` type. Will be transformed to `extraData` two-column table in response. */
      customData?: { [key: string]: any };
      /** Shows who or what triggered the Timeline message. */
      triggeredBy?: "rebilly" | "app" | "direct-api";
      /** The message that describes the message details. */
      message?: string;
      extraData?: components["schemas"]["TimelineExtraData"];
      /** Timeline message time. */
      occurredTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    ProductLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "product";
    };
    /**
     * Products include digital goods, services, and physical goods.
     * Products appear on invoice line items. If you set a tax category identifier,
     * taxes will be calculated upon invoice generation. If it is shippable,
     * shipping will be calculated upon invoice generation. Pricing and
     * variations are set within Plans.
     */
    CommonProduct: {
      /** The product ID. */
      id?: components["schemas"]["ResourceId"];
      /** The product name. */
      name: string;
      /** The unit label, such as per `seat` or per `unit`. */
      unitLabel?: string;
      /** The product description. */
      description?: string;
      /** If the product requires shipping, shipping calculations will be applied. */
      requiresShipping?: boolean;
      /**
       * The product options such as color, size, etc. The product options definition does
       * not include option values. Those are defined within the plans.
       */
      options?: string[];
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** The product created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The product updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    Product: components["schemas"]["CommonProduct"] & {
      /** The product's tax category identifier string. */
      taxCategoryId?:
        | "00000"
        | "99999"
        | "20010"
        | "40030"
        | "51020"
        | "51010"
        | "31000"
        | "30070";
      /** The product accounting code. */
      accountingCode?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Product object. */
    ProductEmbed: {
      product?: components["schemas"]["Product"];
    };
    PlanPriceFormula: {
      /**
       * The price formula determines what algorithm is used to calculate the invoice price based on a few factors,
       * - the quantity in the order (which may be variable if usage pricing, otherwise determined when creating the order)
       * - the price brackets data
       *
       * To determine which formula is correct, please see the price formula documentation.
       */
      formula: "fixed-fee" | "flat-rate" | "stairstep" | "tiered" | "volume";
    };
    "fixed-fee": components["schemas"]["PlanPriceFormula"] & {
      /**
       * For the very simple price when it's fixed and does not depend on the quantity chosen by customer.
       *
       * If the price is 0, it's free.
       */
      price: number;
    };
    "flat-rate": components["schemas"]["PlanPriceFormula"] & {
      /**
       * Flat-rate pricing is represented in a simple price per unit.
       * Some examples:
       *
       * - $30 per unit
       * - $0.10 per transaction
       * - $50 per period
       *
       * If the price is 0, it's free.
       */
      price: number;
      /** If the value is `null`, it''s assumed to be infinite. */
      maxQuantity?: number;
    };
    stairstep: components["schemas"]["PlanPriceFormula"] & {
      /**
       * The price brackets, along with the price formula,
       * is used to calculate the amount to charge for the product on this plan on the invoice.
       *
       * The "stairstep" example:
       *
       * Price total | Max quantity | Description
       * ------------|--------------|------------
       * $5          | 1            | 1
       * $13         | 5            | 2 to 5
       * $30         | null         | 6 or more
       *
       * If someone bought 1 apple, it would be $5.
       *
       * If someone bought 2 apples, it would be $13. For 2 to 5 apples, the price is $13 in any case.
       */
      brackets: {
        /** If the price is 0, it is free. */
        price?: number;
        /**
         * If the value is `null`, it's assumed to be infinite.  It starts at the end of the previous bracket.
         * If there is no previous bracket, it starts at 1.
         */
        maxQuantity?: number;
      }[];
    };
    tiered: components["schemas"]["PlanPriceFormula"] & {
      /**
       * The price brackets, along with the price formula,
       * is used to calculate the amount to charge for the product on this plan on the invoice.
       *
       * The "tiered" example:
       *
       * Price per apple | Max quantity | Description
       * ----------------|--------------|------------
       * $5              | 1            | 1
       * $4              | 5            | 2 to 5
       * $3              | null         | 6 or more
       *
       * If someone bought 1 apple, it would be $5.
       *
       * If someone bought 2 apples, it would be $9. $5 per apple for the first apple, then $4 per apple for the 2nd to 5th apple.
       */
      brackets: {
        /** If the price is 0, it is free. */
        price?: number;
        /**
         * If the value is `null`, it's assumed to be infinite.  It starts at the end of the previous bracket.
         * If there is no previous bracket, it starts at 1.
         */
        maxQuantity?: number;
      }[];
    };
    volume: components["schemas"]["PlanPriceFormula"] & {
      /**
       * The price brackets, along with the price formula,
       * is used to calculate the amount to charge for the product on this plan on the invoice.
       *
       * The "volume" example:
       *
       * Price per apple | Max quantity | Description
       * ----------------|--------------|------------
       * $5              | 1            | 1
       * $4              | 5            | 2 to 5
       * $3              | null         | 6 or more
       *
       * If someone bought 1 apple, it would be $5.
       *
       * If someone bought 2 apples, it would be $8. For 2 to 5 apples, the price is $4 per apple.
       */
      brackets: {
        /** If the price is 0, it is free. */
        price?: number;
        /**
         * If the value is `null`, it's assumed to be infinite.  It starts at the end of the previous bracket.
         * If there is no previous bracket, it starts at 1.
         */
        maxQuantity?: number;
      }[];
    };
    PlanPeriod: {
      /** The unit of time. */
      unit: "day" | "week" | "month" | "year";
      /** The length of time. */
      length: number;
    };
    /**
     * The billing timing in relation to the service period.
     * For `prepaid` plans the customer pays when the service period starts,
     * whereas, for `postpaid` plans, the customer pays when the service period ends.
     */
    PlanBillingTiming: "prepaid" | "postpaid";
    CommonPlan: {
      /** The plan ID. */
      id?: components["schemas"]["ResourceId"];
      /** The plan name, displayed on invoices and receipts. */
      name: string;
      /** The related product ID. */
      productId: components["schemas"]["ResourceId"];
      /** Name-value pairs to specify the product options. */
      productOptions?: { [key: string]: string };
      currency: components["schemas"]["CurrencyCode"];
      /** Currency sign. */
      currencySign?: string;
      pricing: components["schemas"]["PlanPriceFormula"];
      /** The service interval. For a one-time item, use `null`. */
      recurringInterval?: components["schemas"]["PlanPeriod"] & {
        /**
         * The number of invoices this subscription order will generate
         * (if 1, it will not generate any beyond the initial order creation).
         * For example, set this property to `12`, when the `periodUnit` is month and the
         * `periodDuration` is 1, for a 1 year contract billed monthly.
         */
        limit?: number;
        billingTiming?: components["schemas"]["PlanBillingTiming"];
      };
      /** The trial. Set `null` if no trial. */
      trial?: {
        /** The price of the trial. For a free trial, use `0`. */
        price: number;
        period: components["schemas"]["PlanPeriod"];
      };
      /** Whether a plan has a trial without recurring instructions. */
      isTrialOnly?: boolean;
      /** The setup. Set `null` if no setup. */
      setup?: {
        /** The price of a setup - 0 is a valid value (for free). */
        price: number;
      };
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** Plan created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Plan updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    TimeUnit: "second" | "minute" | "hour" | "day" | "month" | "year";
    TimePluralUnit:
      | "seconds"
      | "minutes"
      | "hours"
      | "days"
      | "months"
      | "years";
    /**
     * The calculation instruction of billing time.
     * This is used in conjunction with the **service period anchor** to calculate the time the invoice is issued.
     */
    IssueTimeShiftInstruction: {
      /** The chronology of the billing time relatively to the service period start. */
      chronology: "before";
      /** The number of the units. */
      duration: number;
      unit:
        | components["schemas"]["TimeUnit"]
        | components["schemas"]["TimePluralUnit"];
    };
    /**
     * The calculation instruction of due time.
     * This is used in conjunction with the **billing anchor** to calculate due time of invoice.
     * The chronology of due time shift is always **after**.
     */
    DueTimeShiftInstruction: {
      /** The number of the units. */
      duration: number;
      unit:
        | components["schemas"]["TimeUnit"]
        | components["schemas"]["TimePluralUnit"];
    };
    /**
     * The invoice time shift in conjunction with `billingTiming` allows to setup different billing use cases such as:
     * - Bill immediately when the service period _starts_
     * - Bill immediately after the service period _ends_
     * - Bill _interval of time_ before the service period _starts_
     * - Bill _interval of time_ after the service period _starts_
     * - Bill _interval of time_ before the service period _ends_
     * - Bill _interval of time_ after the service period _ends_
     * It allows to control the billing time.
     */
    InvoiceTimeShift: {
      issueTimeShift?: components["schemas"]["IssueTimeShiftInstruction"];
      dueTimeShift?: components["schemas"]["DueTimeShiftInstruction"];
    };
    Plan: components["schemas"]["CommonPlan"] & {
      /** You can shift issue time and due time of invoices for this plan. */
      invoiceTimeShift?: components["schemas"]["InvoiceTimeShift"];
      /** Number of subscriptions associated with this plan. */
      subscriptionCount?: number;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Plan object. */
    PlanEmbed: {
      plan?: components["schemas"]["Plan"];
    };
    InvoiceItem: {
      /** The website identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Invoice item's type. */
      type: "debit" | "credit";
      /** Invoice item's description. */
      description?: string;
      /** Invoice item's price. */
      unitPrice: number;
      /** Invoice item's quantity. */
      quantity?: number;
      /** Invoice item's total price. */
      price?: number;
      /** The product's ID. */
      productId?: components["schemas"]["ResourceId"];
      /** Invoice item discount amount. */
      discountAmount?: number;
      /** Start time. */
      periodStartTime?: string;
      /** End time. */
      periodEndTime?: string;
      /** Invoice item subscription order period number. */
      periodNumber?: number;
      /** Invoice item created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice item updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["ProductLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["ProductEmbed"]> &
        Partial<components["schemas"]["PlanEmbed"]>)[];
    };
    InvoiceTax: {
      /** Tax amount. */
      amount?: number;
      /** Tax description. */
      description?: string;
    };
    InvoiceDiscount: {
      /** Coupon's ID. */
      couponId?: components["schemas"]["ResourceId"];
      /** Redemption ID. */
      redemptionId?: components["schemas"]["ResourceId"];
      /** Total amount that was discounted by this Coupon. */
      amount?: number;
      /** Discount description. */
      description?: string;
    };
    CommonInvoice: {
      /** The invoice ID. */
      id?: components["schemas"]["ResourceId"];
      /** An auto-incrementing number based on the sequence of invoices for any particular customer. */
      invoiceNumber?: number;
      /** The related order's ID if available, otherwise null. */
      subscriptionId?: components["schemas"]["ResourceId"];
      currency: components["schemas"]["CurrencyCode"];
      /** The invoice's amount. */
      amount?: number;
      /** The invoice's due amount. */
      amountDue?: number;
      /** The invoice's subtotal amount. */
      subtotalAmount?: number;
      /** The invoice's discounts amount. */
      discountAmount?: number;
      /** The invoice's taxes amount. */
      taxAmount?: number;
      /** The invoice's shipping amount. */
      shippingAmount?: number;
      /** Invoice's billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      /** Invoice's delivery address. */
      deliveryAddress?: components["schemas"]["ContactObject"];
      /** Purchase order number which will be displayed on the invoice. */
      poNumber?: string | null;
      /** Notes for the customer which will be displayed on the invoice. */
      notes?: string;
      /** Invoice items array. */
      items?: components["schemas"]["InvoiceItem"][];
      /** Taxes applied to this invoice. */
      taxes?: components["schemas"]["InvoiceTax"][];
      /** Discounts applied. */
      discounts?: components["schemas"]["InvoiceDiscount"][];
      /** Invoice autopay scheduled time. */
      autopayScheduledTime?: string;
      /** Invoice autopay retry number. */
      autopayRetryNumber?: number;
      /** Invoice status. */
      status?:
        | "draft"
        | "unpaid"
        | "paid"
        | "past-due"
        | "delinquent"
        | "abandoned"
        | "voided"
        | "partially-refunded"
        | "refunded"
        | "disputed";
      /** Delinquent collection period - difference between paidTime and dueTime in days. */
      delinquentCollectionPeriod?: number;
      /** Collection period - difference between paidTime and issuedTime in days. */
      collectionPeriod?: number;
      /**
       * URL where the customer can be redirected to pay for the invoice
       * with one of the methods which are available for this customer.
       * It's an alternative to creating a new transaction with empty `methods`.
       */
      paymentFormUrl?: string;
      /** Invoice abandoned time. */
      abandonedTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice voided time. */
      voidedTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice paid time. */
      paidTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice due time. */
      dueTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice issued time. */
      issuedTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Invoice updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    InstrumentReference: {
      method: "payment-card" | "ach" | "paypal";
      /** The payment instrument ID. */
      paymentInstrumentId: components["schemas"]["ResourceId"];
    };
    MethodReference: {
      method: components["schemas"]["PaymentMethod"];
    };
    PaymentInstrumentReference:
      | components["schemas"]["InstrumentReference"]
      | components["schemas"]["MethodReference"];
    ThreeDSecureResult: {
      /** 3D Secure version. */
      version?: "1.0.2" | "2.1.0" | "2.2.0";
      /** Is the cardholder enrolled in 3D Secure. */
      enrolled: "yes" | "no" | "invalid card/timeout" | "unavailable";
      /** 3D Secure authentication response status. */
      authenticated: "yes" | "no" | "not applicable" | "attempted";
      liability: "protected" | "not protected" | "protected (attempt)";
      /** 3D Secure 2 authentication flow. */
      flow?: "frictionless" | "challenge";
      /** If 3D Secure 2 was attempted but downgraded to 3D Secure 1. */
      isDowngraded: boolean;
    };
    /** The payment gateway name. */
    GatewayName:
      | "A1Gateway"
      | "Adyen"
      | "Airpay"
      | "AmexVPC"
      | "APAR"
      | "ApcoPay"
      | "AsiaPaymentGateway"
      | "AstroPayCard"
      | "AuthorizeNet"
      | "Bambora"
      | "BitPay"
      | "BlueSnap"
      | "BraintreePayments"
      | "Cardknox"
      | "Cashflows"
      | "CASHlib"
      | "CashToCode"
      | "CauriPayment"
      | "Cayan"
      | "CCAvenue"
      | "Chase"
      | "Citadel"
      | "Clearhaus"
      | "CODVoucher"
      | "CoinPayments"
      | "Conekta"
      | "Coppr"
      | "Credorax"
      | "Cryptonator"
      | "CyberSource"
      | "DataCash"
      | "Dengi"
      | "Dragonphoenix"
      | "Directa24"
      | "dLocal"
      | "EBANX"
      | "ecoPayz"
      | "EcorePay"
      | "Elavon"
      | "Euteller"
      | "eMerchantPay"
      | "EMS"
      | "EPG"
      | "EPro"
      | "eZeeWallet"
      | "Finrax"
      | "Flexepin"
      | "FinTecSystems"
      | "FundSend"
      | "Forte"
      | "GET"
      | "Gigadat"
      | "GlobalOnePay"
      | "Gooney"
      | "Gpaysafe"
      | "Greenbox"
      | "HiPay"
      | "iCanPay"
      | "ICEPAY"
      | "iCheque"
      | "iDebit"
      | "Ilixium"
      | "Ingenico"
      | "INOVAPAY"
      | "Inovio"
      | "Intuit"
      | "InstaDebit"
      | "IpayOptions"
      | "JetPay"
      | "Jeton"
      | "Khelocard"
      | "Konnektive"
      | "LPG"
      | "Moneris"
      | "MtaPay"
      | "MuchBetter"
      | "MyFatoorah"
      | "Neosurf"
      | "Netbanking"
      | "Neteller"
      | "NGenius"
      | "NinjaWallet"
      | "NMI"
      | "NuaPay"
      | "OchaPay"
      | "Onlineueberweisen"
      | "Pagsmile"
      | "Panamerican"
      | "ParamountEft"
      | "ParamountInterac"
      | "PandaGateway"
      | "Pay4Fun"
      | "PayCash"
      | "Payeezy"
      | "Payflow"
      | "PaymenTechnologies"
      | "Paymero"
      | "PayPal"
      | "Payr"
      | "Paysafe"
      | "Paysafecash"
      | "PayULatam"
      | "Payvision"
      | "Piastrix"
      | "Plugnpay"
      | "Prosa"
      | "Realex"
      | "Realtime"
      | "Redsys"
      | "Rotessa"
      | "RPN"
      | "SaltarPay"
      | "Sagepay"
      | "SeamlessChex"
      | "SecureTrading"
      | "Skrill"
      | "SmartInvoice"
      | "SMSVoucher"
      | "Sofort"
      | "SparkPay"
      | "StaticGateway"
      | "Stripe"
      | "TestProcessor"
      | "ToditoCash"
      | "Trustly"
      | "TWINT"
      | "UPayCard"
      | "USAePay"
      | "VantivLitle"
      | "vegaaH"
      | "VCreditos"
      | "Wallet88"
      | "Walpay"
      | "Wirecard"
      | "WorldlineAtosFrankfurt"
      | "Worldpay"
      | "Zimpler"
      | "Zotapay";
    CommonTransaction: {
      /** The transaction ID. */
      id?: components["schemas"]["ResourceId"];
      /** The website ID. */
      websiteId?: components["schemas"]["ResourceId"];
      /** The ustomer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /** Transaction type. */
      type?:
        | "3ds-authentication"
        | "authorize"
        | "capture"
        | "credit"
        | "refund"
        | "sale"
        | "void";
      /** Transaction status. */
      status?:
        | "completed"
        | "conn-error"
        | "disputed"
        | "never-sent"
        | "offsite"
        | "partially-refunded"
        | "pending"
        | "refunded"
        | "sending"
        | "suspended"
        | "timeout"
        | "voided"
        | "waiting-approval"
        | "waiting-capture"
        | "waiting-gateway"
        | "waiting-refund";
      /** Transaction result. */
      result?: "abandoned" | "approved" | "canceled" | "declined" | "unknown";
      /** The transaction's amount. */
      amount?: number;
      currency?: components["schemas"]["CurrencyCode"];
      /** The amount actually purchased which may have differed from the originally requested amount in case of an adjustment. */
      purchaseAmount?: number;
      purchaseCurrency?: components["schemas"]["CurrencyCode"];
      /** The amount in the payment request. If adjusted, the purchase amount and billing amount may vary from it. */
      requestAmount?: number;
      requestCurrency?: components["schemas"]["CurrencyCode"];
      /** The parent's transaction ID. */
      parentTransactionId?: components["schemas"]["ResourceId"];
      /** The child transaction IDs. */
      childTransactions?: components["schemas"]["ResourceId"][];
      /** The invoice IDs related to transaction. */
      invoiceIds?: components["schemas"]["ResourceId"][];
      /** The orders IDs related to transaction's invoice(s). */
      subscriptionIds?: components["schemas"]["ResourceId"][];
      /** The plan IDs related to transaction's order(s). */
      planIds?: components["schemas"]["ResourceId"][];
      isRebill?: boolean;
      /** The transaction's rebill number. */
      rebillNumber?: number;
      paymentInstrument?: components["schemas"]["PaymentInstrumentReference"];
      /** Billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      has3ds?: boolean;
      "3ds"?: components["schemas"]["ThreeDSecureResult"];
      /** The URL to redirect the end-user when an offsite transaction is completed. Defaults to the website's configured URL. */
      redirectUrl?: string;
      /** The position in the sequence of retries. */
      retryNumber?: number;
      /** True if this transaction is retry. */
      isRetry?: boolean;
      /**
       * The billing descriptor that appears on the periodic billing statement. Commonly
       * 12 or fewer characters for a credit card statement.
       */
      billingDescriptor?: string;
      /** The payment description. */
      description?: string;
      /** The transaction's request ID.  This ID must be unique within a 24 hour period. Use this field to prevent duplicated transactions. */
      requestId?: string;
      /** True if transaction has amount adjustment. */
      hasAmountAdjustment?: boolean;
      /** Payment Gateway name, available only after the gateway is selected for the transaction. */
      gatewayName?: components["schemas"]["GatewayName"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** Transaction processed time. */
      processedTime?: components["schemas"]["ServerTimestamp"];
      /** Transaction created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Transaction updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    /** The acquirer name. */
    AcquirerName:
      | "Adyen"
      | "Alipay"
      | "AIB"
      | "Airpay"
      | "APAR"
      | "ApcoPay"
      | "AsiaPaymentGateway"
      | "AstroPay Card"
      | "Ipay Options"
      | "B+S"
      | "Bambora"
      | "BitPay"
      | "Bank of America"
      | "Bank of Moscow"
      | "Bank of Rebilly"
      | "Bank One"
      | "BMO Harris Bank"
      | "Borgun"
      | "BraintreePayments"
      | "Cardknox"
      | "CASHlib"
      | "CashToCode"
      | "Catalunya Caixa"
      | "CCAvenue"
      | "Chase"
      | "ChinaUnionPay"
      | "CIM"
      | "Citadel"
      | "Clearhaus"
      | "CODVoucher"
      | "CoinPayments"
      | "Conekta"
      | "Coppr"
      | "Credorax"
      | "Cryptonator"
      | "CyberSource"
      | "dLocal"
      | "Dragonphoenix"
      | "EBANX"
      | "ecoPayz"
      | "EcorePay"
      | "Elavon"
      | "EMS"
      | "EPG"
      | "Euteller"
      | "eZeeWallet"
      | "Fifth Third Bank"
      | "Finrax"
      | "First Data Buypass"
      | "First Data Nashville"
      | "First Data North"
      | "First Data Omaha"
      | "FinTecSystems"
      | "Flexepin"
      | "Forte"
      | "FundSend"
      | "Gigadat"
      | "Global East"
      | "Gooney"
      | "Gpaysafe"
      | "Heartland"
      | "HiPay"
      | "HSBC"
      | "iCanPay"
      | "ICEPAY"
      | "iCheque"
      | "Ilixium"
      | "Ingenico"
      | "INOVAPAY"
      | "Intuit"
      | "Jeton"
      | "Khelocard"
      | "Konnektive"
      | "LPG"
      | "Masapay"
      | "Merrick"
      | "Mission Valley Bank"
      | "Moneris"
      | "MuchBetter"
      | "MyFatoorah"
      | "NATWEST"
      | "Neosurf"
      | "Netbanking"
      | "Neteller"
      | "NinjaWallet"
      | "NMI"
      | "NuaPay"
      | "OchaPay"
      | "Onlineueberweisen"
      | "Other"
      | "Panamerican"
      | "Panda Bank"
      | "Paramount"
      | "ParamountEft"
      | "ParamountInterac"
      | "Pay4fun"
      | "PayCash"
      | "PaymenTechnologies"
      | "Paymero"
      | "Paynetics"
      | "PayPal"
      | "Payr"
      | "PayULatam"
      | "Payvision"
      | "Piastrix"
      | "Peoples Trust Company"
      | "Privatbank"
      | "Prosa"
      | "QQPay"
      | "RBC"
      | "RBS WorldPay"
      | "RealTime"
      | "Rotessa"
      | "SaltarPay"
      | "SecureTrading"
      | "Skrill"
      | "SmartInvoice"
      | "SMSVoucher"
      | "Sofort"
      | "SparkPay"
      | "State Bank of Mauritius"
      | "Stripe"
      | "TBI"
      | "TestProcessor"
      | "ToditoCash"
      | "Trustly"
      | "TrustPay"
      | "TSYS"
      | "TWINT"
      | "UPayCard"
      | "Vantiv"
      | "VCreditos"
      | "VoicePay"
      | "Wallet88"
      | "WeChat Pay"
      | "Wells Fargo"
      | "Wing Hang Bank"
      | "Wirecard"
      | "WorldPay"
      | "Zimpler"
      | "Zotapay";
    MoneyAmount: number;
    Money: {
      amount: components["schemas"]["MoneyAmount"];
      currency: components["schemas"]["CurrencyCode"];
    };
    /** The name of bump offer version, useful to make split tests. */
    PurchaseBumpSplitVersionName: string;
    /** Language (two letter ISO 639-1 code). */
    LanguageIsoCode: string;
    /** Bump offer status. */
    PurchaseBumpStatus: "presented" | "rejected" | "selected" | "unknown";
    PurchaseBumpOffer: {
      /** Offer ID. */
      offerId: string;
      /** Offer Type. */
      offerType: string;
      /** Bump amount. */
      bumpAmount: components["schemas"]["MoneyAmount"];
      /** Bump amount in USD. */
      bumpAmountInUsd?: components["schemas"]["MoneyAmount"];
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    PurchaseBumpOfferList: components["schemas"]["PurchaseBumpOffer"][];
    RiskMetadata: {
      /** The customer's IP. */
      ipAddress?: string;
      /** True if customer's ip address is related to proxy. */
      isProxy?: boolean;
      /** True if customer's ip address is related to VPN. */
      isVpn?: boolean;
      /** True if customer's ip address is related to TOR. */
      isTor?: boolean;
      /** True if customer's ip address is related to hosting. */
      isHosting?: boolean;
      /** VPN service name, if available. */
      vpnServiceName?: string;
      /** Internet Service Provider name, if available. */
      isp?: string;
      /** Country ISO Alpha-2 code for specified ipAddress. */
      country?: string;
      /** Region for specified ipAddress. */
      region?: string;
      /** City for specified ipAddress. */
      city?: string;
      /** Latitude for specified ipAddress. */
      latitude?: number;
      /** Longitude for specified ipAddress. */
      longitude?: number;
      /** Postal code for specified ipAddress. */
      postalCode?: string;
      /** Time zone for specified ipAddress. */
      timeZone?: string;
      /** Accuracy radius for specified ipAddress (kilometers). */
      accuracyRadius?: number;
      /** The fingerprint. */
      fingerprint?: string;
      /** HTTP headers. */
      httpHeaders?: { [key: string]: string };
      /** Distance between IP Address and Billing Address geolocation (kilometers). */
      distance?: number;
      /** True if the billing address country and geo-IP address are not the same. */
      hasMismatchedBillingAddressCountry?: boolean;
      /** True if the bank country and geo-IP address are not the same. */
      hasMismatchedBankCountry?: boolean;
      /** True if the browser time zone and IP address associated time zone are not the same. */
      hasMismatchedTimeZone?: boolean;
      /** Risk score computed per all the factors. */
      score?: number;
    };
    /**
     * The URL where a server-to-server POST notification will be sent.  It  will be sent when the
     * transaction's result is finalized after a timeout or an offsite interaction. Do not trust the
     * notification; follow with a GET request to confirm the result of the transaction. Please
     * respond with a 2xx HTTP status code, or we will reattempt the request again.
     * The 2 placeholders are available to use in this URI: `{id}` and `{result}`.
     */
    TransactionNotificationUrl: string;
    /** The calculation instruction of scheduled time. */
    CommonScheduleInstruction: {
      method:
        | "auto"
        | "intelligent"
        | "immediately"
        | "date-interval"
        | "day-of-month"
        | "day-of-week";
    };
    auto: components["schemas"]["CommonScheduleInstruction"];
    "date-interval": components["schemas"]["CommonScheduleInstruction"] &
      components["schemas"]["CustomEventScheduleInstruction"] &
      components["schemas"]["InvoiceRetryScheduleInstruction"] & {
        /** The number of the units. */
        duration: number;
        unit:
          | components["schemas"]["TimeUnit"]
          | components["schemas"]["TimePluralUnit"];
      };
    /** The calculation instruction of scheduled time. */
    CustomEventScheduleInstruction: {
      method: "date-interval" | "day-of-month" | "day-of-week";
    };
    "day-of-month": components["schemas"]["CommonScheduleInstruction"] &
      components["schemas"]["CustomEventScheduleInstruction"] &
      components["schemas"]["ServicePeriodAnchorInstruction"] &
      components["schemas"]["InvoiceRetryScheduleInstruction"] & {
        /**
         * The day of the month when event will be scheduled.
         * Be aware if the month has less days,
         * the last day of the month will be selected.
         */
        day: number;
        time?: components["schemas"]["TimeIso8601Extended"];
      };
    /**
     * Instruction for calculating the service period anchor.
     * This is used in conjunction with the **subscription start** to calculate the time the service period starts and ends.
     */
    ServicePeriodAnchorInstruction: {
      method: "immediately" | "day-of-month" | "day-of-week";
    };
    "day-of-week": components["schemas"]["CommonScheduleInstruction"] &
      components["schemas"]["CustomEventScheduleInstruction"] &
      components["schemas"]["ServicePeriodAnchorInstruction"] &
      components["schemas"]["InvoiceRetryScheduleInstruction"] & {
        day: components["schemas"]["DayOfWeekLong"];
        week?: "next" | "first-in-month" | "last-in-month";
        time?: components["schemas"]["TimeIso8601Extended"];
      };
    /** The calculation instruction of scheduled time. */
    InvoiceRetryScheduleInstruction: {
      method:
        | "intelligent"
        | "immediately"
        | "date-interval"
        | "day-of-month"
        | "day-of-week";
    };
    immediately: components["schemas"]["CommonScheduleInstruction"] &
      components["schemas"]["ServicePeriodAnchorInstruction"] &
      components["schemas"]["InvoiceRetryScheduleInstruction"];
    intelligent: components["schemas"]["CommonScheduleInstruction"] &
      components["schemas"]["CustomEventScheduleInstruction"] &
      components["schemas"]["InvoiceRetryScheduleInstruction"] & {
        /** The number of the units. */
        duration: number;
        unit:
          | components["schemas"]["TimeUnit"]
          | components["schemas"]["TimePluralUnit"];
      };
    DayOfWeekLong:
      | "Sunday"
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday";
    /** Extended ISO-8601 format of time. */
    TimeIso8601Extended: string;
    AmountAdjustment: {
      method: "none" | "partial" | "discount";
    };
    discount: components["schemas"]["AmountAdjustment"] & {
      /** The payment amount discount. */
      value: number;
      /** The payment amount discount type. */
      type: "percent" | "fixed";
    };
    partial: components["schemas"]["AmountAdjustment"] & {
      /** The payment amount. */
      value: number;
      /** The payment amount type. */
      type: "percent" | "fixed";
    };
    PaymentRetry: {
      attempts: {
        scheduleInstruction: components["schemas"]["CommonScheduleInstruction"];
        paymentInstruction: components["schemas"]["AmountAdjustment"];
      }[];
      /** The policy on the attempt finishes. */
      afterAttemptPolicy: "none" | "change-subscription-renewal-time";
      /** The policy on the retry ends. */
      afterRetryEndPolicy: "none" | "cancel-subscription";
    };
    GatewayAccountLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "gatewayAccount";
    };
    PaymentCardLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "paymentCard";
    };
    ParentTransactionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "parentTransaction";
    };
    RetriedTransactionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "retriedTransaction";
    };
    ApprovalUrlLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "approvalUrl";
    };
    CancelUrlLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "cancelUrl";
    };
    RefundUrlLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "refundUrl";
    };
    DisputeLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "dispute";
    };
    InvoicesLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "invoices";
    };
    Transaction: components["schemas"]["CommonTransaction"] & {
      /** The transaction's Gateway Account ID. */
      gatewayAccountId?: components["schemas"]["ResourceId"];
      /** The gateway's transaction ID. */
      gatewayTransactionId?: components["schemas"]["ResourceId"];
      /** The related gateway information. */
      gateway?: {
        /** The gateway's response. */
        response?: {
          /** The gateway's response code. */
          code?: string;
          /** The gateway's response message. */
          message?: string;
          /** The gateway's response type. */
          type?: string;
          /** The raw, unmapped gateway's response code. */
          originalCode?: string;
          /** The raw, unmapped gateway's response message. */
          originalMessage?: string;
        };
        /** The AVS gateway's response. */
        avsResponse?: {
          /** The response code. */
          code?: string;
          /** The response message. */
          message?: string;
          /** The raw response code. */
          originalCode?: string;
          /** The raw response message. */
          originalMessage?: string;
        };
        /** The CVV gateway's response. */
        cvvResponse?: {
          /** The response code. */
          code?: string;
          /** The response message. */
          message?: string;
          /** The raw response code. */
          originalCode?: string;
          /** The raw response message. */
          originalMessage?: string;
        };
      };
      /** Acquirer name, available only when transaction use gateway, else null. */
      acquirerName?: components["schemas"]["AcquirerName"];
      /** Payment Method. Use `paymentInstrument.method` instead. */
      method?: components["schemas"]["PaymentMethod"];
      /** The number of transactions by the same customer in the past 24 hours. */
      velocity?: number;
      /**
       * The number of times the transaction data has been modified.
       * The revision is useful when analyzing webhook data to determine if the change takes precedence over the current representation.
       */
      revision?: number;
      /** Transaction reference data. */
      referenceData?: { [key: string]: string } | null;
      /** Payment Card BIN. */
      bin?: string;
      paymentInstrument?: components["schemas"]["PaymentInstrument"];
      /** True if transaction has Dynamic Currency Conversion applied. */
      hasDcc?: boolean;
      /** Dynamic Currency Conversion detailed information. Null if hasDcc is false. */
      dcc?: {
        /** Initial amount and currency to convert from. */
        base?: components["schemas"]["Money"];
        /** Suggested amount and currency to convert to. */
        quote?: components["schemas"]["Money"];
        /** The amount of markup translated to USD. */
        usdMarkup?: components["schemas"]["MoneyAmount"];
        /** Dynamic Currency Conversion outcome. */
        outcome?: "rejected" | "selected" | "unknown";
      };
      /** True if transaction has a Bump offer. */
      hasBumpOffer?: boolean;
      /** Bump offer information. Null if hasBumpOffer is false. */
      bumpOffer?: {
        /** Initial amount and currency. */
        order?: components["schemas"]["Money"];
        /** The name of the version that was picked (useful for measuring split tests). */
        version?: components["schemas"]["PurchaseBumpSplitVersionName"];
        /** The language of the bump offer that was displayed to user (useful for finding any translation problems). */
        language?: components["schemas"]["LanguageIsoCode"];
        outcome?: components["schemas"]["PurchaseBumpStatus"];
        /** Offers presented to a customer. */
        presentedOffers?: components["schemas"]["PurchaseBumpOfferList"];
        /** Offer selected by a customer. Null if bump offer outcome is not `selected`. */
        selectedOffer?: components["schemas"]["PurchaseBumpOffer"];
      };
      /** The transaction's risk score. */
      riskScore?: number;
      /** Risk metadata. */
      riskMetadata?: components["schemas"]["RiskMetadata"];
      notificationUrl?: components["schemas"]["TransactionNotificationUrl"];
      retryInstruction?: components["schemas"]["PaymentRetry"];
      /** The retried transaction ID. */
      retriedTransactionId?: components["schemas"]["ResourceId"];
      /** Retries sequence result. */
      retriesResult?: "approved" | "canceled" | "declined" | "scheduled";
      /** True if transaction is disputed. */
      isDisputed?: boolean;
      /** True if the transaction has been verified with gateway batch data. */
      isReconciled?: boolean;
      /** True if the transaction was processed outside of Rebilly. */
      isProcessedOutside?: boolean;
      /** True if the transaction was initiated by the merchant. */
      isMerchantInitiated?: boolean;
      /** True if the transaction has been updated due to a discrepancy with its. source of truth. */
      hadDiscrepancy?: boolean;
      /** The transaction's order ID.  This ID must be unique within a 24 hour period. This field was renamed to the `requestId`. */
      orderId?: string;
      /** The acquirer reference number. */
      arn?: string;
      /** The time the transaction is scheduled for collection. */
      scheduledTime?: string;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["WebsiteLink"]> &
        Partial<components["schemas"]["CustomerLink"]> &
        Partial<components["schemas"]["GatewayAccountLink"]> &
        Partial<components["schemas"]["PaymentCardLink"]> &
        Partial<components["schemas"]["ParentTransactionLink"]> &
        Partial<components["schemas"]["RetriedTransactionLink"]> &
        Partial<components["schemas"]["LeadSourceLink"]> &
        Partial<components["schemas"]["ApprovalUrlLink"]> &
        Partial<components["schemas"]["CancelUrlLink"]> &
        Partial<components["schemas"]["RefundUrlLink"]> &
        Partial<components["schemas"]["DisputeLink"]> &
        Partial<components["schemas"]["InvoicesLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["ParentTransactionEmbed"]> &
        Partial<components["schemas"]["RetriedTransactionEmbed"]> &
        Partial<components["schemas"]["GatewayAccountEmbed"]> &
        Partial<components["schemas"]["CustomerEmbed"]> &
        Partial<components["schemas"]["LeadSourceEmbed"]> &
        Partial<components["schemas"]["WebsiteEmbed"]> &
        Partial<components["schemas"]["PaymentCardEmbed"]> &
        Partial<components["schemas"]["BankAccountEmbed"]> &
        Partial<components["schemas"]["InvoicesEmbed"]>)[];
    };
    /** Retried Transaction object. */
    ParentTransactionEmbed: {
      parentTransaction?: components["schemas"]["Transaction"];
    };
    /** Parent Transaction object. */
    RetriedTransactionEmbed: {
      retriedTransaction?: components["schemas"]["Transaction"];
    };
    GatewayAccount: {
      /** The gateway identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The gateway account's status. */
      status?: "active" | "inactive" | "pending" | "closed";
      gatewayName: components["schemas"]["GatewayName"];
      acquirerName: components["schemas"]["AcquirerName"];
      /** The gateway account's merchant category code. */
      merchantCategoryCode: number;
      /** Dynamic currency conversion markup in basis points. */
      dccMarkup?: number;
      /**
       * Force dynamic currency conversion to the specified currency on each sale.
       * Leave it empty to disable force DCC.
       */
      dccForceCurrency?: string;
      /** The gateway account's descriptor. */
      descriptor?: string;
      /** The gateway account's city field (also known as line 2 descriptor). */
      cityField?: string;
      /** Organization ID. */
      organizationId: components["schemas"]["ResourceId"];
      /** Excluded Dynamic Currency Conversion Quote Currencies. */
      excludedDccQuoteCurrencies?: string[];
      /** Monthly Limit. */
      monthlyLimit?: number;
      /** The time window (in seconds) allotted for approving an offsite transaction before it is automatically `abandoned`. */
      approvalWindowTtl?: number;
      /** If a transaction is not reconciled within the `reconciliationWindowTtl` time, then the transaction is marked as `abandoned`. */
      reconciliationWindowEnabled?: boolean;
      /** The time window (in seconds) allotted for a reconciliation to occur. If it is not reconciled in that time, then the transaction is marked as `abandoned`. */
      reconciliationWindowTtl?: number;
      /** True, if Gateway Account allows 3DSecure. */
      threeDSecure?: boolean;
      /** True, if Gateway Account allows dynamic descriptor. */
      dynamicDescriptor?: boolean;
      /** Accepted currencies (array of the currency three letter code). */
      acceptedCurrencies: string[];
      method?: components["schemas"]["PaymentMethod"];
      /** Accepted payment card brands. */
      paymentCardSchemes?: components["schemas"]["PaymentCardBrand"][];
      digitalWallets?: components["schemas"]["DigitalWallets"];
      /** True if gateway is currently in downtime period. */
      isDown?: boolean;
      /**
       * The additional filters are used to determine whether the gateway account can be selected for the transaction to be processed.
       * For example, the filter may put a maximum amount value. If the transaction is above that amount, this gateway account wouldn't be used.
       * This follows our standard filter format.
       */
      additionalFilters?: string;
      /** Gateway Account request timeout in seconds. */
      timeout?: number | null;
      /** Gateway Account token. */
      token?: string;
      /** Gateway Account created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Gateway Account updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["OnBoardingUrlLink"]> &
        Partial<components["schemas"]["DynamicIpnLink"]> &
        Partial<components["schemas"]["StaticIpnLink"]>)[];
    };
    /** A1Gateway 3DS Servers. */
    A1Gateway3dsServers: {
      name: "Paay3dsServer" | "Other";
    };
    /** Other. */
    Other: components["schemas"]["A1Gateway3dsServers"] &
      components["schemas"]["eMerchantPay3dsServers"] &
      components["schemas"]["GET3dsServers"] &
      components["schemas"]["NMI3dsServers"] &
      components["schemas"]["Payvision3dsServers"] &
      components["schemas"]["VantivLitle3dsServers"] &
      components["schemas"]["Walpay3dsServers"] &
      components["schemas"]["Worldpay3dsServers"];
    /** eMerchantPay 3DS Servers. */
    eMerchantPay3dsServers: {
      name:
        | "eMerchantPay3dsServer"
        | "ThreeDSecureIO3dsServer"
        | "Paay3dsServer"
        | "Other";
    };
    /** Paay. */
    Paay3dsServer: components["schemas"]["A1Gateway3dsServers"] &
      components["schemas"]["eMerchantPay3dsServers"] &
      components["schemas"]["GET3dsServers"] &
      components["schemas"]["NMI3dsServers"] &
      components["schemas"]["Payvision3dsServers"] &
      components["schemas"]["VantivLitle3dsServers"] &
      components["schemas"]["Walpay3dsServers"] &
      components["schemas"]["Worldpay3dsServers"] & {
        /** Paay ApiKey. */
        apiKey: string;
        /** Paay secret. */
        secret: string;
        /** Paay 3DS Server url. */
        mpiUrl: string;
        /** Paay sandbox 3DS Server url. */
        sandboxMpiUrl: string;
      };
    /** The Merchant plug-in Name. */
    ThreeDSecureServerName:
      | "Payvision3dsServer"
      | "Wirecard3dsServer"
      | "Ilixium3dsServer"
      | "DataCash3dsServer"
      | "Paysafe3dsServer"
      | "Ingenico3dsServer"
      | "CardinalCommerce3dsServer"
      | "Paay3dsServer"
      | "Panamerican3dsServer"
      | "eMerchantPay3dsServer"
      | "SecureTrading3dsServer"
      | "Clearhaus3dsServer"
      | "Other"
      | "ThreeDSecureIO3dsServer"
      | "WorldlineAtosFrankfurt3dsServer"
      | "Piastrix3dsServer"
      | "NGenius3dsServer"
      | "Stripe3dsServer";
    /** GET 3DS Servers. */
    GET3dsServers: {
      name: "Paay3dsServer" | "Other";
    };
    /** NMI 3DS Servers. */
    NMI3dsServers: {
      name: "Paay3dsServer" | "Other";
    };
    /** Payvision 3DS Servers. */
    Payvision3dsServers: {
      name:
        | "Payvision3dsServer"
        | "Payvision3ds2Server"
        | "CardinalCommerce3dsServer"
        | "Paay3dsServer"
        | "ThreeDSecureIO3dsServer"
        | "Other";
    };
    /** CardinalCommerce 3DS Server Credentials. */
    CardinalCommerce3dsServer: components["schemas"]["Payvision3dsServers"] & {
      /** Cardinal MerchantId. */
      merchantId: string;
      /** Cardinal ProcessorId. */
      processorId: string;
      /** Cardinal TransactionPwd. */
      transactionPwd: string;
    };
    /** Payvision Integrated. */
    Payvision3dsServer: components["schemas"]["Payvision3dsServers"];
    /** ThreeDSecureIO3dsServer. */
    ThreeDSecureIO3dsServer: components["schemas"]["WorldlineAtosFrankfurt3dsServers"] &
      components["schemas"]["TestProcessor3dsServers"] &
      components["schemas"]["EMS3dsServers"] & {
        /** Merchant Id. */
        merchantId: string;
        /** Merchant Name. */
        merchantName: string;
        /** Visa Acquirer BIN. */
        merchantAcquirerBinVisa: string;
        /** Mastercard Acquirer BIN. */
        merchantAcquirerBinMastercard: string;
        /** Merchant Country ISO Alpha-2 Code. */
        merchantCountry: string;
        /** Merchant URL. */
        merchantUrl: string;
        /**
         * Value determines if requests can use version 1 of 3DS.
         * In case both v1 and v2 are enabled it will prefer v2.
         * If v2 is not supported for the issuer, it will coalesce to v1.
         */
        v1?: boolean;
        /**
         * Value determines if requests will attempt version 2 of 3DS.
         * In case both v1 and v2 are enabled it will prefer v2.
         * If v2 is not supported for the issuer, it will coalesce to v1.
         */
        v2?: boolean;
        /**
         * 01 - Goods/Service Purchase
         * 03 - Check Acceptance
         * 10 - Account Funding
         * 11 - Quasi-Cash Transaction
         * 28 - Prepaid Activation and Load
         *
         * Identifies the type of transaction being authenticated.
         */
        transactionType?: "01" | "03" | "10" | "11" | "28";
      };
    /** WorldlineAtosFrankfurt 3DS Servers. */
    WorldlineAtosFrankfurt3dsServers: {
      name: "ThreeDSecureIO3dsServer";
    };
    /** TestProcessor3dsServers 3DS Servers. */
    TestProcessor3dsServers: {
      name: "TestSandbox3dsServer" | "ThreeDSecureIO3dsServer";
    };
    /** TestProcessor Integrated. */
    TestProcessor3dsServer: components["schemas"]["TestProcessor3dsServers"];
    /** EMS 3DS Servers. */
    EMS3dsServers: {
      name: "ThreeDSecureIO3dsServer";
    };
    /** VantivLitle 3DS Servers. */
    VantivLitle3dsServers: {
      name: "Paay3dsServer" | "Other";
    };
    /** Walpay 3DS Servers. */
    Walpay3dsServers: {
      name: "Paay3dsServer" | "Other";
    };
    /** Worldpay 3DS Servers. */
    Worldpay3dsServers: {
      name: "Paay3dsServer" | "ThreeDSecureIO3dsServer" | "Other";
    };
    /** eMerchantPay 3DS Server. */
    eMerchantPay3dsServer: components["schemas"]["eMerchantPay3dsServers"];
    /** A1Gateway config. */
    A1Gateway: components["schemas"]["GatewayAccount"] & {
      /** A1Gateway credentials object. */
      credentials: {
        /** A1Gateway account ID. */
        accountId: string;
        /** A1Gateway password. */
        password: string;
      };
      threeDSecureServer?: components["schemas"]["A1Gateway3dsServers"];
    };
    /** Adyen config. */
    Adyen: components["schemas"]["GatewayAccount"] & {
      /** Adyen credentials object. */
      credentials: {
        /** Adyen merchant account. */
        merchantAccount: string;
        /** Adyen api key. */
        apiKey: string;
      };
      /** Adyen settings object. */
      settings: {
        /** Adyen post URL. */
        url: string;
      };
    };
    /** Airpay config. */
    Airpay: components["schemas"]["GatewayAccount"] & {
      /** Airpay credentials object. */
      credentials: {
        /** Airpay username. */
        username: string;
        /** Airpay merchant ID. */
        merchantId: string;
        /** Airpay password. */
        password: string;
        /** Airpay api key. */
        apiKey: string;
      };
    };
    /** AmexVPC config. */
    AmexVPC: components["schemas"]["GatewayAccount"] & {
      /** AmexVPC credentials object. */
      credentials: {
        /** Merchant ID. */
        merchantId: string;
        /** Access Code. */
        accessCode: string;
        /** User (used for refund, void and capture). */
        user: string;
        /** Password (used for refund, void and capture). */
        password: string;
      };
      /** AmexVPC settings object. */
      settings: {
        /** Virtual Payment Client URL. */
        url: string;
      };
    };
    /** APAR config. */
    APAR: components["schemas"]["GatewayAccount"] & {
      /** APAR credentials object. */
      credentials: {
        merchantId: string;
        merchantToken: string;
      };
    };
    /** ApcoPay config. */
    ApcoPay: components["schemas"]["GatewayAccount"] & {
      /** ApcoPay credentials object. */
      credentials: {
        /** ApcoPay profile ID. */
        profileID: string;
        /** ApcoPay secret word. */
        secretWord: string;
        /** ApcoPay merchant ID. */
        MerchantID: string;
        /** ApcoPay merchant password. */
        MerchantPassword: string;
      };
      settings?: {
        /** ApcoPay's method. */
        method:
          | "AFTERPAY"
          | "IDEAL"
          | "CREDITCLICK"
          | "BANCONTACT"
          | "ONLINEUBERWEISEN";
      };
    };
    /** AsiaPaymentGateway config. */
    AsiaPaymentGateway: components["schemas"]["GatewayAccount"] & {
      /** AsiaPaymentGateway credentials object. */
      credentials: {
        /** AsiaPaymentGateway merchant number. */
        merchantNumber: string;
        /** AsiaPaymentGateway secret key for hash. */
        secretKey: string;
      };
    };
    /** AstroPay Card config. */
    AstroPayCard: components["schemas"]["GatewayAccount"] & {
      /** AstroPay Card credentials object. */
      credentials: {
        /** AstroPay Card login. */
        x_login: string;
        /** AstroPay Card transaction key. */
        x_tran_key: string;
        /** AstroPay Card secret key. */
        secret_key: string;
        /** One Touch Astropay API key. */
        api_key?: string;
      };
      /** AstroPay Card settings object. */
      settings?: {
        /** Use One Touch Astropay API. */
        oneTouchApi?: boolean;
      };
    };
    /** AuthorizeNet Gateway config. */
    AuthorizeNet: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** AuthorizeNet Gateway api login ID. */
        apiLoginId: string;
        /** AuthorizeNet Gateway Transaction Key. */
        transactionKey: string;
      };
    };
    /** Bambora Gateway config. */
    Bambora: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Bambora Gateway merchant ID. */
        merchantId: string;
        /** Bambora Gateway API Passcode. */
        apiPasscode: string;
      };
    };
    /** BitPay Gateway config. */
    BitPay: components["schemas"]["GatewayAccount"] & {
      /** BitPay credentials object. */
      credentials: {
        /** BitPay merchant API token. */
        token: string;
      };
    };
    /** BlueSnap config. */
    BlueSnap: components["schemas"]["GatewayAccount"] & {
      /** BlueSnap credentials object. */
      credentials: {
        /** BlueSnap merchant's api username. */
        username: string;
        /** BlueSnap merchant's api password. */
        password: string;
      };
    };
    /** BraintreePayments Gateway config. */
    BraintreePayments: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** BraintreePayments Public Key. */
        publicKey: string;
        /** BraintreePayments Private Key. */
        privateKey: string;
        /** BraintreePayments merchant ID. */
        merchantId: string;
        /** BraintreePayments merchant account ID. */
        merchantAccountId: string;
      };
    };
    /** CASHlib config. */
    CASHlib: components["schemas"]["GatewayAccount"] & {
      /** CASHlib credentials object. */
      credentials: {
        /** CASHlib API Key. */
        apiKey: string;
        /** CASHlib merchant id. */
        merchantId: string;
      };
    };
    /** COD Voucher config. */
    CODVoucher: components["schemas"]["GatewayAccount"] & {
      /** COD Voucher credentials object. */
      credentials: {
        /** COD Voucher API key. */
        apiKey: string;
        /** COD Voucher API secret. */
        apiSecret: string;
      };
    };
    /** CoinPayments config. */
    CoinPayments: components["schemas"]["GatewayAccount"] & {
      /** CoinPayments credentials object. */
      credentials: {
        publicKey: string;
        privateKey: string;
        ipnSecret: string;
      };
    };
    /** Cardknox Gateway config. */
    Cardknox: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Cardknox xKey. */
        xKey: string;
      };
    };
    /** CashToCode config. */
    CashToCode: components["schemas"]["GatewayAccount"] & {
      /** CashToCode credentials object. */
      credentials: {
        /** CashToCode credentials Username. */
        cashToCodeUsername: string;
        /** CashToCode credentials password. */
        cashToCodePassword: string;
        /** Merchant credentials Username. */
        merchantUsername: string;
        /** Merchant credentials password. */
        merchantPassword: string;
      };
      settings?: {
        /** Skip amount selection screen. */
        skipAmountSelection?: boolean;
        /** Amounts for which to allow transactions. */
        amounts?: number[];
      };
    };
    /** Cashflows Gateway config. */
    Cashflows: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Cashflows Gateway auth ID. */
        authId: string;
        /** Cashflows Gateway auth password. */
        authPassword: string;
      };
    };
    /** CauriPayment config. */
    CauriPayment: components["schemas"]["GatewayAccount"] & {
      /** CauriPayment credentials object. */
      credentials: {
        /** CauriPayment merchant's public key. */
        publicKey: string;
        /** CauriPayment merchant's private key. */
        privateKey: string;
      };
    };
    /** Cayan Gateway config. */
    Cayan: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Cayan Gateway merchant site ID. */
        merchantSiteId: string;
        /** Cayan Gateway merchant name. */
        merchantName: string;
        /** Cayan Gateway merchant key. */
        merchantKey: string;
      };
    };
    /** CCAvenue config. */
    CCAvenue: components["schemas"]["GatewayAccount"] & {
      /** CCAvenue credentials object. */
      credentials: {
        /** CCAvenue merchant id. */
        merchantId: string;
        /** CCAvenue access code. */
        accessCode: string;
        /** CCAvenue working key. */
        workingKey: string;
      };
    };
    /** Chase Gateway config. */
    Chase: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Chase Gateway Net Connect username. */
        username: string;
        /** Chase Gateway Net Connect password. */
        password: string;
        /** Chase Gateway CO Number used for delimited file reports. */
        coNumber: string;
        /** Chase Gateway division ID. */
        divisionId: string;
        /** Support for Partial Auths. */
        partialAuth: boolean;
      };
    };
    /** Citadel config. */
    Citadel: components["schemas"]["GatewayAccount"] & {
      /** Citadel credentials object. */
      credentials: {
        /** Store name. */
        storeName: string;
        /** Store ID. */
        storeId: string;
        /** Username. */
        username: string;
        /** Password. */
        password: string;
      };
    };
    /** Clearhaus 3DS Servers. */
    Clearhaus3dsServers: {
      name: "Clearhaus3dsServers";
    };
    /** Clearhaus 3DS Server Credentials. */
    Clearhaus3dsServer: components["schemas"]["Clearhaus3dsServers"] & {
      /** Merchant account ID or Card Acceptor ID provided by the acquiring bank. */
      merchantId: string;
      /** Acquiring institution identification code. */
      acquirerBin: string;
      /** 3DS Server Api key. */
      apiKey: string;
    };
    /** Clearhaus Gateway config. */
    Clearhaus: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Clearhaus api key. */
        apiKey: string;
      };
      threeDSecureServer?: components["schemas"]["Clearhaus3dsServers"];
    };
    /** Conekta config. */
    Conekta: components["schemas"]["GatewayAccount"] & {
      /** Conekta credentials object. */
      credentials: {
        /** Conekta private API key. */
        apiKey: string;
      };
    };
    /** Coppr config. */
    Coppr: components["schemas"]["GatewayAccount"] & {
      /** Coppr credentials object. */
      credentials: {
        /** Coppr Organization's ID. */
        organizationId: string;
        /** Coppr api key. */
        apiKey: string;
      };
      /** Coppr settings object. */
      settings?: {
        /** Rebilly publishable api key. If provided a payment token will be created for each transaction. */
        rebillyPublishableKey?: string;
      };
    };
    /** Credorax Gateway config. */
    Credorax: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Credorax Gateway merchant ID. */
        merchantId: string;
        /** Credorax Gateway md5 signature. */
        merchantMd5Signature: string;
      };
    };
    /** Cryptonator config. */
    Cryptonator: components["schemas"]["GatewayAccount"] & {
      /** Cryptonator credentials object. */
      credentials: {
        /** Cryptonator merchant ID. */
        merchant_id: string;
        /** Cryptonator secret. */
        secret: string;
      };
    };
    /** CyberSource config. */
    CyberSource: components["schemas"]["GatewayAccount"] & {
      /** CyberSource credentials object. */
      credentials: {
        /** CyberSource access key. */
        accessKey: string;
        /** CyberSource profile ID. */
        profileId: string;
        /** CyberSource secret key. */
        secretKey: string;
      };
    };
    /** DataCash 3DS Servers. */
    DataCash3dsServers: {
      name: "DataCash3dsServer";
    };
    /** DataCash Integrated. */
    DataCash3dsServer: components["schemas"]["DataCash3dsServers"];
    /** DataCash Gateway config. */
    DataCash: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** DataCash Gateway client. */
        client: string;
        /** DataCash Gateway password. */
        password: string;
        /** DataCash report group. */
        reportGroup?: string;
        /** DataCash report user. */
        reportUser?: string;
        /** DataCash report password. */
        reportPassword?: string;
        /** DataCash Gateway client for Visa payouts (OCT). */
        visaPayoutsClient?: string;
        /** DataCash Gateway password for Visa payouts (OCT). */
        visaPayoutsPassword?: string;
        /** DataCash Gateway client for MasterCard payouts (OCT). */
        masterCardPayoutsClient?: string;
        /** DataCash Gateway password for MasterCard payouts (OCT). */
        masterCardPayoutsPassword?: string;
      };
      /** Datacash settings object. */
      settings?: {
        /** Policy. */
        policy?: number;
        /** Auto Capture delay (in hours). */
        delay?: number;
      };
      threeDSecureServer?: components["schemas"]["DataCash3dsServers"];
    };
    /** Dengi Gateway config. */
    Dengi: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Dengi Gateway project ID. */
        projectId: string;
        /** Dengi Gateway public key. */
        publicKey: string;
        /** Dengi Gateway refund key. */
        refundKey: string;
      };
    };
    /** dLocal config. */
    dLocal: components["schemas"]["GatewayAccount"] & {
      credentials: {
        xLogin: string;
        xTransKey: string;
        secretKey: string;
      };
    };
    /** Dragonphoenix config. */
    Dragonphoenix: components["schemas"]["GatewayAccount"] & {
      /** Dragonphoenix credentials object. */
      credentials: {
        /** Dragonphoenix site ID. */
        sid: string;
        /** Dragonphoenix rcode. */
        rcode: string;
      };
    };
    Directa24Banks:
      | "AA"
      | "AL"
      | "AZ"
      | "B"
      | "BB"
      | "BC"
      | "BE"
      | "BL"
      | "BM"
      | "BN"
      | "BP"
      | "BQ"
      | "BU"
      | "BV"
      | "BW"
      | "BX"
      | "BZ"
      | "CA"
      | "CE"
      | "CI"
      | "CU"
      | "EF"
      | "EN"
      | "EY"
      | "FA"
      | "FB"
      | "FC"
      | "GC"
      | "GG"
      | "HC"
      | "I"
      | "IA"
      | "IB"
      | "JM"
      | "LC"
      | "LE"
      | "LL"
      | "MC"
      | "MD"
      | "MP"
      | "MT"
      | "NB"
      | "OM"
      | "OX"
      | "PC"
      | "PH"
      | "PL"
      | "SB"
      | "SC"
      | "SE"
      | "SF"
      | "SM"
      | "SS"
      | "ST"
      | "SU"
      | "TC"
      | "TG"
      | "TY"
      | "UB"
      | "UI"
      | "UL"
      | "US"
      | "VD"
      | "VI"
      | "WA"
      | "WP"
      | "WU";
    /** Directa24 config. */
    Directa24: components["schemas"]["GatewayAccount"] & {
      /** Directa24 credentials object. */
      credentials: {
        /** Directa24 login. */
        x_login: string;
        /** Directa24 transaction key. */
        x_tran_key: string;
        /** Directa24 secret key. */
        secret_key: string;
        /** Directa24 web pay status login. */
        web_pay_login: string;
        /** Directa24 web pay status password. */
        web_pay_tran_key: string;
      };
      /** Directa24 settings object. */
      settings?: {
        /** List of banks which will be shown to customers. */
        banks?: components["schemas"]["Directa24Banks"][];
        /** Skip step for user to enter their personal information. */
        skipStep?: boolean;
      };
    };
    /** EBANX config. */
    EBANX: components["schemas"]["GatewayAccount"] & {
      /** EBANX credentials object. */
      credentials: {
        /** EBANX integration key. */
        integrationKey: string;
      };
    };
    /** EPG config. */
    EPG: components["schemas"]["GatewayAccount"] & {
      /** EPG credentials object. */
      credentials: {
        /** Merchant ID. */
        merchantId: string;
        /** Product ID. */
        productId: string;
        /** Merchant password. */
        merchantPassword: string;
        /** Merchant key. */
        merchantKey: string;
      };
    };
    /** EPro config. */
    EPro: components["schemas"]["GatewayAccount"] & {
      /** EPro credentials object. */
      credentials: {
        /** EPro API secret key. */
        apiSecretKey: string;
      };
    };
    /** EcorePay Gateway config. */
    EcorePay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** EcorePay Account ID. */
        accountId: string;
        /** EcorePay Account Auth. */
        accountAuth: string;
      };
    };
    /** Elavon config. */
    Elavon: components["schemas"]["GatewayAccount"] & {
      /** Elavon credentials object. */
      credentials: {
        /** Elavon merchant ID. */
        ssl_merchant_id: string;
        /** Elavon user ID. */
        ssl_user_id: string;
        /** Elavon pin. */
        ssl_pin: string;
      };
    };
    /** EMS e-Commerce (XML) API config. */
    EMS: components["schemas"]["GatewayAccount"] & {
      /** EMS settings object. */
      settings?: {
        /** Automatic capture delay in hours. */
        delay?: number;
      };
      /** EMS credentials object. */
      credentials: {
        /** EMS store id. */
        storeId: string;
        /** EMS account id. */
        userId: string;
        /** EMS password. */
        password: string;
        /** Private Key. */
        privateKey: string;
        /** Private key password. */
        privateKeyPassword: string;
        /** Client Certificate. */
        clientCertificate: string;
        /** Client Certificate password. */
        clientCertificatePassword: string;
        /** Server Certificate. */
        serverCertificate: string;
      };
      threeDSecureServer?: components["schemas"]["EMS3dsServers"];
    };
    /** Euteller config. */
    Euteller: components["schemas"]["GatewayAccount"] & {
      /** Euteller credentials object. */
      credentials: {
        username: string;
        password: string;
      };
    };
    /** eZeeWallet config. */
    eZeeWallet: components["schemas"]["GatewayAccount"] & {
      /** eZeeWallet credentials object. */
      credentials: {
        /** eZeeWallet API username. */
        apiUsername: string;
        /** eZeeWallet API password. */
        apiPassword: string;
      };
    };
    /** FinTecSystems config. */
    FinTecSystems: components["schemas"]["GatewayAccount"] & {
      /** FinTecSystems credentials object. */
      credentials: {
        /** FinTecSystems api key. */
        apiKey: string;
      };
      /** FinTecSystems settings object. */
      settings: {
        /** IBAN of the recipient account. */
        recipientIBAN: string;
        /** BIC of the recipient account. */
        recipientBIC: string;
        /** Two letter country code. */
        recipientCountry: "AT" | "CH" | "DE";
        /** Account holder of the recipient account. */
        recipientHolder: string;
      };
    };
    /** Finrax config. */
    Finrax: components["schemas"]["GatewayAccount"] & {
      /** Finrax credentials object. */
      credentials: {
        /** Finrax Business Id. */
        businessId: string;
        /** Finrax API Key. */
        apiKey: string;
        /** Finrax API Secret. */
        apiSecret: string;
      };
      /** Finrax settings object. */
      settings?: {
        /** Tolerance percentage for settled amount. */
        tolerancePercentage?: string;
      };
    };
    /** Flexepin Gateway config. */
    Flexepin: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Flexepin API Key. */
        apiKey: string;
        /** Flexepin API Secret. */
        apiSecret: string;
      };
    };
    /** Forte Gateway config. */
    Forte: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Forte Gateway account ID. */
        accountId: string;
        /** Forte Gateway location ID. */
        locationId: string;
        /** Forte Gateway api access ID. */
        apiAccessId: string;
        /** Forte Gateway api secret key. */
        apiSecretKey: string;
      };
    };
    /** FundSend Gateway config. */
    FundSend: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** FundSend Gateway client ID. */
        clientId: string;
        /** FundSend Gateway secret word. */
        secretWord: string;
      };
    };
    /** GET Gateway config. */
    GET: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** GET Gateway account ID. */
        accountId: string;
      };
      threeDSecureServer?: components["schemas"]["GET3dsServers"];
    };
    /** Gigadat config. */
    Gigadat: components["schemas"]["GatewayAccount"] & {
      /** Gigadat credentials object. */
      credentials: {
        /** Gigadat campaign ID. */
        campaignId: string;
        /** Gigadat access token. */
        accessToken: string;
        /** Gigadat security token. */
        securityToken: string;
      };
      settings?: {
        /** True if gateway account is in sandbox mode. */
        sandbox: boolean;
      };
    };
    /** GlobalOne Gateway config. */
    GlobalOne: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** GlobalOne Gateway terminal ID. */
        terminalId: string;
        /** GlobalOne Gateway shared secret. */
        sharedSecret: string;
      };
    };
    /** Gooney config. */
    Gooney: components["schemas"]["GatewayAccount"] & {
      /** Gooney credentials object. */
      credentials: {
        /** Gooney API user. */
        apiUser?: string;
        /** Gooney API password. */
        apiPassword?: string;
        /** Gooney API key. */
        apiKey: string;
        /** Gooney API secret. */
        apiSecret: string;
      };
    };
    /** Gpaysafe Gateway config. */
    Gpaysafe: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Gpaysafe apiKey. */
        apiKey: string;
      };
    };
    /** Greenbox config. */
    Greenbox: components["schemas"]["GatewayAccount"] & {
      /** Greenbox credentials object. */
      credentials: {
        /** Greenbox client ID. */
        clientId: string;
        /** Greenbox location ID. */
        locationId: string;
        /** Greenbox client secret. */
        clientSecret: string;
      };
    };
    /** HiPay config. */
    HiPay: components["schemas"]["GatewayAccount"] & {
      /** HiPay credentials object. */
      credentials: {
        /** HiPay API user name. */
        apiUsername: string;
        /** HiPay API password. */
        apiPassword: string;
      };
    };
    /** ICEPAY config. */
    ICEPAY: components["schemas"]["GatewayAccount"] & {
      /** ICEPAY credentials object. */
      credentials: {
        /** ICEPAY merchant ID. */
        merchantId: string;
        /** ICEPAY API secret key. */
        secretKey: string;
      };
    };
    /** INOVAPAY config. */
    INOVAPAY: components["schemas"]["GatewayAccount"] & {
      /** INOVAPAY credentials object. */
      credentials: {
        /** INOVAPAY API key. */
        apiKey: string;
        /** INOVAPAY API secret. */
        apiSecret: string;
      };
    };
    /** Ilixium3dsServers 3DS Servers. */
    Ilixium3dsServers: {
      name: "Ilixium3dsServer";
    };
    /** Ilixium Integrated. */
    Ilixium3dsServer: components["schemas"]["Ilixium3dsServers"];
    /** Ilixium Gateway config. */
    Ilixium: components["schemas"]["GatewayAccount"] & {
      /** Ilixium credentials object. */
      credentials: {
        /** Ilixium Gateway merchant ID. */
        merchantId: string;
        /** Ilixium Gateway account ID. */
        accountId: string;
        /** Ilixium Gateway digest password. */
        digestPassword: string;
      };
      /** Ilixium settings object. */
      settings?: {
        /** Force Ilixium to process via Ip Frame. */
        useIpFrame?: boolean;
        /** Use SFTP for payouts. */
        useSftpPayouts?: boolean;
        /** Use previous approval credit endpoint for payouts. */
        useCreditEndpoint?: boolean;
        /** Use standalone (token) credit endpoint for payouts. */
        useStandaloneCreditEndpoint?: boolean;
      };
      threeDSecureServer?: components["schemas"]["Ilixium3dsServers"];
    };
    /** Ingenico 3DS Servers. */
    Ingenico3dsServers: {
      name: "Ingenico3dsServer";
    };
    /** Ingenico Integrated. */
    Ingenico3dsServer: components["schemas"]["Ingenico3dsServers"];
    /** Ingenico Gateway config. */
    Ingenico: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Ingenico Gateway merchant ID. */
        merchantId: string;
        /** Ingenico Gateway api key ID. */
        apiKeyId: string;
        /** Ingenico Gateway api secret key. */
        apiSecretKey: string;
        /** Ingenico skip fraud service. */
        skipFraudService?: boolean;
      };
      threeDSecureServer?: components["schemas"]["Ingenico3dsServers"];
    };
    /** Inovio 3DS Servers. */
    Inovio3dsServers: {
      name: "Inovio3dsServer";
    };
    /** Inovio Integrated. */
    Inovio3dsServer: components["schemas"]["Inovio3dsServers"];
    /** Inovio config. */
    Inovio: components["schemas"]["GatewayAccount"] & {
      /** Inovio credentials object. */
      credentials: {
        /** Inovio username. */
        username: string;
        /** Inovio password. */
        password: string;
      };
      /** Inovio settings object. */
      settings: {
        /** Inovio website ID. */
        websiteId: string;
        /** Inovio merchant account ID. */
        merchantAccountId: string;
        /** Inovio product ID. */
        productId: string;
      };
      threeDSecureServer?: components["schemas"]["Inovio3dsServers"];
    };
    /** InstaDebit config. */
    InstaDebit: components["schemas"]["GatewayAccount"] & {
      /** InstaDebit credentials object. */
      credentials: {
        /** InstaDebit merchant account number. */
        merchantId: string;
        /** InstaDebit merchant account password. */
        password: string;
      };
    };
    /** Intuit Gateway config. */
    Intuit: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** The Intuit client_id key. */
        clientId: string;
        /** The Intuit client_secret key. */
        clientSecret: string;
      };
    };
    /** Ipay Options config. */
    IpayOptions: components["schemas"]["GatewayAccount"] & {
      /** Ipay Options credentials object. */
      credentials: {
        /** Ipay Options website ID. */
        sid: string;
        /** Ipay Options rcode. */
        rcode: string;
      };
      /** Ipay Options settings object. */
      settings: {
        /** Show extra step for user to enter their email and DNI number. */
        extraStep?: boolean;
        /** Subdomain to use when sending request to IpayOptions. */
        subdomain?: "miglite" | "w88asiapay";
        /** Platform which IpayOptions will process. */
        platform?: "SOAP" | "TxHandler" | "SecureHosted";
        /** Manually set the card_type for iDEAL. */
        cardType?: "ideal" | "idealqr";
      };
    };
    /** JetPay Gateway config. */
    JetPay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** JetPay Gateway terminal ID. */
        TerminalID: string;
      };
    };
    /** Jeton Gateway config. */
    Jeton: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Jeton apiKey. */
        apiKey: string;
      };
      settings?: {
        /** Jeton's method. */
        method: "CHECKOUT" | "DIRECT" | "QR" | "JETGO";
      };
    };
    /** Khelocard config. */
    Khelocard: components["schemas"]["GatewayAccount"] & {
      /** Credentials object. */
      credentials: {
        /** Merchant ID. */
        merchantId: string;
        /** The referrer URL registered on Khelocard. */
        referrer: string;
        /** API key. */
        apiKey: string;
        /** API secret. */
        apiSecret: string;
      };
    };
    /** Konnektive config. */
    Konnektive: components["schemas"]["GatewayAccount"] & {
      /** Credentials object. */
      credentials: {
        /** Konnektive API login ID. */
        loginId: string;
        /** Konnektive API password. */
        password: string;
      };
      /** Settings object. */
      settings: {
        /** Konnektive campaign ID for which the order is being placed. */
        campaignId: string;
        /** Konnektive campaign product ID for which the order is being placed. */
        productId: string;
      };
    };
    /** LPG config. */
    LPG: components["schemas"]["GatewayAccount"] & {
      /** LPG credentials object. */
      credentials: {
        /** LPG public API key. */
        publicKey: string;
        /** LPG secure API key. */
        secureKey: string;
        /** LPG payout account username. */
        payoutUsername?: string;
        /** LPG payout account password. */
        payoutPassword?: string;
      };
    };
    /** Moneris Gateway config. */
    Moneris: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Moneris Gateway api token. */
        apiToken: string;
        /** Moneris Gateway store ID. */
        storeId: string;
      };
    };
    /** MTA Pay Gateway config. */
    MtaPay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** MTA Pay Gateway account ID. */
        accountId: string;
        /** MTA Pay Gateway party ID. */
        partyId: string;
        /** MTA Pay Gateway md5key. */
        md5key: string;
      };
      /** MTA Pay settings object. */
      settings: {
        /** MTA Pay Gateway goods. */
        goods: string;
        /** MTA Pay Gateway mobile pay param. */
        mobilePay: string;
      };
    };
    /** MuchBetter config. */
    MuchBetter: components["schemas"]["GatewayAccount"] & {
      /** MuchBetter credentials object. */
      credentials: {
        /** MuchBetter merchant account ID. */
        merchantAccountId: string;
        /** MuchBetter api key. */
        apiKey: string;
      };
      /** MuchBetter settings object. */
      settings?: {
        /** MuchBetter brand name used for reporting and logo. */
        brandName?: string;
        /** Request phone number before submitting the request to MuchBetter. */
        hasPhoneNumberRequest?: boolean;
      };
    };
    /** MyFatoorah config. */
    MyFatoorah: components["schemas"]["GatewayAccount"] & {
      /** MyFatoorah credentials object. */
      credentials: {
        /** MyFatoorah api key. */
        apiKey: string;
      };
    };
    /** Neosurf config. */
    Neosurf: components["schemas"]["GatewayAccount"] & {
      /** Neosurf credentials object. */
      credentials: {
        /** Neosurf merchant ID. */
        merchantId: string;
        /** Neosurf API secret key. */
        secretKey: string;
      };
    };
    /** NMI Gateway config. */
    NMI: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** NMI Gateway api token. */
        username: string;
        /** NMI Gateway store ID. */
        password: string;
      };
      threeDSecureServer?: components["schemas"]["NMI3dsServers"];
    };
    /** Netbanking config. */
    Netbanking: components["schemas"]["GatewayAccount"] & {
      /** Netbanking credentials object. */
      credentials: {
        /** Netbanking MID code. */
        midcode: string;
        /** Netbanking MID secret key. */
        midsecret: string;
      };
    };
    /** Neteller Gateway config. */
    Neteller: components["schemas"]["GatewayAccount"] & {
      /** Neteller credentials object. */
      credentials: {
        /** Neteller App Paysafe Payments API Username for a private key. */
        paysafePaymentsApiUsername: string;
        /** Neteller App Paysafe Payments API Password for a private key. */
        paysafePaymentsApiPassword: string;
      };
      settings?: {
        /** Populate customer email for payment. */
        populateCustomerEmail?: boolean;
      };
    };
    /** NGenius 3DS Servers. */
    NGenius3dsServers: {
      name: "NGenius3dsServer";
    };
    /** NGenius Integrated. */
    NGenius3dsServer: components["schemas"]["NGenius3dsServers"];
    /** NGenius config. */
    NGenius: components["schemas"]["GatewayAccount"] & {
      /** NGenius credentials object. */
      credentials: {
        /** NGenius outlet ID. */
        outletId: string;
        /** NGenius API key. */
        apiKey: string;
      };
      threeDSecureServer?: components["schemas"]["NGenius3dsServers"];
    };
    /** NinjaWallet config. */
    NinjaWallet: components["schemas"]["GatewayAccount"] & {
      /** NinjaWallet credentials object. */
      credentials: {
        /** NinjaWallet api key. */
        apiKey: string;
        /** NinjaWallet secret. */
        secret: string;
        /** NinjaWallet passphrase. */
        passphrase: string;
      };
    };
    /** NuaPay Gateway config. */
    NuaPay: components["schemas"]["GatewayAccount"] & {
      /** NuaPay credentials object. */
      credentials: {
        /** NuaPay common name. */
        nuaPayCommonName: string;
        /** NuaPay serial number. */
        nuaPaySerialNumber: string;
        /** NuaPay account ID. */
        nuaPayAccountId: string;
        /** NuaPay origiantor IBAN. */
        nuaPayOriginatorIban: string;
        /** NuaPay api key. */
        nuaPayApiKey: string;
        /** NuaPay private key. */
        nuaPayPrivateKey: string;
      };
    };
    /** OchaPay Gateway config. */
    OchaPay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** OchaPay Gateway username. */
        apiUsername: string;
        /** OchaPay Gateway api password. */
        apiPassword: string;
        /** OchaPay Gateway secret word. */
        secretWord: string;
      };
    };
    /** Onlineueberweisen config. */
    Onlineueberweisen: components["schemas"]["GatewayAccount"] & {
      /** Onlineueberweisen credentials object. */
      credentials: {
        /** Onlineueberweisen API Key. */
        apiKey: string;
        /** NuaPay API Key for reconciliation. */
        nuaPayApiKey?: string;
        /** NuaPay account ID for reconciliation. */
        nuaPayAccountId?: string;
      };
      /** Onlineueberweisen settings object. */
      settings: {
        /** Onlineueberweisen payform code to use customized Payform template. */
        payformCode?: string;
      };
    };
    /** Pagsmile Gateway config. */
    Pagsmile: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Pagsmile merchant ID. */
        merchantId: string;
        /** Pagsmile app ID. */
        appId: string;
        /** Pagsmile secret key. */
        secretKey: string;
      };
    };
    /** Panamerican 3DS Servers. */
    Panamerican3dsServers: {
      name: "Panamerican3dsServer";
    };
    /** Panamerican Integrated. */
    Panamerican3dsServer: components["schemas"]["Panamerican3dsServers"];
    /** Panamerican config. */
    Panamerican: components["schemas"]["GatewayAccount"] & {
      /** Panamerican credentials object. */
      credentials: {
        /** Panamerican's key. */
        key: string;
        /** Panamerican's Password. */
        password: string;
      };
      threeDSecureServer?: components["schemas"]["Panamerican3dsServers"];
      /** Panamerican settings object. */
      settings: {
        /** Show extra step for user to enter their ID number. */
        extraStep: boolean;
        /** Will convert all chars to ascii. */
        convertToAscii?: boolean;
      };
    };
    /** Panda Gateway config. */
    PandaGateway: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Panda Gateway merchant code. */
        merchantCode: string;
        /** Panda Gateway api code. */
        apiCode: string;
        /** Panda Gateway sign key. */
        signKey: string;
      };
    };
    /** Paramount config. */
    ParamountEft: components["schemas"]["GatewayAccount"] & {
      /** Paramount credentials object. */
      credentials: {
        /** Merchant account ID. */
        merchant_id: string;
        /** Merchant account password. */
        merchant_pass: string;
        /** Merchant name/descriptor. */
        payee: string;
      };
    };
    /** ParamountInterac config. */
    ParamountInterac: components["schemas"]["GatewayAccount"] & {
      /** ParamountInterac credentials object. */
      credentials: {
        /** ParamountInterac merchant ID. */
        merchantId: string;
        /** ParamountInterac encryption key. */
        encryptionKey: string;
        /** ParamountInterac password for query. */
        password: string;
      };
    };
    /** Pay4Fun config. */
    Pay4Fun: components["schemas"]["GatewayAccount"] & {
      /** Pay4Fun credentials object. */
      credentials: {
        /** Pay4Fun merchant ID. */
        merchantId: string;
        /** Pay4Fun merchant secret. */
        merchantSecret: string;
        /** Pay4Fun merchant key. */
        merchantKey: string;
      };
    };
    /** PayCash config. */
    PayCash: components["schemas"]["GatewayAccount"] & {
      /** PayCash credentials object. */
      credentials: {
        /** Identify of the company. */
        emisor: string;
        /** Token. */
        token: string;
      };
    };
    /** PayPal Gateway config. */
    PayPal: components["schemas"]["GatewayAccount"] & {
      /** PayPal settings object. */
      settings: {
        /** The URL where the user will be redirected after authorizing the account on PayPal. */
        redirectUrl: string;
      };
    };
    /** Payeezy Gateway config. */
    Payeezy: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Payeezy Merchant ID. */
        merchantId: string;
        /** Merchant Token. */
        merchantToken: string;
        /** API Key. */
        apiKey: string;
        /** API Secret. */
        apiSecret: string;
      };
    };
    /** Payflow config. */
    Payflow: components["schemas"]["GatewayAccount"] & {
      /** Payflow credentials object. */
      credentials: {
        /** If you set up one or more additional users on the account, this value is the ID of the user authorized to process transactions. If, however, you have not set up additional users, USER has the same value as VENDOR. */
        user: string;
        /** Your merchant login ID created when you registered for the account. */
        vendor: string;
        /** The password you defined while registering for the account. */
        password: string;
      };
    };
    /** PaymenTechnologies Gateway config. */
    PaymenTechnologies: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** PaymenTechnologies Gateway authenticate ID. */
        authenticateId: string;
        /** PaymenTechnologies Gateway authenticate password. */
        authenticatePw: string;
        /** PaymenTechnologies Gateway API public key. */
        publicKey: string;
        /** PaymenTechnologies Gateway API secret key. */
        secretKey: string;
        /** PaymenTechnologies API key required for query operations. */
        apiKey: string;
      };
      settings?: {
        /** Use 3DS endpoint. */
        use3DSEndpoint?: boolean;
      };
    };
    /** Paymero config. */
    Paymero: components["schemas"]["GatewayAccount"] & {
      /** Paymero credentials object. */
      credentials: {
        /** Paymero API key. */
        apiKey: string;
      };
      /** Paymero settings object. */
      settings?: {
        /** Tolerance percentage (from 1 to 100) for settled amount for crypto currency method. */
        tolerancePercentage?: number;
        /** This will be the currency to which you want to auto-convert the received cryptocurrency in to. */
        targetCurrency?: components["schemas"]["CurrencyCode"];
      };
    };
    /** Payr Gateway config. */
    Payr: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Payr Gateway client ID. */
        clientId: string;
        /** Payr Gateway secret word. */
        secretWord: string;
        /** Username for the Alliance API (transaction reporting). */
        apiUserId?: string;
        /** Hash of the password for the Alliance API (transaction reporting). */
        apiSecurityToken?: string;
      };
    };
    /** Paysafe 3DS Servers. */
    Paysafe3dsServers: {
      name: "Paysafe3dsServer";
    };
    /** Paysafe Integrated. */
    Paysafe3dsServer: components["schemas"]["Paysafe3dsServers"];
    /** Paysafe Gateway config. */
    Paysafe: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Paysafe Gateway store ID. */
        storeId: string;
        /** Paysafe Gateway store password. */
        storePwd: string;
        /** Paysafe Gateway account number. */
        accountNum: string;
      };
      threeDSecureServer?: components["schemas"]["Paysafe3dsServers"];
    };
    /** Paysafecash Gateway config. */
    Paysafecash: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Paysafecash API key. */
        apiKey: string;
      };
    };
    /** PayULatam config. */
    PayULatam: components["schemas"]["GatewayAccount"] & {
      /** PayULatam credentials object. */
      credentials: {
        /** PayULatam merchant id. */
        merchantId: string;
        /** PayULatam account id. */
        accountId: string;
        /** PayULatam API login. */
        apiLogin: string;
        /** PayULatam API key. */
        apiKey: string;
      };
    };
    /** Payvision Gateway config. */
    Payvision: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Payvision Gateway member id. */
        memberId: string;
        /** Payvision Gateway member guid. */
        memberGuid: string;
      };
      /** Payvision settings object. */
      settings?: {
        /** Payvision Gateway avs. */
        avs?: boolean;
        /** Payvision Gateway delay. */
        delay?: number;
        /** Payvision merchant account type. */
        merchantAccountType: number;
      };
      threeDSecureServer?: components["schemas"]["Payvision3dsServers"];
    };
    /** Piastrix 3DS Servers. */
    Piastrix3dsServers: {
      name: "Piastrix3dsServer";
    };
    /** Piastrix Integrated. */
    Piastrix3dsServer: components["schemas"]["Piastrix3dsServers"];
    /** Piastrix config. */
    Piastrix: components["schemas"]["GatewayAccount"] & {
      /** Piastrix credentials object. */
      credentials: {
        /** Shop ID. */
        shopId: string;
        /** Secret Key. */
        secretKey: string;
      };
      threeDSecureServer?: components["schemas"]["Piastrix3dsServers"];
    };
    /** Plugnpay Gateway config. */
    Plugnpay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Plugnpay Gateway member id. */
        "publisher-name": string;
        /** Plugnpay Gateway avs. */
        "publisher-password": string;
      };
    };
    /** Prosa config. */
    Prosa: components["schemas"]["GatewayAccount"] & {
      /** Prosa credentials object. */
      credentials: {
        /** Entity ID. */
        entityId: string;
        /** Access token. */
        accessToken: string;
      };
    };
    /** RPN Gateway config. */
    RPN: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** RPN MID. */
        mid: string;
        /** RPN Key. */
        key: string;
      };
    };
    /** Realex Gateway config. */
    Realex: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Realex Gateway merchant id. */
        merchantId: string;
        /** Realex Gateway secret key. */
        secretKey: string;
        /** Realex Gateway rebate password. */
        rebatePassword: string;
        /** Realex Gateway account. */
        account: string;
      };
    };
    /** Realtime Gateway config. */
    Realtime: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Realtime Gateway client ID. */
        clientId: string;
        /** Realtime Gateway secret word. */
        secretWord: string;
      };
    };
    /** Redsys Gateway config. */
    Redsys: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Redsys Gateway merchant code. */
        merchantCode: string;
        /** Redsys Gateway secret code. */
        secretCode: string;
      };
    };
    /** Rotessa config. */
    Rotessa: components["schemas"]["GatewayAccount"] & {
      /** Rotessa credentials object. */
      credentials: {
        /** Rotessa api key. */
        apiKey: string;
      };
      /** Rotessa settings object. */
      settings: {
        /** Rotessa Gateway time delay for them to process transaction. */
        delay: number;
      };
    };
    /** SaltarPay config. */
    SaltarPay: components["schemas"]["GatewayAccount"] & {
      /** SaltarPay credentials object. */
      credentials: {
        /** SaltarPay API key. */
        apiKey: string;
        /** SaltarPay secret key. */
        secretKey: string;
      };
    };
    /** SMSVoucher Gateway config. */
    SMSVoucher: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** SMSVoucher AppId. */
        AppId: string;
      };
    };
    /** Sofort config. */
    Sofort: components["schemas"]["GatewayAccount"] & {
      /** Sofort credentials object. */
      credentials: {
        /** Sofort configuration key. */
        configKey: string;
        /** NuaPay API Key for reconciliation. */
        nuaPayApiKey?: string;
        /** NuaPay account ID for reconciliation. */
        nuaPayAccountId?: string;
      };
    };
    /** Sagepay Gateway config. */
    Sagepay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Sagepay Gateway merchant ID. */
        M_ID: string;
        /** Sagepay Gateway merchant key. */
        M_KEY: string;
      };
    };
    /** SeamlessChex config. */
    SeamlessChex: components["schemas"]["GatewayAccount"] & {
      /** SeamlessChex credentials object. */
      credentials: {
        /** SeamlessChex publishable key. */
        publicKey: string;
        /** SeamlessChex secret key. */
        secretKey: string;
      };
    };
    /** SecureTrading 3DS Servers. */
    SecureTrading3dsServers: {
      name: "SecureTrading3dsServer";
    };
    /** SecureTrading 3DS Server. */
    SecureTrading3dsServer: components["schemas"]["SecureTrading3dsServers"];
    /** SecureTrading config. */
    SecureTrading: components["schemas"]["GatewayAccount"] & {
      /** SecureTrading credentials object. */
      credentials: {
        /** Website ID. */
        websiteId: string;
        /** SecureTrading web service username. */
        username: string;
        /** SecureTrading web service password. */
        password: string;
      };
      threeDSecureServer?: components["schemas"]["SecureTrading3dsServers"];
    };
    /** Skrill config. */
    Skrill: components["schemas"]["GatewayAccount"] & {
      /** Skrill credentials object. */
      credentials: {
        /** Email address of your Skrill merchant account. */
        accountEmail: string;
        /** Secret word used for MD5 signature verifications. */
        secretWord: string;
        /** Password used during MQI/API requests. */
        mqiPassword?: string;
      };
    };
    /** SmartInvoice 3DS Servers. */
    SmartInvoice3dsServers: {
      name: "SmartInvoice3dsServer";
    };
    /** SmartInvoice Integrated. */
    SmartInvoice3dsServer: components["schemas"]["SmartInvoice3dsServers"];
    /** SmartInvoice config. */
    SmartInvoice: components["schemas"]["GatewayAccount"] & {
      /** SmartInvoice credentials object. */
      credentials: {
        /** SmartInvoice merchant account UID. */
        merchantId: string;
        /** SmartInvoice application UID. */
        applicationId: string;
      };
      threeDSecureServer?: components["schemas"]["SmartInvoice3dsServers"];
    };
    /** SparkPay config. */
    SparkPay: components["schemas"]["GatewayAccount"] & {
      /** SparkPay credentials object. */
      credentials: {
        /** SparkPay shop ID. */
        shopId: string;
        /** SparkPay secret key. */
        secretKey: string;
      };
    };
    /** StaticGateway Gateway config. */
    StaticGateway: components["schemas"]["GatewayAccount"] & {
      [key: string]: any;
    };
    /** Stripe 3DS Servers. */
    Stripe3dsServers: {
      name?: "Stripe3dsServer";
    };
    /** Stripe Integrated. */
    Stripe3dsServer: components["schemas"]["Stripe3dsServers"] & {
      /**
       * If true, Stripe will attempt to perform 3D Secure
       * and overrides any [dynamic 3D Secure Radar rules](https://stripe.com/docs/radar/rules#request-3ds).
       */
      enforceThreeDSecure?: boolean;
    };
    /** Stripe Gateway config. */
    Stripe: components["schemas"]["GatewayAccount"] & {
      /** Stripe settings object. */
      settings: {
        /** The URL where the user will be redirected after authorizing the account on Stripe. */
        redirectUrl: string;
        /** If `true` the `PaymentIntents` API will be used instead of `Charges` API. */
        usePaymentIntents?: boolean;
        /** If `true`, `off_session` param will always be `true` in Stripe requests. */
        enforceOffSession?: boolean;
      };
      threeDSecureServer?: components["schemas"]["Stripe3dsServers"];
    };
    /** TestProcessor Gateway config. */
    TestProcessor: components["schemas"]["GatewayAccount"] & {
      threeDSecureServer?: components["schemas"]["TestProcessor3dsServers"];
    };
    /** ToditoCash config. */
    ToditoCash: components["schemas"]["GatewayAccount"] & {
      /** ToditoCash credentials object. */
      credentials: {
        /** ToditoCash API key. */
        apiKey: string;
      };
    };
    /** Trustly config. */
    Trustly: components["schemas"]["GatewayAccount"] & {
      /** Trustly credentials object. */
      credentials: {
        /** Trustly username. */
        username?: string;
        /** Trustly password. */
        password: string;
        /** Trustly public key. */
        publicKey: string;
        /** Trustly private key. */
        privateKey: string;
      };
    };
    /** TWINT config. */
    TWINT: components["schemas"]["GatewayAccount"] & {
      /** TWINT credentials object. */
      credentials: {
        /** TWINT store UUID. */
        storeUuid: string;
        /** Cash register ID. */
        cashRegisterId: string;
        /** TWINT public key. */
        publicKey: string;
        /** TWINT private key. */
        privateKey: string;
        /** TWINT key's passphrase. */
        keyPassphrase: string;
      };
      /** TWINT settings object. */
      settings: {
        /** TWINT cash register type. */
        cashRegisterType: string;
      };
    };
    /** UPayCard Gateway config. */
    UPayCard: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** merchant receiver account. */
        receiver_account: string;
        /** merchant key. */
        key: string;
        /** merchant secret. */
        secret: string;
      };
      /** UpayCard settings object. */
      settings?: {
        /** Tolerance percentage for settled amount. */
        tolerancePercentage?: string;
      };
    };
    /** USAePay Gateway config. */
    USAePay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** USAePay Gateway source key. */
        sourceKey: string;
        /** USAePay Gateway pin. */
        pin: string;
      };
    };
    /** VantivLitle Gateway config. */
    VantivLitle: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** VantivLitle Gateway username. */
        username: string;
        /** VantivLitle Gateway password. */
        password: string;
        /** VantivLitle Gateway merchant ID. */
        merchantId: string;
      };
      threeDSecureServer?: components["schemas"]["VantivLitle3dsServers"];
    };
    /** VCreditos config. */
    VCreditos: components["schemas"]["GatewayAccount"] & {
      /** VCreditos credentials object. */
      credentials: {
        /** VCreditos API public key. */
        publicKey: string;
        /** VCreditos API secret key. */
        secretKey: string;
      };
    };
    /** Wallet88 config. */
    Wallet88: components["schemas"]["GatewayAccount"] & {
      /** Wallet88 credentials object. */
      credentials: {
        /** Wallet88 API user. */
        username: string;
        /** Wallet88 API password. */
        password: string;
      };
    };
    /** Walpay Gateway config. */
    Walpay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Walpay Gateway merchant name. */
        merchantName: string;
        /** Walpay Gateway merchant pin. */
        merchantPin: string;
      };
      threeDSecureServer?: components["schemas"]["Walpay3dsServers"];
    };
    /** Wirecard 3DS Servers. */
    Wirecard3dsServers: {
      name: "Wirecard3dsServer";
    };
    /** Wirecard Integrated. */
    Wirecard3dsServer: components["schemas"]["Wirecard3dsServers"];
    /** Wirecard Gateway config. */
    Wirecard: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Wirecard Gateway merchant username. */
        merchantUsername: string;
        /** Wirecard Gateway merchant password. */
        merchantPassword: string;
        /** Wirecard Gateway merchant business case signature. */
        businessSignature: string;
        /** Wirecard Gateway delay. */
        delay: number;
        /** Wirecard sftp username. */
        sftpUsername?: string;
        /** Wirecard sftp private key. */
        sftpPrivateKey?: string;
      };
      threeDSecureServer?: components["schemas"]["Wirecard3dsServers"];
    };
    /** WorldlineAtosFrankfurt Gateway config. */
    WorldlineAtosFrankfurt: components["schemas"]["GatewayAccount"] & {
      threeDSecureServer?: components["schemas"]["WorldlineAtosFrankfurt3dsServers"];
      /** WorldlineAtosFrankfurt credentials. */
      credentials: {
        /** Card Acceptor ID Code. */
        cardAcceptorIdCode: string;
        /** Acquiring Institution Identification Code. */
        acquiringInstitutionIdentificationCode: string;
      };
      /** WorldlineAtosFrankfurt settings. */
      settings: {
        /** Card Acceptor Name. */
        cardAcceptorName: string;
        /** Card Acceptor Location. */
        cardAcceptorLocation: string;
        /** Card Acceptor Country Code. */
        cardAcceptorCountryCode: string;
      };
    };
    /** Worldpay Gateway config. */
    Worldpay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Worldpay Gateway merchant code. */
        merchantCode: string;
        /** Worldpay Gateway merchant password. */
        merchantPassword: string;
      };
      threeDSecureServer?: components["schemas"]["Worldpay3dsServers"];
      settings?: {
        /** True to enable Stored Credentials. */
        enableStoredCredentials?: boolean;
        /** The value of merchantInitiatedReason to send with merchant-initiated transactions. */
        merchantInitiatedReason?:
          | "UNSCHEDULED"
          | "RECURRING"
          | "INSTALMENT"
          | "REAUTH"
          | "DELAYED"
          | "INCREMENTAL"
          | "RESUBMISSION"
          | "NOSHOW";
      };
    };
    /** Zotapay Gateway config. */
    Zotapay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** Zotapay's endpoint ID. */
        endpointId: string;
        /** Zotapay's merchant ID. */
        merchantId: string;
        /** Zotapay's merchant secret key. */
        merchantSecretKey: string;
      };
    };
    /** eMerchantPay Gateway config. */
    eMerchantPay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** eMerchantPay Gateway client ID. */
        clientId?: string;
        /** eMerchantPay Gateway api key. */
        apiKey?: string;
        /** eMerchantPay username for Genesis platform. */
        username?: string;
        /** eMerchantPay token for Genesis platform. */
        token?: string;
        /** eMerchantPay password for Genesis platform. */
        password?: string;
      };
      /** eMerchantPay settings object. */
      settings?: {
        /** eMerchantPay platform to process payment. */
        platform?: "IPG" | "Genesis";
      };
      threeDSecureServer?: components["schemas"]["eMerchantPay3dsServers"];
    };
    /** ecoPayz config. */
    ecoPayz: components["schemas"]["GatewayAccount"] & {
      /** ecoPayz credentials object. */
      credentials: {
        /** ecoPayz payment page ID. */
        paymentPageId: string;
        /** ecoPayz merchant account number. */
        merchantAccountNumber: string;
        /** ecoPayz merchant password. */
        merchantPassword: string;
      };
      /** ecoPayz settings object. */
      settings?: {
        /** Three letter currency code. */
        validCurrency: "CAD" | "EUR" | "GBP" | "USD";
      };
    };
    /** iCanPay Gateway config. */
    iCanPay: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** iCanPay Gateway authenticate ID. */
        authenticateId: string;
        /** iCanPay Gateway authenticate password. */
        authenticatePw: string;
        /** iCanPay Gateway API public key. */
        publicKey: string;
        /** iCanPay Gateway API secret key. */
        secretKey: string;
      };
      settings?: {
        /** Use 3DS endpoint. */
        use3DSEndpoint?: boolean;
      };
    };
    /** iCheque Gateway config. */
    iCheque: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** iCheque Gateway client ID. */
        clientId: string;
        /** iCheque Gateway secret word. */
        secretWord: string;
        /** Username for the Alliance API (transaction reporting). */
        apiUserId?: string;
        /** Hash of the password for the Alliance API (transaction reporting). */
        apiSecurityToken?: string;
      };
    };
    /** iDebit config. */
    iDebit: components["schemas"]["GatewayAccount"] & {
      /** iDebit credentials object. */
      credentials: {
        /** iDebit merchant account number. */
        merchantId: string;
        /** iDebit merchant account password. */
        password: string;
      };
    };
    /** vegaaH Gateway config. */
    vegaaH: components["schemas"]["GatewayAccount"] & {
      credentials: {
        /** vegaaH Gateway terminal ID. */
        terminalId: string;
        /** vegaaH Gateway password. */
        password: string;
      };
    };
    /** Zimpler config. */
    Zimpler: components["schemas"]["GatewayAccount"] & {
      /** Zimpler credentials object. */
      credentials: {
        /** Zimpler merchant id. */
        merchantId: string;
        /** Zimpler API key. */
        apiKey: string;
      };
    };
    /** Payment Card brand. */
    PaymentCardBrand:
      | "Visa"
      | "MasterCard"
      | "American Express"
      | "Discover"
      | "Maestro"
      | "Solo"
      | "Electron"
      | "JCB"
      | "Voyager"
      | "Diners Club"
      | "Switch"
      | "Laser"
      | "China UnionPay"
      | "AstroPay Card";
    /** Configure which digital wallets are enabled. */
    DigitalWallets: {
      /** The Apple Pay digital wallet configuration. Skip if not using Apple Pay. */
      applePay?: {
        /** Set true if Apple Pay is enabled. */
        isEnabled: boolean;
      };
      /** The Google Pay digital wallet configuration. Skip if not using Google Pay. */
      googlePay?: {
        /** Set true if Google Pay is enabled. */
        isEnabled: boolean;
        /** The merchant name in Google Pay. Leave blank if using FramePay. */
        merchantName?: string;
        /** The merchant origin in Google Pay. The fully qualified domain name. Leave blank if using FramePay. */
        merchantOrigin?: string;
      };
    };
    OnBoardingUrlLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "onBoardingUrl";
    };
    DynamicIpnLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "dynamicIpnUrl";
    };
    StaticIpnLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "staticIpnUrl";
    };
    /** Gateway Account object. */
    GatewayAccountEmbed: {
      gatewayAccount?: components["schemas"]["GatewayAccount"];
    };
    /** Website object. */
    WebsiteEmbed: {
      website?: { [key: string]: any };
    };
    CommonPaymentCard: {
      /** The payment instrument ID. */
      id?: components["schemas"]["ResourceId"];
      /** The method of payment instrument. */
      method?: "payment-card";
      /** The ustomer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /**
       * Payment instrument status. When an instrument is `active` it means it has been used at least once for an approved transaction.
       * To remove an instrument from being in use, set it as `deactivated` (see the deactivation endpoint).
       */
      status?:
        | "active"
        | "inactive"
        | "expired"
        | "deactivated"
        | "verification-needed";
      /** A unique value to identify the payment instrument regardless of variable values. It contains alphanumeric values. */
      fingerprint?: string;
      /** The card's bin (the PAN's first 6 digits). */
      bin?: string;
      /** The PAN's last 4 digits. */
      last4?: string;
      /** The card PAN (primary account number). */
      pan?: string;
      /** Card's expiration year. */
      expYear?: number;
      /** Card's expiration month. */
      expMonth?: number;
      /** Card's cvv (card verification value). */
      cvv?: string;
      brand?: components["schemas"]["PaymentCardBrand"];
      /** Payment instrument bank country. */
      bankCountry?: string;
      /** Payment instrument bank name. */
      bankName?: string;
      /** The billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      /** Payment instrument created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Payment instrument updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    AuthTransactionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "authTransaction";
    };
    /** Auth Transaction object. */
    AuthTransactionEmbed: {
      authTransaction?: components["schemas"]["Transaction"];
    };
    PaymentCard: components["schemas"]["CommonPaymentCard"] & {
      /** Default gateway account ID used for transactions. */
      stickyGatewayAccountId?: string;
      /** Time expiration reminder event will be triggered. */
      expirationReminderTime?: components["schemas"]["ServerTimestamp"] | null;
      /** Number of expiration reminder events triggered. */
      expirationReminderNumber?: number;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]> &
        Partial<components["schemas"]["AuthTransactionLink"]> &
        Partial<components["schemas"]["ApprovalUrlLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["AuthTransactionEmbed"]> &
        Partial<components["schemas"]["CustomerEmbed"]>)[];
    };
    /** Payment Card object. */
    PaymentCardEmbed: {
      paymentCard?: components["schemas"]["PaymentCard"];
    };
    /** Bank Account object. */
    BankAccountEmbed: {
      bankAccount?: components["schemas"]["BankAccount"];
    };
    Invoice: components["schemas"]["CommonInvoice"] & { [key: string]: any } & {
      /** The ustomer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /** The website ID. */
      websiteId?: components["schemas"]["ResourceId"];
      /** Invoice transactions array. */
      transactions?: components["schemas"]["Transaction"][];
      /** The invoice retry instruction. */
      retryInstruction?: {
        attempts: {
          scheduleInstruction: components["schemas"]["InvoiceRetryScheduleInstruction"];
        }[];
        /** The policy on the attempt finishes. */
        afterAttemptPolicies: "change-subscription-renewal-time"[];
        /** The policy on the retry ends. */
        afterRetryEndPolicies: ("abandon-invoice" | "cancel-subscription")[];
      };
      /**
       * The number of times the invoice data has been modified.
       * The revision is useful when analyzing webhook data to determine if the change takes precedence over the current representation.
       */
      revision?: number;
      /** Time past due reminder event will be triggered. */
      dueReminderTime?: components["schemas"]["ServerTimestamp"] | null;
      /** Number of past due reminder events triggered. */
      dueReminderNumber?: number;
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]> &
        Partial<components["schemas"]["WebsiteLink"]> &
        Partial<components["schemas"]["OrganizationLink"]> &
        Partial<components["schemas"]["LeadSourceLink"]> &
        Partial<components["schemas"]["TransactionAllocationsLink"]> &
        Partial<components["schemas"]["RecalculateInvoiceLink"]> &
        Partial<components["schemas"]["SubscriptionLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["CustomerEmbed"]> &
        Partial<components["schemas"]["WebsiteEmbed"]> &
        Partial<components["schemas"]["OrganizationEmbed"]> &
        Partial<components["schemas"]["LeadSourceEmbed"]>)[];
    };
    /** Invoices collection. */
    InvoicesEmbed: {
      invoices?: components["schemas"]["Invoice"][];
    };
    OrganizationLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "organization";
    };
    TransactionAllocationsLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "transactionAllocations";
    };
    RecalculateInvoiceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "recalculateInvoice";
    };
    SubscriptionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "subscription";
    };
    Organization: {
      /** The organization identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The organization created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The organization updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The organization name. */
      name: string;
      /** The organization street address. */
      address?: string;
      /** The organization street address. */
      address2?: string;
      /** The organization city. */
      city?: string;
      /** The organization region (state). */
      region?: string;
      /** The organization country ISO Alpha-2 code. */
      country: string;
      /** The organization postal code. */
      postalCode?: string;
      phoneNumbers?: components["schemas"]["ContactPhoneNumbers"];
      emails?: components["schemas"]["ContactEmails"];
      /** The organization's tax label. This will be displayed on the invoice. */
      taxDescriptor?: string;
      /** Invoice will use this time zone to display time otherwise UTC will be used. Example "America/New_York". */
      invoiceTimeZone?: string;
      /** True, if Organization is primary (available to set as true only, other organizations will become as isPrimary=false). */
      isPrimary?: boolean;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Organization object. */
    OrganizationEmbed: {
      organization?: components["schemas"]["Organization"];
    };
    TransactionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "transaction";
    };
    /** Transaction object. */
    TransactionEmbed: {
      transaction?: components["schemas"]["Transaction"];
    };
    Dispute: {
      /** The dispute identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The dispute's customer ID. */
      customerId?: string;
      /** The dispute's transaction ID. */
      transactionId: string;
      currency: components["schemas"]["CurrencyCode"];
      /** The dispute amount. */
      amount: number;
      /** The dispute's acquirer reference number. */
      acquirerReferenceNumber?: string;
      /** The case ID for the dispute. */
      caseId?: string;
      /** The dispute's reason code. */
      reasonCode:
        | "1000"
        | "10.1"
        | "10.2"
        | "10.3"
        | "10.4"
        | "10.5"
        | "11.1"
        | "11.2"
        | "11.3"
        | "12"
        | "12.1"
        | "12.2"
        | "12.3"
        | "12.4"
        | "12.5"
        | "12.6"
        | "12.7"
        | "13.1"
        | "13.2"
        | "13.3"
        | "13.4"
        | "13.5"
        | "13.6"
        | "13.7"
        | "13.8"
        | "13.9"
        | "2"
        | "30"
        | "31"
        | "35"
        | "37"
        | "40"
        | "41"
        | "42"
        | "46"
        | "47"
        | "49"
        | "50"
        | "53"
        | "54"
        | "55"
        | "57"
        | "59"
        | "60"
        | "62"
        | "7"
        | "70"
        | "71"
        | "72"
        | "73"
        | "74"
        | "75"
        | "76"
        | "77"
        | "79"
        | "8"
        | "80"
        | "81"
        | "82"
        | "83"
        | "85"
        | "86"
        | "93"
        | "00"
        | "63"
        | "A01"
        | "A02"
        | "A08"
        | "F10"
        | "F14"
        | "F22"
        | "F24"
        | "F29"
        | "C02"
        | "C04"
        | "C05"
        | "C08"
        | "C14"
        | "C18"
        | "C28"
        | "C31"
        | "C32"
        | "M10"
        | "M49"
        | "P01"
        | "P03"
        | "P04"
        | "P05"
        | "P07"
        | "P08"
        | "P22"
        | "P23"
        | "R03"
        | "R13"
        | "M01"
        | "FR1"
        | "FR4"
        | "FR6"
        | "AL"
        | "AP"
        | "AW"
        | "CA"
        | "CD"
        | "CR"
        | "DA"
        | "DP"
        | "DP1"
        | "EX"
        | "IC"
        | "IN"
        | "IS"
        | "LP"
        | "N"
        | "NA"
        | "NC"
        | "P"
        | "RG"
        | "RM"
        | "RN1"
        | "RN2"
        | "SV"
        | "TF"
        | "TNM"
        | "UA01"
        | "UA02"
        | "UA32"
        | "UA99"
        | "UA03"
        | "UA10"
        | "UA11"
        | "UA12"
        | "UA18"
        | "UA20"
        | "UA21"
        | "UA22"
        | "UA23"
        | "UA28"
        | "UA30"
        | "UA31"
        | "UA38"
        | "duplicate"
        | "fraudulent"
        | "subscription_canceled"
        | "product_unacceptable"
        | "product_not_received"
        | "unrecognized"
        | "credit_not_processed"
        | "customer_initiated"
        | "incorrect_account_details"
        | "insufficient_funds"
        | "bank_cannot_process"
        | "debit_not_authorized"
        | "general"
        | "pre-chargeback-alert"
        | "0"
        | "1"
        | "2"
        | "3"
        | "4"
        | "5"
        | "6"
        | "7"
        | "9"
        | "51"
        | "A"
        | "B";
      /** The dispute's category. */
      category?:
        | "fraud"
        | "unrecognized"
        | "product-not-received"
        | "product-unacceptable"
        | "product-not-refunded"
        | "duplicate"
        | "subscription-canceled"
        | "uncategorized";
      /** The dispute's type. */
      type:
        | "information-request"
        | "first-chargeback"
        | "second-chargeback"
        | "arbitration"
        | "fraud"
        | "ethoca-alert"
        | "verifi-alert";
      /** The dispute's status. */
      status:
        | "response-needed"
        | "under-review"
        | "forfeited"
        | "won"
        | "lost"
        | "unknown";
      /** Dispute posted time. */
      postedTime: string;
      /** Dispute deadline time. */
      deadlineTime?: string;
      /** Dispute raw response from gateway. */
      rawResponse?: string;
      /** Dispute resolved time. */
      resolvedTime?: components["schemas"]["ServerTimestamp"];
      /** Dispute created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Dispute updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["TransactionLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: Partial<components["schemas"]["TransactionEmbed"]>[];
    };
    FileCreateFromInline: {
      /** The file in base64 encoded format. */
      file: string;
      /** The File visibility. If public a permalink is provided. */
      isPublic?: boolean;
      /** The file name used for downloading. */
      name?: string;
      /** The file description. */
      description?: string;
      /** The tags list. */
      tags?: string[];
    };
    FileCreateFromUrl: {
      /** The URL of the file to upload. */
      url: string;
      /** The File visibility. If public a permalink is provided. */
      isPublic?: boolean;
      /** The file name used for downloading. */
      name?: string;
      /** The file description. */
      description?: string;
      /** The tags list. */
      tags?: string[];
    };
    InvoiceIssue: {
      /** Invoice issued time. Will be issued immediately if `null` or omitted. */
      issuedTime?: string | null;
      /** Invoice due time. Will be set same as `issuedTime` if `null` or omitted. */
      dueTime?: string | null;
    };
    InvoiceReissue: {
      /** Invoice due time. Will be set as current date-time if `null` or omitted. */
      dueTime?: string | null;
    };
    InvoiceTimeline: {
      /** The Timeline message identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Timeline message type. */
      type?:
        | "timeline-comment-created"
        | "invoice-created"
        | "invoice-issued"
        | "invoice-abandoned"
        | "invoice-voided"
        | "invoice-past-due"
        | "invoice-paid"
        | "invoice-partially-paid"
        | "invoice-disputed"
        | "invoice-refunded"
        | "invoice-partially-refunded"
        | "invoice-renewal-payment-declined"
        | "email-message-sent"
        | "coupon-applied"
        | "transaction-approved"
        | "transaction-abandoned"
        | "transaction-canceled"
        | "transaction-declined"
        | "transaction-refunded"
        | "transaction-voided";
      /** Shows who or what triggered the Timeline event. */
      triggeredBy?: "rebilly" | "app" | "direct-api";
      /** The message that describes the message details. */
      message?: string;
      extraData?: components["schemas"]["TimelineExtraData"];
      /** Timeline message time. */
      occurredTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    InvoiceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "invoice";
    };
    InvoiceTransactionAllocation: {
      invoiceId?: components["schemas"]["ResourceId"];
      transactionId?: components["schemas"]["ResourceId"];
      amount?: number;
      currency?: components["schemas"]["CurrencyCode"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["InvoiceLink"]> &
        Partial<components["schemas"]["TransactionLink"]>)[];
    };
    KycDocumentRejection: {
      type?:
        | "document-unreadable"
        | "document-expired"
        | "document-not-matching"
        | "underage-person"
        | "other";
      /** The rejection message. */
      message?: string;
    };
    CommonKycDocument: {
      id?: components["schemas"]["ResourceId"];
      /** The ustomer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** Linked file object id. */
      fileId?: components["schemas"]["ResourceId"];
      /** Linked file object id's. */
      fileIds?: components["schemas"]["ResourceId"][];
      /** Document type submitted for validation, only identity-proof type is analyzed in an automated manner. */
      documentType: "identity-proof" | "address-proof" | "funds-proof";
      /** Document subtype submitted for validation. */
      documentSubtype?: "passport" | "id-card" | "driver-license";
      /** The level of strictness for the document matches. */
      matchLevel?: number;
      /** Status of the validation. */
      status: "pending" | "in-progress" | "accepted" | "rejected";
      /** Reason for uploading. */
      reason?: string;
      rejectionReason?: components["schemas"]["KycDocumentRejection"];
      /** Creation date/time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Latest update date/time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Processing date/time. */
      processedTime?: components["schemas"]["ServerTimestamp"];
      /** Reviewer's user ID. */
      reviewerId?: string | null;
      /** Reviewer's first and last name. */
      reviewerName?: string | null;
      /** Date and time of manual review. */
      reviewTime?: components["schemas"]["ServerTimestamp"] | null;
    };
    ProofOfIdentity: components["schemas"]["CommonKycDocument"] & {
      documentMatches?: {
        /** The calculated score that represents the % of confidence that this ID represents the given customer. */
        score?: number;
        data?: {
          /** Flag that indicates if there is an image that contains a face on it. */
          containsImage?: boolean;
          /** Flag that indicates if this looks like and ID. */
          isIdentityDocument?: boolean;
          /** If there is an exact match found online. */
          isPublishedOnline?: boolean;
          /** The customer first name if it was matched, null otherwise. */
          firstName?: string;
          /** The customer last name if it was matched, null otherwise. */
          lastName?: string;
          /** The date of birth found on the document, null if not found. */
          dateOfBirth?: components["schemas"]["ServerTimestamp"];
          /** The expiry date found on the document, null if not found. */
          expiryDate?: components["schemas"]["ServerTimestamp"];
          /** The issued date found on the document, null if not found. */
          issueDate?: components["schemas"]["ServerTimestamp"];
          /** Checks the minimal age, 21+ for USA and 18+ for all other countries. Null if dateOfBirth could not be determined. */
          hasMinimalAge?: boolean;
        };
      };
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["FileLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
    };
    ProofOfAddress: components["schemas"]["CommonKycDocument"] & {
      documentMatches?: {
        /** The calculated score that represents the % of confidence that this proof of address represents the given customer. */
        score?: number;
        data?: {
          /** The customer first name if it was matched, null otherwise. */
          firstName?: string;
          /** The customer last name if it was matched, null otherwise. */
          lastName?: string;
          /** The customer address if it was matched, null otherwise. */
          line1?: string;
          /** The customer city if it was matched, null otherwise. */
          city?: string;
          /** The customer region if it was matched, null otherwise. */
          region?: string;
          /** The customer postal code if it was matched, null otherwise. */
          postalCode?: string;
          /** The number of words in the document. */
          wordCount?: number;
          /** Flag that indicates if the word count passed the threshold. */
          wordCountResult?: boolean;
          /** The number of unique words in the document. */
          uniqueWords?: number;
          /** Flag that indicates if the unique words passed the threshold. */
          uniqueWordsResult?: boolean;
          /** The date on the document proving the document is recent. */
          date?: string;
          /** The phone of the company or agency that sent the document. */
          phone?: string;
        };
      };
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["FileLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
    };
    ProofOfFunds: components["schemas"]["CommonKycDocument"];
    KycDocument:
      | components["schemas"]["ProofOfIdentity"]
      | components["schemas"]["ProofOfAddress"]
      | components["schemas"]["ProofOfFunds"];
    ResetPasswordToken: {
      /** The token's identifier string. */
      token?: string;
      /** The token's username. */
      username: string;
      /** Token's credential ID. */
      credentialId?: string;
      /** Password expired time. */
      expiredTime?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    CommonPayPalAccount: {
      /** The payment instrument ID. */
      id?: components["schemas"]["ResourceId"];
      /** The method of payment instrument. */
      method: "paypal";
      /** The customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** The billing address. */
      billingAddress: components["schemas"]["ContactObject"];
      /** PayPal username. */
      username?: string;
      /** PayPal account status. */
      status?: "inactive" | "active" | "deactivated";
      /** PayPal account created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** PayPal account updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    PayPalAccount: components["schemas"]["CommonPayPalAccount"] & {
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]> &
        Partial<components["schemas"]["AuthTransactionLink"]> &
        Partial<components["schemas"]["ApprovalUrlLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["AuthTransactionEmbed"]> &
        Partial<components["schemas"]["CustomerEmbed"]>)[];
    };
    KhelocardCard: {
      /** The payment instrument ID. */
      id?: components["schemas"]["ResourceId"];
      /** The method of payment instrument. */
      method?: "Khelocard";
      /** Customer's ID. */
      customerId?: components["schemas"]["ResourceId"];
      /** A unique value to identify the payment instrument regardless of variable values. It contains alphanumeric values. */
      fingerprint?: string;
      /** Khelocard card's masked number. */
      number?: string;
      /** The number's last 4 digits. */
      last4?: string;
      /** Khelocard card's expiration year. */
      expYear?: number;
      /** Khelocard card's expiration month. */
      expMonth?: number;
      /** The billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      /** The payment instrument status. */
      status?: "active" | "deactivated";
      /** The payment instrument created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The payment instrument updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
      /** Links related to the resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: Partial<components["schemas"]["CustomerEmbed"]>[];
    };
    "PaymentInstrument-2":
      | components["schemas"]["PaymentCard"]
      | components["schemas"]["BankAccount"]
      | components["schemas"]["PayPalAccount"]
      | components["schemas"]["KhelocardCard"];
    PaymentInstrumentCreateToken: {
      /** The customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** Payment token ID. */
      token: string;
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    PaymentCardCreatePlain: {
      /** The method of payment instrument. */
      method: "payment-card";
      /** The Customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** The card PAN (Primary Account Number). */
      pan: string;
      /** Card's expiration year. */
      expYear: number;
      /** Card's expiration month. */
      expMonth: number;
      /** Card's cvv (card verification value). */
      cvv?: string;
      /** The billing address. */
      billingAddress: components["schemas"]["ContactObject"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      browserData?: components["schemas"]["BrowserData"];
    };
    PaymentInstrumentUpdateToken: {
      /** Payment token ID. */
      token?: string;
      /** The billing address (if supplied  overrides billing address from token). */
      billingAddress?: components["schemas"]["ContactObject"];
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    PaymentCardUpdatePlain: {
      /** Card's cvv (card verification value). */
      cvv?: string;
      /** Card's expiration month. */
      expMonth?: number;
      /** Card's expiration year. */
      expYear?: number;
      /** The billing address. */
      billingAddress?: components["schemas"]["ContactObject"];
      /** Sticky gateway account ID. */
      stickyGatewayAccountId?: components["schemas"]["ResourceId"];
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    PaymentCardCreateToken: {
      /** The Customer's ID. */
      customerId: components["schemas"]["ResourceId"];
      /** PaymentCardToken ID. */
      token: string;
      customFields?: components["schemas"]["ResourceCustomFields"];
    };
    /** The name of the payment method returned in our API response. */
    PaymentMethodApiName: string;
    PaymentMethodCountriesUnrestrictedMetadata: {
      mode?: "unknown" | "all";
    };
    PaymentMethodCountriesSubsetMetadata: {
      mode?: "subset";
      /** The list of payment method's supported countries. */
      values: string[];
    };
    PaymentMethodCountriesMetadata:
      | components["schemas"]["PaymentMethodCountriesUnrestrictedMetadata"]
      | components["schemas"]["PaymentMethodCountriesSubsetMetadata"];
    PaymentMethodMetadata: {
      apiName: components["schemas"]["PaymentMethodApiName"];
      /** The name of the payment method. */
      name: string;
      /** The URL for the payment method logo optimized for landscape orientation. */
      landscapeLogo?: string | null;
      /** The URL for the payment method logo optimized for portrait orientation. */
      portraitLogo?: string | null;
      /** A short description of the payment method. (Markdown is supported). */
      summary: string;
      /** A detailed information about the payment method. (Markdown is supported). */
      description: string;
      countries: components["schemas"]["PaymentMethodCountriesMetadata"];
      storefrontEnabled?: boolean;
    };
    /**
     * The URL to redirect the end-user when an offsite transaction is completed.
     * The 2 placeholders are available to use in this URI: `{id}` and `{result}`.
     * Defaults to the website's configured URL.
     */
    TransactionRedirectUrl: string;
    PayPalAccountAuthorization: {
      /** The Website ID. */
      websiteId: string;
      currency: components["schemas"]["CurrencyCode"];
      /** The amount to authorize. */
      amount?: number;
      /** The Gateway Account ID which use to send transactions. */
      gatewayAccountId?: string;
      redirectUrl?: components["schemas"]["TransactionRedirectUrl"];
    };
    Membership: {
      /** Membership organization. */
      organization: {
        /** Organization ID. */
        id?: string;
        /** Organization name. */
        name?: string;
        /** The organization created time. */
        createdTime?: components["schemas"]["ServerTimestamp"];
      };
      /** Membership user. */
      user: {
        /** Organization ID. */
        id?: string;
        /** First and last name. */
        name?: string;
      };
      /** The user's permissions. See the format in example. Use wildcard `*` for full access. */
      permissions?: components["schemas"]["AclPermissions"];
      /** User is owner of organization. */
      isOwner?: boolean;
      /** This organization is default for membership user. */
      isDefault?: boolean;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Session: {
      /** The session identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The session's token used for authentication. */
      token?: string;
      /** The session's permissions. See the format in example. Use wildcard `*` for full access. */
      permissions: components["schemas"]["AclPermissions"];
      /** The user memberships. */
      memberships?: components["schemas"]["Membership"][];
      /** The user identifier string. */
      userId?: components["schemas"]["ResourceId"];
      /** Session created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Session updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Session expired time. Defaults to one hour. */
      expiredTime?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Subscription: {
      /** The Order identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Specifies the type of order, a subscription or a one-time purchase. */
      orderType: "subscription-order" | "one-time-order";
      /**
       * The billing status of the most recent invoice.  It may
       * help you determine if you should change the service status
       * such as suspending the service.
       */
      billingStatus?:
        | "unpaid"
        | "past-due"
        | "delinquent"
        | "paid"
        | "voided"
        | "refunded"
        | "disputed"
        | "voided";
      /** Unique id for each customer. */
      customerId: components["schemas"]["ResourceId"];
      /** Unique id for each website. */
      websiteId: components["schemas"]["ResourceId"];
      /** Unique id for the initial invoice. */
      initialInvoiceId?: components["schemas"]["ResourceId"];
      /** Unique id for the most recently issued invoice. It might not be `paid` yet. */
      recentInvoiceId?: components["schemas"]["ResourceId"];
      items: {
        /** Unique id for each plan. */
        planId: components["schemas"]["ResourceId"];
        /** Number of units of the product on the given plan. */
        quantity?: number;
      }[];
      /** Delivery address. */
      deliveryAddress?: components["schemas"]["ContactObject"] | null;
      /** Billing address. */
      billingAddress?: components["schemas"]["ContactObject"] | null;
      /** Risk metadata. If null, the value would coalesce to the risk metadata captured when creating the payment token. */
      riskMetadata?: components["schemas"]["RiskMetadata"] | null;
      /** Order activation time. */
      activationTime?: components["schemas"]["ServerTimestamp"];
      /**
       * A list of coupons to redeem on the customer and restrict to this subscription.
       * Read more about [coupons here](https://docs.rebilly.com/docs/dashboard/marketing/coupons-and-discounts/).
       *
       * This parameter respects the following logic:
       *
       * - When not passed then applied coupons will not be changed.
       *
       * - When empty array passed then all applied coupon redemptions will be canceled.
       *
       * - When list of coupons is passed then not applied yet coupons will be applied, already applied coupons
       * will not change their state, applied coupons that are not presented in passed list will be canceled.
       *
       * If list of applied coupons on pending order will be changed due to this param during update order,
       *  Invoice for the order will be reissued.
       */
      couponIds?: string[] | null;
      /** Purchase order number, will be displayed on the issued invoices. */
      poNumber?: string | null;
      /**
       * The number of times the order data has been modified.
       * The revision is useful when analyzing webhook data to determine if the change takes precedence over the current representation.
       */
      revision?: number;
    };
    InitialInvoiceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "initialInvoice";
    };
    RecentInvoiceLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "recentInvoice";
    };
    /** Recent Invoice object. */
    RecentInvoiceEmbed: {
      recentInvoice?: components["schemas"]["Invoice"];
    };
    /** Initial Invoice object. */
    InitialInvoiceEmbed: {
      initialInvoice?: components["schemas"]["Invoice"];
    };
    SubscriptionMetadata: {
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** Order created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Order updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["CustomerLink"]> &
        Partial<components["schemas"]["InitialInvoiceLink"]> &
        Partial<components["schemas"]["RecentInvoiceLink"]> &
        Partial<components["schemas"]["WebsiteLink"]> &
        Partial<components["schemas"]["ApprovalUrlLink"]>)[];
      /** Any embedded objects available that are requested by the `expand` querystring parameter. */
      _embedded?: (Partial<components["schemas"]["RecentInvoiceEmbed"]> &
        Partial<components["schemas"]["InitialInvoiceEmbed"]> &
        Partial<components["schemas"]["CustomerEmbed"]> &
        Partial<components["schemas"]["WebsiteEmbed"]> &
        Partial<components["schemas"]["LeadSourceEmbed"]>)[];
    };
    "one-time-order": components["schemas"]["Subscription"] & {
      /** One-time order status. */
      status?: "pending" | "completed" | "abandoned";
    } & components["schemas"]["SubscriptionMetadata"];
    /** Line item. */
    UpcomingInvoiceItem: {
      /** Type of line item. */
      type: "debit" | "credit";
      /** Description of line item. */
      description?: string;
      /** Unit price of the line item. */
      unitPriceAmount: number;
      unitPriceCurrency: components["schemas"]["CurrencyCode"];
      /** Quantity of line item. */
      quantity: number;
      /** Date-time when the period begins for this item. */
      periodStartTime?: string;
      /** Date-time when the period ends for this item. */
      periodEndTime?: string;
      /** Date-time when the item was added to the subscription. */
      createdTime?: components["schemas"]["ServerTimestamp"];
    };
    UpcomingInvoiceItemCollection: components["schemas"]["UpcomingInvoiceItem"][];
    SubscriptionCancellationState: {
      /** Subscription order canceled time. */
      canceledTime?: components["schemas"]["ServerTimestamp"];
      /** Canceled by. */
      canceledBy?: "merchant" | "customer" | "rebilly";
      /** Cancel category. */
      cancelCategory?:
        | "billing-failure"
        | "did-not-use"
        | "did-not-want"
        | "missing-features"
        | "bugs-or-problems"
        | "do-not-remember"
        | "risk-warning"
        | "contract-expired"
        | "too-expensive"
        | "never-started"
        | "switched-plan"
        | "other";
      /** Cancel reason description in free form. */
      cancelDescription?: string;
    };
    "subscription-order": components["schemas"]["Subscription"] & {
      /**
       * The status of the subscription service. A subscription starts
       * in the `pending` status, and will become `active` when the
       * service period begins.
       */
      status?:
        | "pending"
        | "active"
        | "canceled"
        | "churned"
        | "suspended"
        | "paused"
        | "abandoned"
        | "trial-ended";
      /** True if the subscription is currently in a trial period. */
      inTrial?: boolean;
      /** To use plan defaults do not send the `trial` key, or send a `null`. value with it. */
      trial?: {
        /** Enable or disable the trial for this subscription. If enabled for plans without trial prices, the trial will be free. */
        enabled?: boolean;
        /** The time the trial should end. */
        endTime: string;
      };
      /** Whether a subscription ends after a trial period. Recurring settings are ignored if it's `true`. */
      isTrialOnly?: boolean;
      /**
       * You can shift issue time and due time of invoices for this subscription.
       * This setting overrides plan settings. To use plan settings, set `null`.
       * To use multiple plans in one subscription they all must have the same billing period,
       * this property allows to subscribe to different plans.
       */
      invoiceTimeShift?: components["schemas"]["InvoiceTimeShift"] | null;
      /**
       * The recurring interval to override plan settings. To use plan settings, set `null`.
       * To use multiple plans in one subscription they all must have the same recurring period length,
       * this property allows to subscribe to different plans.
       */
      recurringInterval?: {
        periodAnchorInstruction?: components["schemas"]["ServicePeriodAnchorInstruction"];
      } | null;
      /** Autopay determines if a payment attempt will be automatic. */
      autopay?: boolean;
      /** Subscription start time.  When the value is sent as null, it will use the current time. This value can't be in past more than one service period. */
      startTime?: string | null;
      /** Subscription end time. */
      endTime?: components["schemas"]["ServerTimestamp"];
      /** Subscription renewal time. */
      renewalTime?: string;
      /** The current period number. */
      rebillNumber?: number;
      /** Time renewal reminder event will be triggered. */
      renewalReminderTime?: components["schemas"]["ServerTimestamp"] | null;
      /** Number of renewal reminder events triggered. */
      renewalReminderNumber?: number;
      /** Time renewal reminder event will be triggered. */
      trialReminderTime?: components["schemas"]["ServerTimestamp"] | null;
      /** Number of renewal reminder events triggered. */
      trialReminderNumber?: number;
      /** Subscription line items which queue until the next renewal (or interim) invoice is issued for the subscription. */
      lineItems?: components["schemas"]["UpcomingInvoiceItemCollection"];
      /** Subtotal of line items in this subscription (signed value). If credits exceed debits, it will be a negative number. */
      lineItemSubtotal?: {
        currency?: components["schemas"]["CurrencyCode"];
        amount?: number;
      };
    } & components["schemas"]["SubscriptionCancellationState"] &
      components["schemas"]["SubscriptionMetadata"];
    Search: {
      /** List of returned customers. */
      customers?: components["schemas"]["Customer"][];
      /** List of returned invoices. */
      invoices?: components["schemas"]["Invoice"][];
      /** List of returned orders. */
      orders?: components["schemas"]["Subscription"][];
      /** List of returned transactions. */
      transactions?: components["schemas"]["Transaction"][];
      /** Names of searched resources, even if they returned nothing. */
      searched?: string[];
    };
    PriceBasedShippingRate: {
      /** The shipping rate name. */
      name: string;
      /** Minimum order subtotal for which this shipping rate is applicable, defaults to 0.00. */
      minOrderSubtotal?: number;
      /** Maximum order subtotal for which this shipping rate is applicable (NULL if no maximum). */
      maxOrderSubtotal?: number;
      /** The shipping price - 0 is a valid value (for free). */
      price: number;
      currency: components["schemas"]["CurrencyCode"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    ShippingZone: {
      /** The shipping zone identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The shipping zone name. */
      name: string;
      /**
       * Countries covered by the shipping zone. A country can only belong to one shipping zone (no overlapping).
       * This property can be empty or null to create a default shipping zone for countries that were not specified in other zones.
       */
      countries?: string[];
      /** Price-based shipping rate instructions. */
      rates?: components["schemas"]["PriceBasedShippingRate"][];
      /** Is this Shipping Zone default. */
      isDefault?: { [key: string]: any };
      /** The shipping zone created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The shipping zone updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    SubscriptionCancellation: {
      /** Cancellation identifier. */
      id?: components["schemas"]["ResourceId"];
      /** Identifier of the canceled subscription order. */
      subscriptionId: components["schemas"]["ResourceId"];
      /** Identifier of the invoice on which the cancellation proration is calculated. */
      proratedInvoiceId?: components["schemas"]["ResourceId"];
      /** The identifier of the invoice where the cancellation fees or credits are applied. */
      appliedInvoiceId?: components["schemas"]["ResourceId"];
      /** Who did the cancellation. */
      canceledBy?: "merchant" | "customer";
      /** Cancellation reason. */
      reason?:
        | "did-not-use"
        | "did-not-want"
        | "missing-features"
        | "bugs-or-problems"
        | "do-not-remember"
        | "risk-warning"
        | "contract-expired"
        | "too-expensive"
        | "other"
        | "billing-failure";
      /** Cancel reason description in free form. */
      description?: string;
      /**
       * Defines if the customer gets a pro-rata credit for the time remaining between `churnTime` and
       * subscription's next renewal time.
       */
      prorated?: boolean;
      /**
       * "draft" defines that the cancellation isn't applied on an invoice and subscription but
       * can be inspected to see the charge.
       * "confirmed" will set a subscription to be canceled when the `churnTime` is reached.
       * "completed" is a read-only status which is set by the system when the churnTime is reached.
       * The cancellation may not be changed or deleted when the status is "completed".
       */
      status?: "draft" | "confirmed" | "completed" | "revoked";
      /** The cancellation time (when the status is confirmed which is by default unless specified "draft"). */
      canceledTime?: string;
      /** The time of resource creation (when it is posted). */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The time when the subscription will be deactivated. */
      churnTime: string;
      /** Items to be added to the new invoice. Proration item is generated and added automatically. */
      lineItems?: components["schemas"]["UpcomingInvoiceItemCollection"];
      /** Subtotal of the line items which will be added after the subscription's cancellation. */
      lineItemSubtotal?: number;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    SubscriptionReactivation: {
      /** Reactivation identifier. */
      id?: components["schemas"]["ResourceId"];
      /** Identifier of the reactivated subscription. */
      subscriptionId: components["schemas"]["ResourceId"];
      /** Identifier of the related cancellation. */
      cancellationId?: components["schemas"]["ResourceId"];
      /** Reactivation reason description in free form. */
      description?: string;
      /**
       * The date from which the service period would start, unless the subscription is canceled but still active.
       * In case the susbcription is still active, the subscription will continue the current service period.
       * If omitted, it will default to the current time.
       */
      effectiveTime?: string;
      /**
       * The time of the next subscription renewal. If omitted then it is computed from the effective time.
       * If the subscription is canceled but active it is ignored, so the next renewal will happen as scheduled.
       */
      renewalTime?: string;
      /** The time of resource creation (when it is posted). */
      createdTime?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    SubscriptionChange: {
      /** The plan identifier string. */
      planId: components["schemas"]["ResourceId"];
      /** Number of units of the product on the given plan. If null or omitted, current quantity will not be changed. */
      quantity?: number;
      /** The value determines whether the subscription retains its current `renewalTime` or resets it to a newly calculated `renewalTime`. */
      renewalPolicy: "reset" | "retain";
      /**
       * Whether or not to give a pro rata credit for the amount of time remaining between the `effectiveTime` and the end of the current period.
       * In addition, if the `renewalTime` is retained (by setting the `renewalPolicy` to `retain`), then a pro rata debit will occur as well,
       * for the amount between the `effectiveTime` and the `renewalTime` as a percentage of the normal period size.
       */
      prorated: boolean;
      /** The date from which the renewal time (for `reset` operations) and proration calculations are made.  If omitted, it will default to the current time. */
      effectiveTime?: string;
      /** If set to true, it will not change the subscription.  It allows for a way to preview the changes that would be made to a subscription. */
      preview?: boolean;
      /** If set to true and the subscription order has an active trial, it will use that trial further. Works with 'retain' renewalPolicy only. */
      keepTrial?: boolean;
    };
    SubscriptionInvoice: {
      /** If present, applies a payment to the invoice created.  If the payment is for the invoice total, it would be marked as paid. */
      transactionId?: components["schemas"]["ResourceId"];
    };
    OrderTimeline: {
      /** The Timeline message identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Timeline message type. */
      type?:
        | "timeline-comment-created"
        | "order-renewed"
        | "order-activated"
        | "order-completed"
        | "order-reactivated"
        | "order-canceled"
        | "order-upgraded"
        | "order-downgraded"
        | "order-billing-address-changed"
        | "order-delivery-address-changed"
        | "order-renewal-time-changed"
        | "order-churned"
        | "order-custom-fields-changed"
        | "order-items-changed"
        | "order-billing-anchor-changed"
        | "order-recurring-interval-changed"
        | "order-risk-metadata-changed"
        | "order-paid-early"
        | "order-quantity-changed"
        | "email-message-sent"
        | "coupon-applied"
        | "invoice-created"
        | "invoice-issued"
        | "invoice-abandoned"
        | "invoice-voided"
        | "invoice-past-due"
        | "invoice-paid"
        | "invoice-partially-paid"
        | "invoice-disputed"
        | "invoice-refunded"
        | "invoice-partially-refunded"
        | "invoice-renewal-payment-declined";
      /** Shows who or what triggered the Timeline message. */
      triggeredBy?: "rebilly" | "app" | "direct-api";
      /** The message that describes the message details. */
      message?: string;
      extraData?: components["schemas"]["TimelineExtraData"];
      /** Timeline message time. */
      occurredTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    CommonPaymentToken: {
      /** The token identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Whether the token was already used. */
      isUsed?: boolean;
      method: string;
      browserData?: components["schemas"]["BrowserData"];
      leadSource?: components["schemas"]["LeadSource"];
      /** Token created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Token updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Token usage time. */
      usageTime?: components["schemas"]["ServerTimestamp"];
      /** Token expiration time. */
      expirationTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    PaymentCardToken: components["schemas"]["CommonPaymentToken"] & {
      /** The token payment method. */
      method: "payment-card";
      /** The payment card instrument details. */
      paymentInstrument: {
        /** Payment Card PAN (Primary Account Number). */
        pan?: string;
        /** Payment Card CVV/CVC. */
        cvv?: string;
        /** Payment Card expiration month. */
        expMonth?: number;
        /** Payment Card expiration year. */
        expYear?: number;
        /** Payment Card BIN (the PAN's first 6 digits). */
        bin?: string;
        /** Payment Card PAN's last 4 digits. */
        last4?: string;
        brand?: components["schemas"]["PaymentCardBrand"];
      };
      /** The billing address object. */
      billingAddress?: components["schemas"]["ContactObject"];
    };
    /** The bank account BBAN or IBAN instrument. */
    BankAccountInstrument: {
      /** Bank's Account Number type. A valid value is basic bank account number (BBAN) or international bank account number (IBAN). */
      accountNumberType: "IBAN" | "BBAN";
    };
    /** Bank account BBAN instrument. */
    BBANInstrument: components["schemas"]["BankAccountInstrument"] & {
      /** Bank Account Number. */
      accountNumber: string;
      /** Bank Routing Number. */
      routingNumber: string;
      /** Bank Account Type. */
      accountType: "checking" | "savings" | "other";
      /** Bank Identifier Code. */
      bic?: string;
      /** Bank name. */
      bankName?: string;
      /** Bank Account Number's last 4 digits. */
      last4?: string;
    };
    /** Bank account IBAN instrument. */
    IBANInstrument: components["schemas"]["BankAccountInstrument"] & {
      /** Bank Account Number. Detailed information about all ISO 13616-compliant national IBAN formats is available in [SWIFT IBAN Registry](https://www.swift.com/standards/data-standards/iban). */
      accountNumber: string;
      /** Bank Identifier Code. */
      bic?: string;
      /** Bank name. */
      bankName?: string;
      /** Bank Account Number's last 4 digits. */
      last4?: string;
    };
    BankAccountToken: components["schemas"]["CommonPaymentToken"] & {
      /** The token payment method. */
      method: "ach" | "echeck";
      paymentInstrument: components["schemas"]["BankAccountInstrument"];
      /** The billing address object. */
      billingAddress: components["schemas"]["ContactObject"];
    };
    DigitalWalletToken: components["schemas"]["CommonPaymentToken"] & {
      /** The token payment method. */
      method: "digital-wallet";
      /** The payment instrument details. */
      paymentInstrument: {
        /** The digital wallet type. */
        type: "Apple Pay" | "Google Pay";
        /** Authorized for the digital wallet amount. */
        amount: number;
        /** Authorized for the digital wallet currency. */
        currency: components["schemas"]["CurrencyCode"];
        /** The descriptor for a payment. */
        descriptor: string;
        /** Payment Card BIN (the PAN's first 6 digits). */
        bin?: string;
        /** Payment Card PAN's last 4 digits. */
        last4?: string;
        brand?: components["schemas"]["PaymentCardBrand"];
        /** Payment Card expiration month. */
        expMonth?: number;
        /** Payment Card expiration year. */
        expYear?: number;
        /** The digital wallet encoded data. May contain the digital wallet billing address. */
        payload: { [key: string]: any };
      };
      /** The billing address object. */
      billingAddress?: components["schemas"]["ContactObject"];
    };
    PlaidAccountToken: components["schemas"]["CommonPaymentToken"] & {
      /** The token method. */
      method: "plaid-account";
      /** The Plaid payment instrument details. */
      paymentInstrument: {
        /** The Plaid credentials hash. */
        credentialHash: components["schemas"]["ResourceId"];
        /** The Plaid public token. */
        publicToken: string;
        /** The Plaid account ID. */
        accountId: string;
      };
      /** The billing address object. */
      billingAddress: components["schemas"]["ContactObject"];
    };
    KhelocardCardToken: components["schemas"]["CommonPaymentToken"] & {
      /** The token method. */
      method: "Khelocard";
      /** The token instrument details. */
      paymentInstrument: {
        /** Khelocard card number. */
        number: string;
        /** Khelocard card CVV. */
        cvv: string;
        /** Khelocard card number's last 4 digits. */
        last4?: string;
        /** Khelocard card expiration month. */
        expMonth: number;
        /** Khelocard card expiration year. */
        expYear: number;
      };
      /** The billing address object. */
      billingAddress: components["schemas"]["ContactObject"];
    };
    /** The token payment method. */
    TokenPaymentMethod:
      | "cash"
      | "check"
      | "paypal"
      | "AdvCash"
      | "Alfa-click"
      | "Alipay"
      | "AstroPay Card"
      | "bank-transfer"
      | "bank-transfer-2"
      | "bank-transfer-3"
      | "bank-transfer-4"
      | "bank-transfer-5"
      | "bank-transfer-6"
      | "bank-transfer-7"
      | "bank-transfer-8"
      | "bank-transfer-9"
      | "Beeline"
      | "Belfius-direct-net"
      | "bitcoin"
      | "Boleto"
      | "cash-deposit"
      | "CASHlib"
      | "CashToCode"
      | "China UnionPay"
      | "CODVoucher"
      | "Conekta-oxxo"
      | "Cupon-de-pagos"
      | "cryptocurrency"
      | "domestic-cards"
      | "echeck"
      | "ecoPayz"
      | "ecoVoucher"
      | "EPS"
      | "ePay.bg"
      | "eZeeWallet"
      | "Flexepin"
      | "Giropay"
      | "Gpaysafe"
      | "Google Pay"
      | "iDebit"
      | "iDEAL"
      | "ING-homepay"
      | "INOVAPAY-pin"
      | "INOVAPAY-wallet"
      | "InstaDebit"
      | "instant-bank-transfer"
      | "Interac"
      | "Interac-online"
      | "Interac-eTransfer"
      | "invoice"
      | "Jeton"
      | "jpay"
      | "Khelocard"
      | "Klarna"
      | "Megafon"
      | "miscellaneous"
      | "Mistercash"
      | "MTS"
      | "MuchBetter"
      | "Neosurf"
      | "Netbanking"
      | "Neteller"
      | "Nordea-Solo"
      | "OchaPay"
      | "online-bank-transfer"
      | "Onlineueberweisen"
      | "oriental-wallet"
      | "OXXO"
      | "Pagsmile-deposit-express"
      | "Pagsmile-lottery"
      | "PayCash"
      | "Payeer"
      | "Paymero"
      | "Perfect-money"
      | "Piastrix"
      | "plaid-account"
      | "Paysafecard"
      | "Paysafecash"
      | "Pay4Fun"
      | "PinPay"
      | "phone"
      | "POLi"
      | "Przelewy24"
      | "QIWI"
      | "QQPay"
      | "Resurs"
      | "SEPA"
      | "Skrill"
      | "Skrill Rapid Transfer"
      | "SMSVoucher"
      | "Sofort"
      | "SparkPay"
      | "swift-dbt"
      | "Tele2"
      | "Terminaly-RF"
      | "ToditoCash-card"
      | "Trustly"
      | "UPayCard"
      | "VCreditos"
      | "voucher"
      | "voucher-2"
      | "voucher-3"
      | "voucher-4"
      | "Webmoney"
      | "Webpay"
      | "Webpay-2"
      | "Webpay Card"
      | "WeChat Pay"
      | "Yandex-money"
      | "Zotapay"
      | "Zimpler";
    AlternativePaymentToken: components["schemas"]["CommonPaymentToken"] & {
      method: components["schemas"]["TokenPaymentMethod"];
      /** The billing address object. */
      billingAddress: components["schemas"]["ContactObject"];
    };
    CompositeToken:
      | components["schemas"]["PaymentCardToken"]
      | components["schemas"]["BankAccountToken"]
      | components["schemas"]["DigitalWalletToken"]
      | components["schemas"]["PlaidAccountToken"]
      | components["schemas"]["KhelocardCardToken"]
      | components["schemas"]["AlternativePaymentToken"];
    DigitalWalletValidation: {
      /** Type of the digital wallet to validate. */
      type: "Apple Pay";
    };
    /** Apple Pay session validation. */
    ApplePayValidation: components["schemas"]["DigitalWalletValidation"] & {
      type?: string;
      /** The validation request. */
      validationRequest: {
        /** The URL provided by the Apple Pay SDK to perform the validation. */
        validationURL?: string;
        /** The domain where the client code like FramePay is executed. Should be registered in the Apple Pay console by Rebilly before using. */
        domainName?: string;
        /** A name of your store, suitable for display. */
        displayName?: string;
      };
      /** The validation response to use by the Apple Pay SDK to proceed. */
      validationResponse?: { [key: string]: any };
    };
    PaymentToken: {
      /** Payment Token ID. */
      token: string;
    };
    "PaymentInstrument-3": {
      /** The Payment Instrument identifier string. */
      paymentInstrumentId: components["schemas"]["ResourceId"];
    };
    PaymentMethods: {
      /**
       * The list of available payment methods.
       * Only payment methods with at least one active gateway account are allowed.
       *
       * If not specified all available payment methods will be displayed.
       *
       * Customer can choose any of those as well as the payment instrument for them.
       * Additional steps will occur via a redirect to `approvalUrl`.
       */
      methods?: components["schemas"]["PaymentMethod"][];
    };
    PaymentInstruction:
      | components["schemas"]["PaymentToken"]
      | components["schemas"]["PaymentInstrument-3"]
      | components["schemas"]["PaymentMethods"];
    CommonTransactionRequest: {
      /** The website identifier string. */
      websiteId: components["schemas"]["ResourceId"];
      /** The customer identifier string. */
      customerId: components["schemas"]["ResourceId"];
      currency: components["schemas"]["CurrencyCode"];
      /** The transaction amount. */
      amount: number;
      /** The array of invoice identifiers. */
      invoiceIds?: components["schemas"]["ResourceId"][] | null;
      /** Payment instruction. If not supplied, customer's default payment instrument will be used. */
      paymentInstruction?: components["schemas"]["PaymentInstruction"];
      paymentInstrument?: components["schemas"]["PaymentInstrument"];
      /** Billing address. If not supplied, we use the billing address associated with the payment instrument, and then customer. */
      billingAddress?: components["schemas"]["ContactObject"] | null;
      /** The request id is **recommended**. It prevents duplicate transaction requests within a short period of time. If a duplicate request is sent with the same `requestId` it will be ignored to prevent double-billing anyone.  It must be unique within a 24-hour period.  We recommend generating a UUID v4 as its value. */
      requestId?: string | null;
      /** Rebilly will select the appropriate payment gateway account for the transaction based on the properties of the transaction and the `gateway-account-requested` event rules configurations. If you wish to prevent Rebilly from making the gateway account selection, you may supply a gateway account id here, and it will be used instead. Only use this field if you intend to override the settings. */
      gatewayAccountId?: components["schemas"]["ResourceId"] | null;
      /** The payment description. */
      description?: string | null;
      /** The URL where a server-to-server notification request type `POST` with a transaction payload will be sent when the transaction's result is finalized. Do not trust the notification; follow with a `GET` request to confirm the result of the transaction. Please respond with a `2xx` HTTP status code, or we will reattempt the request again. You may use `{id}` or `{result}` as placeholders in the URL and we will replace them with the transaction's id and result accordingly. */
      notificationUrl?: string | null;
      /** The URL to redirect the end-user when an offsite transaction is completed. Defaults to the website's configured URL. You may use `{id}` or `{result}` as placeholders in the URL and we will replace them with the transaction's id and result accordingly. */
      redirectUrl?: string | null;
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** True if transaction was processed outside Rebilly. */
      isProcessedOutside?: boolean;
      /** True if the transaction was initiated by the merchant. */
      isMerchantInitiated?: boolean;
      /** The time the transaction was processed. Can be specified only if transaction was processed outside Rebilly. */
      processedTime?: string;
    };
    TransactionRequest: components["schemas"]["CommonTransactionRequest"] & {
      [key: string]: any;
    } & {
      /**
       * The type of transaction requested.
       * You should always include the type within your API request.
       * This supports a limited subset of Transaction types.  To refund or void, use the refund endpoint.
       * To `capture` use the `sale` type. If any existing `authorize` transactions are eligible, then they will be captured and the `sale` will be converted to a `capture` type.
       */
      type?: "3ds-authentication" | "sale" | "authorize";
    };
    PayoutRequest: components["schemas"]["CommonTransactionRequest"];
    TransactionGatewayLog: {
      /** The request headers. */
      headers?: string[];
      /** The request URL. */
      url?: string;
      /** The request body. */
      request?: string;
      /** The response body. */
      response?: string;
      /** The request time (miliseconds). */
      duration?: number;
      /** The log entry created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["TransactionLink"][];
    };
    TransactionRefund: {
      /** Refund amount. */
      amount: number;
    };
    TransactionTimeline: {
      /** The Timeline message identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Timeline message type. */
      type?:
        | "amount-adjusted"
        | "blocklist-matched"
        | "bump-offer-accepted"
        | "bump-offer-presented"
        | "bump-offer-rejected"
        | "customer-redirected-offsite"
        | "customer-returned"
        | "dcc-offer-accepted"
        | "dcc-offer-forced"
        | "dcc-offer-presented"
        | "dcc-offer-rejected"
        | "dispute-changed"
        | "dispute-created"
        | "dispute-forfeited"
        | "dispute-lost"
        | "dispute-responded"
        | "dispute-won"
        | "gateway-connection-failed"
        | "gateway-connection-timed-out"
        | "gateway-response-received"
        | "risk-score-changed"
        | "timeline-comment-created"
        | "transaction-abandoned"
        | "transaction-amount-discrepancy-found"
        | "transaction-approved"
        | "transaction-canceled"
        | "transaction-capture-delayed"
        | "transaction-captured"
        | "transaction-declined"
        | "transaction-discrepancy-found"
        | "transaction-initiated"
        | "transaction-reconciled"
        | "transaction-refunded"
        | "transaction-retried"
        | "transaction-rules-processed"
        | "transaction-scheduled-time-changed"
        | "transaction-timeout-resolved"
        | "transaction-voided"
        | "transaction-waiting-gateway";
      /** Shows who or what triggered the Timeline message. */
      triggeredBy?: "rebilly" | "app" | "direct-api";
      /** The message that describes the message details. */
      message?: string;
      extraData?: components["schemas"]["TimelineExtraData"];
      /** Timeline message time. */
      occurredTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** API secret Key. */
    ApiKey: {
      id?: components["schemas"]["ResourceId"];
      /** API key description. */
      description: string;
      /** Type of API key. */
      type?: "secret" | "publishable";
      /** Specify access control list here if creating a restricted API key. Send all matching permission with an empty scope to allow all permissions. */
      acl?: components["schemas"]["Acl"];
      /** API user name. */
      apiUser?: string;
      /** API secret key's value. */
      secretKey?: string;
      /** The API key created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    BroadcastMessage: {
      /** The broadcast message's identifier string. */
      id?: components["schemas"]["ResourceId"];
      /**
       * The filter that will be used on customer selection during the broadcast message processing.
       * The syntax is the same as the `query` filter, without `filter=` prefix.
       * For example: `firstName:John`, `firstName:John;lastName:Doe`, etc.
       * Attention: You should not URL encode the filter value.
       */
      filter?: string;
      /** The title of the messages (this title will appear in reports). */
      title?: string;
      /** The list of messages. */
      messages?: {
        /** The message identifier string. */
        id?: string;
        /** The message version (by default is empty, but if you make multiple versions, you can name or number them to distinguish them). */
        version?: string;
        /**
         * The value for random-weighted picking of a template in the case of a split test.
         * The split test algorithm does not factor localization when making a weighted-random template selection.  Therefore, a version will be selected first, and then after a version is selected a specific localization will be selected.  Take the case where two versions have different locale content -- the locales of the content is not considered when selecting the version.
         */
        weight?: number;
        /**
         * The value for random-weighted picking of a template in the case of a split test.
         * The split test algorithm does not factor localization when making a weighted-random template selection.  Therefore, a version will be selected first, and then after a version is selected a specific localization will be selected.  Take the case where two versions have different locale content -- the locales of the content is not considered when selecting the version.
         */
        templates: {
          /** The sender address. It must be a **verified** address. # todo add a link to help docs on how to verify an email address. */
          from: string;
          /** The message subject. The template placeholders are allowed. */
          subject: string;
          /**
           * The message's text body.
           * Leave empty to use content from "html".
           * The template placeholders are allowed.
           */
          text: string;
          /**
           * The message's html body.
           * Leave empty to use content from "text".
           * The template placeholders are allowed.
           */
          html: string;
          /** The language locale identifier according to [RFC 5646](https://tools.ietf.org/html/rfc5646). */
          locale: string;
        }[];
      }[];
      /** The split test start time. */
      splitTestStartTime?: string;
      /** The start sending time. */
      startSendingTime: string;
      /** The broadcast message's status. */
      status?: "draft" | "sending" | "sent" | "archived";
      /** The broadcast message's created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The broadcast message's updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to the resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    CheckoutFormFixedPlan: {
      /** The plan identifier string. */
      planId: components["schemas"]["ResourceId"];
      /** If `variable` customers will be able to choose the quantity. */
      type: "fixed";
      /** The quantity. */
      quantity: number;
    };
    CheckoutFormVariablePlan: {
      /** The plan identifier string. */
      planId: components["schemas"]["ResourceId"];
      /** If `variable` customers will be able to choose the quantity. */
      type: "variable";
      /** The default quantity. */
      quantity: number;
      /** The minimum quantity. */
      minimum?: number;
      /** The step quantity. */
      multipleOf?: number;
      /** The maximum quantity. */
      maximum?: number;
    };
    CheckoutFormPlan:
      | components["schemas"]["CheckoutFormFixedPlan"]
      | components["schemas"]["CheckoutFormVariablePlan"];
    CheckoutFormPlans: components["schemas"]["CheckoutFormPlan"][];
    CommonCheckoutForm: {
      /** The checkout form identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Checkout form website ID. */
      websiteId: string;
      /** The list of plans that would be applied to customer order by default. */
      plans: components["schemas"]["CheckoutFormPlans"];
      /**
       * The list of independent addons.
       * Customer will be able to select whether to add the plans from the list or not.
       */
      addonPlans?: components["schemas"]["CheckoutFormPlans"];
      /**
       * The list of plans that can be used instead of ones specified in `plans`.
       * Customer will be able to select whether to purchase bump plans or the regular ones.
       */
      bumpPlans?: components["schemas"]["CheckoutFormPlans"];
      /** If `true` customer will be able to sign-up and sign-in using the form. */
      accountsEnabled?: boolean;
      /** If `true` customer will be able to use coupons on the form. */
      couponsEnabled?: boolean;
      /** If the purchase limit is set  every purchase will decrease it. Zero purchase limit will make form inactive. */
      purchaseLimit?: number | null;
      /**
       * The list of available payment methods. Only payment methods with at least one active gateway account are allowed.
       * If not specified all available payment methods will be displayed.
       */
      paymentMethods?: components["schemas"]["PaymentMethod"][];
      /** Visual customization options for the form. */
      customization?: {
        /** Linked file object ID. */
        logoId?: components["schemas"]["ResourceId"];
        /** Summary text. */
        summary?: string;
        /** You can use placeholder `{{amount}}` to substitute with the form total. */
        buttonText?: string;
        /** Control the primary color used in the form and button text. */
        colors?: {
          /** Primary color for the form in hexadecimal format. */
          primary?: string;
          /** Button text color for the form in hexadecimal format. */
          buttonText?: string;
        };
        /** Various urls that appear on the form. */
        links?: {
          /** The url to the website refund policy. */
          refundPolicy?: string;
          /** The url to the website privacy policy. */
          privacyPolicy?: string;
          /** The url to the website terms of service. */
          termsOfService?: string;
        };
        /** Various tracking system identifier strings. */
        tracking?: {
          /** The Google Analytics tracking identifier string. */
          googleAnalytics?: string;
          /** The Google Tag Manager tracking identifier string. */
          googleTagManager?: string;
          /** The Facebook Pixel tracking identifier string. */
          facebookPixel?: string;
          /** The Segment Analytics tracking identifier string. */
          segmentAnalytics?: string;
          /** The Heap.io tracking identifier string. */
          heapIo?: string;
        };
      };
      /** Checkout form created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Checkout form updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    CheckoutForm: components["schemas"]["CommonCheckoutForm"] & {
      /** Checkout form name, used for internal display to help you organize your various checkout forms. Will not be displayed to your customers. */
      name: string;
      /** If `inactive`, the checkout form url will result in a 404. */
      status?: "active" | "inactive";
    };
    "Credential-2": {
      hash?: components["schemas"]["ResourceId"];
      /** The credential status. */
      status?: "active" | "deactivated";
      /** The time when the credential was deactivated. */
      deactivationTime?: components["schemas"]["ServerTimestamp"];
    };
    SESCredential: components["schemas"]["Credential-2"] & {
      /** The AWS access key ID. */
      key: string;
      /** The AWS secret access key. */
      secret: string;
      /** The AWS region name. */
      region: string;
      /** The configuration set name which will be used durring email sending. */
      configurationSetName?: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    PatchCredential: {
      /** The credential status. */
      status: "deactivated";
    };
    SmtpAuthorization: {
      type?: "none" | "plain" | "login" | "cram-md5";
    };
    SmtpAuthorizationNone: components["schemas"]["SmtpAuthorization"];
    UserPasswordAuthorization: {
      username: string;
      password: string;
    };
    "cram-md5": components["schemas"]["SmtpAuthorization"] &
      components["schemas"]["UserPasswordAuthorization"];
    login: components["schemas"]["SmtpAuthorization"] &
      components["schemas"]["UserPasswordAuthorization"];
    plain: components["schemas"]["SmtpAuthorization"] &
      components["schemas"]["UserPasswordAuthorization"];
    SmtpCredential: components["schemas"]["Credential-2"] & {
      /** The host name. */
      host: string;
      /** The port value. */
      port?: number;
      /** The encryption value. */
      encryption?: "none" | "tls" | "ssl";
      auth?: components["schemas"]["SmtpAuthorization"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    MailgunCredential: components["schemas"]["Credential-2"] & {
      hash?: components["schemas"]["ResourceId"];
      /** The from email address. */
      emailFrom: string;
      /** The mailgun api key. */
      apiKey: string;
      /** The mailgun domain. */
      domain: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    OAuth2CredentialService: "google-sheets";
    OAuth2Credential: components["schemas"]["Credential-2"] & {
      /** The name of service that the OAuth2 credential belongs to. */
      service: components["schemas"]["OAuth2CredentialService"];
      /** The OAuth2 code provided by the authentication server. */
      code: string;
      /** The OAuth2 access token. */
      accessToken?: string;
      /** The OAuth2 refresh token. */
      refreshToken?: string;
      /** The OAuth2 granted list access. */
      scopes: string[];
      /** The links related to resource. */
      _links?: Partial<components["schemas"]["SelfLink"]>[];
    };
    GoogleSpreadsheet: {
      /** The google spreadsheet indentifier string. */
      id?: string;
      /** The google spreadsheet name. */
      name?: string;
    };
    PlaidCredential: components["schemas"]["Credential-2"] & {
      /**
       * The website assigned to this Plaid account.
       * If not set, credentials will be used for any website.
       */
      websiteId?: components["schemas"]["ResourceId"];
      /** The Plaid client ID. */
      clientId: string;
      /** The Plaid secret token. */
      secretToken: string;
      /**
       * Whether the Stripe integration is enabled for Plaid account.
       * This setting will enable creating Stripe bank account tokens.
       */
      useStripe?: boolean;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    PostmarkCredential: components["schemas"]["Credential-2"] & {
      /** The Postmark server API token. */
      serverApiToken: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    SendGridCredential: components["schemas"]["Credential-2"] & {
      /** The SendGrid api key. */
      apiKey: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    WebhookAuthorization: {
      /** The authorization type. */
      type: "none" | "basic" | "digest" | "oauth1";
    };
    WebhookAuthorizationNone: components["schemas"]["WebhookAuthorization"];
    basic: components["schemas"]["WebhookAuthorization"] & {
      username: string;
      password: string;
    };
    digest: components["schemas"]["WebhookAuthorization"] & {
      username: string;
      password: string;
    };
    oauth1: components["schemas"]["WebhookAuthorization"] & {
      consumerKey: string;
      consumerSecret: string;
      token: string;
      tokenSecret: string;
    };
    WebhookCredential: components["schemas"]["Credential-2"] & {
      /** The host name. */
      host: string;
      auth?: components["schemas"]["WebhookAuthorization"];
    };
    ExperianCredential: components["schemas"]["Credential-2"] & {
      /** Username on the Experian side. */
      username: string;
      /** Password on the Experian side. */
      password: string;
      /** HMAC key to generate the signature for Experian requests. */
      hmacKey: string;
      /** HMAC public key to include into the signature for Experian requests. */
      publicKey: string;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    EmailDeliverySetting: {
      /** The email delivery setting's identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The sender's email address.  It must be unique within your account. */
      from: string;
      /** The sender's name. */
      name: string;
      /** The email message's status. */
      status?: "pending" | "verified";
      /** SMTP or any Email Service Provider credential identifier string. */
      credentialId?: string;
      /** The service provider name. */
      provider?:
        | "rebilly"
        | "smtp"
        | "aws-ses"
        | "mailgun"
        | "postmark"
        | "sendgrid";
      /** Whether this setting will be used by default or not. */
      isDefault?: boolean;
      /** The created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
    };
    EmailMessage: {
      /** The email message's identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The email message's status. */
      status?: "draft" | "outbox" | "sending" | "sent" | "failed";
      /** The email message's metadata. */
      metadata?: { [key: string]: string };
      /** SMTP or any Email Service Provider credential identifier string. */
      credentialHash?: string;
      /** The email message's sender address. */
      from: string;
      /** The email message's recipients address list. */
      to: string[];
      /** The email message's CC address list. */
      cc?: string[];
      /** The email message's BCC address list. */
      bcc?: string[];
      /** The email message's subject. */
      subject: string;
      /** The email message's text body. */
      text: string;
      /** The email message's html body. */
      html: string;
      /** The email message's attachemnts. */
      attachments?: {
        /** The attachment's resource type. */
        resourceType: string;
        /** The attachment's resource identifier string. */
        resourceId: components["schemas"]["ResourceId"];
      }[];
      /** The email message's created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The email message's updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to the resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Rebilly event type. */
    EventType:
      | "account-password-reset-requested"
      | "account-verification-requested"
      | "aml-list-possibly-matched"
      | "customer-created"
      | "customer-one-time-password-requested"
      | "dispute-created"
      | "experian-check-performed"
      | "gateway-account-downtime-ended"
      | "gateway-account-downtime-started"
      | "gateway-account-limit-reached"
      | "gateway-account-requested"
      | "invoice-issued"
      | "invoice-paid"
      | "invoice-past-due"
      | "invoice-past-due-reminder"
      | "kyc-document-accepted"
      | "kyc-document-rejected"
      | "nsf-response-received"
      | "order-completed"
      | "payment-card-created"
      | "payment-card-expiration-reminder"
      | "payment-card-expired"
      | "ready-to-pay-requested"
      | "renewal-invoice-issued"
      | "renewal-invoice-payment-canceled"
      | "renewal-invoice-payment-declined"
      | "risk-score-changed"
      | "subscription-activated"
      | "subscription-canceled"
      | "subscription-created"
      | "subscription-modified"
      | "subscription-reactivated"
      | "subscription-renewal-reminder"
      | "subscription-renewed"
      | "subscription-trial-converted"
      | "subscription-trial-end-reminder"
      | "subscription-trial-end-changed"
      | "transaction-amount-discrepancy-found"
      | "transaction-declined"
      | "transaction-discrepancy-found"
      | "transaction-process-requested"
      | "transaction-processed";
    /** The email notification event. */
    EmailNotification: {
      eventType?: components["schemas"]["EventType"];
      /** The count of binds with `send-email` actions per event. */
      count?: number;
      /** The list of notifications. */
      notifications?: {
        /** The notification labels. */
        labels?: string[];
        /** The notification title. */
        title?: string;
      }[];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** The application event. */
    SystemEvent: {
      eventType?: components["schemas"]["EventType"];
      title?: string;
      description?: string;
      /** The event system category it belongs to. */
      category?: "billing" | "payments";
      rulesCount?: number;
      bindsCount?: number;
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    OnOff: "active" | "inactive";
    RuleAction: {
      /** The action name. */
      name:
        | "add-risk-score"
        | "adjust-ready-to-pay"
        | "blocklist"
        | "cancel-scheduled-payments"
        | "create-infusionsoft-order"
        | "create-infusionsoft-payment"
        | "display-other-choices"
        | "guess-payment-card-expiration"
        | "offer-purchase-bump"
        | "perform-experian-check"
        | "pick-gateway-account"
        | "remove-reminder"
        | "request-kyc"
        | "reset-reminder"
        | "schedule-invoice-retry"
        | "schedule-payment"
        | "schedule-payment-retry"
        | "schedule-reminder"
        | "send-email"
        | "stop-subscriptions"
        | "tag-or-untag-customer"
        | "trigger-webhook";
      status?: components["schemas"]["OnOff"];
    };
    "add-risk-score": components["schemas"]["RuleAction"] & {
      score?: number;
    };
    "adjust-ready-to-pay": components["schemas"]["RuleAction"] & {
      /**
       * If set as `true`, the payment methods associated to the customer's active payment instruments will be displayed at
       * the top of the list.
       */
      prioritizeActivePaymentInstruments?: boolean;
      /** An ordered list of payment methods allowed. If empty  none are allowed. */
      paymentMethods?: (
        | {
            paymentMethod?: "payment-card";
            feature?: ("Google Pay" | "Apple Pay") | null;
          }
        | {
            paymentMethod?: "ach";
            feature?: "Plaid" | null;
          }
        | {
            paymentMethod?: components["schemas"]["TokenPaymentMethod"];
            feature?: { [key: string]: any } | null;
          }
      )[];
    };
    /** Add customer data to blocklist. */
    blocklist: components["schemas"]["RuleAction"] & {
      type:
        | "customer-id"
        | "email"
        | "fingerprint"
        | "ip-address"
        | "payment-card";
      /** Blocklist TTL. Defaults to zero, meaning blocklist record won't expire ever. */
      ttl?: number;
    };
    "cancel-scheduled-payments": components["schemas"]["RuleAction"];
    /** Create a Keap Infusionsoft order along with a contact. */
    "create-infusionsoft-order": components["schemas"]["RuleAction"] & {
      /** The list of contact attributes that will be used during Keap Infusionsoft creation process. */
      contactBody: {
        /** The contact email addresses that will be used during Keap Infusionsoft creation process. */
        email_addresses?: {
          /** The contact email address that will be used during Keap Infusionsoft creation process. */
          email?: string;
          /** The contact email field type that will be used during Keap Infusionsoft creation process. */
          field?: "EMAIL1" | "EMAIL2" | "EMAIL3";
        }[];
        /** The contact phone numbers that will be used during Keap Infusionsoft creation process. */
        phone_numbers?: {
          /** The contact phone number that will be used during Keap Infusionsoft creation process. */
          number?: string;
          /** The contact phone field type that will be used during Keap Infusionsoft creation process. */
          field?: "PHONE1" | "PHONE2" | "PHONE3" | "PHONE4" | "PHONE5";
        }[];
      };
      /** The list of order attributes that will be used during Keap Infusionsoft creation process except `contact_id`. */
      orderBody: {
        /** The order date that will be used during Keap Infusionsoft creation process. */
        order_date: string;
        /** The order title that will be used during Keap Infusionsoft creation process. */
        order_title: string;
        /** The order type that will be used during Keap Infusionsoft creation process. */
        order_type: "Offline" | "Online";
      };
      /** OAuth2 credential identifier string. */
      credentialHash: string;
    };
    /** Create a Keap Infusionsoft payment. */
    "create-infusionsoft-payment": components["schemas"]["RuleAction"] & {
      /** The list of payment attributes that will be used during Keap Infusionsoft creation process. */
      paymentBody?: { [key: string]: any };
      /** OAuth2 credential identifier string. */
      credentialHash: string;
    };
    /** Display Other Choices. */
    "display-other-choices": components["schemas"]["RuleAction"] & {
      choices: {
        /** Language (two letter ISO 639-1 code). */
        langIso: string;
        content: string;
      }[];
    };
    "guess-payment-card-expiration": components["schemas"]["RuleAction"];
    PurchaseBumpOfferContent: {
      langIso: components["schemas"]["LanguageIsoCode"];
      content: string;
    };
    PurchaseBumpSplitVersion: {
      name: components["schemas"]["PurchaseBumpSplitVersionName"];
      /** Bump offer weight. */
      weight: number;
      offers: components["schemas"]["PurchaseBumpOfferList"];
      choices: components["schemas"]["PurchaseBumpOfferContent"][];
    };
    PurchaseBump: {
      bumpOffers?: components["schemas"]["PurchaseBumpSplitVersion"][];
    };
    /** Offer Purchase Bump. */
    "offer-purchase-bump": components["schemas"]["RuleAction"] &
      components["schemas"]["PurchaseBump"] & { [key: string]: any };
    /** Perform Experian ProveID check on the customer. */
    "perform-experian-check": components["schemas"]["RuleAction"] & {
      /** Hash of the Experian credential to use for performing the check. */
      experianCredentialHash: string;
      /** A tag ID that should be used to tag the customer when the identity matches Experian records. */
      tagOnApprove?: string;
      /** A tag ID that should be used to tag the customer when the identity doesn't match Experian records. */
      tagOnReject?: string;
      /** A tag ID that should be used to tag the customer when the identity is not found in Experian records or further analysis needed. */
      tagOnUnknown?: string;
    };
    GatewayAccountPickInstruction: {
      /**
       * Controls the picking strategy for gateway accounts.
       * The weighted-random strategy will pick based on weighted-random every time.
       * The round-robin strategy will try a weighted-random different gateway account for consecutive attempts from same payment instrument.
       */
      strategy?: "weighted-random" | "round-robin";
      method: "gateway-account-weights" | "gateway-acquirer-weights";
    };
    "gateway-account-weights": components["schemas"]["GatewayAccountPickInstruction"] & {
      weightedList: {
        gatewayAccountId: components["schemas"]["ResourceId"];
        weight: number;
      }[];
    };
    "gateway-acquirer-weights": components["schemas"]["GatewayAccountPickInstruction"] & {
      weightedList: {
        gatewayName: components["schemas"]["GatewayName"];
        acquirerName: components["schemas"]["AcquirerName"];
        weight: number;
      }[];
    };
    "pick-gateway-account": components["schemas"]["RuleAction"] & {
      pickInstruction: components["schemas"]["GatewayAccountPickInstruction"];
    };
    "remove-reminder": components["schemas"]["RuleAction"] & {
      /** The role of Reminder (available only on Order events, other events should use `all`). */
      role: "all" | "renewal" | "trial-end";
    };
    /** Request KYC page to verify customer identity. */
    "request-kyc": components["schemas"]["RuleAction"] & {
      /** Who should be excluded from the verification. */
      excludePolicy:
        | "customers-with-accepted-document"
        | "customers-with-document"
        | "none";
      /** Is the verification mandatory. */
      isMandatory: boolean;
      /** When to prompt, before or after processing the transaction. */
      promptPolicy: "before-transaction-process" | "after-transaction-process";
      /** What to do if verification is before transaction processing, and is rejected. */
      rejectedBeforeTransactionProcessPolicy:
        | "process-transaction"
        | "decline"
        | "use-alternate-gateway";
      /** Gateway account to use if use-alternate-gateway is selected for rejectedBeforeTransactionProcessPolicy. */
      alternateGatewayAccountIfRejected?: string;
      /** What to do if verification is after transaction processing, and is rejected. */
      rejectedAfterTransactionProcessPolicy: "proceed";
      /** What to do if verification is optional. */
      optionalPolicy: "allow-bypass" | "allow-use-alternate-gateway";
      /** Gateway account to use if allow-use-alternate-gateway is selected for optionalPolicy. */
      alternateGatewayAccountIfOptional?: string;
      /** The currency three letter code to display on the bypass link, if optional. */
      bypassCurrencyToDisplay?: string;
      /** Maximum number of verification attempts per transaction. */
      maxAttempts?: number;
    };
    "reset-reminder": components["schemas"]["RuleAction"] & {
      /** The role of Reminder (available only on Order events, other events should use `all`). */
      role: "all" | "renewal" | "trial-end";
    };
    /** Schedule an invoice retry. */
    "schedule-invoice-retry": components["schemas"]["RuleAction"] & {
      attempts: {
        scheduleInstruction: components["schemas"]["InvoiceRetryScheduleInstruction"];
      }[];
      /** The policy on the attempt finishes. */
      afterAttemptPolicies: "change-subscription-renewal-time"[];
      /** The policy on the retry ends. */
      afterRetryEndPolicies: ("abandon-invoice" | "cancel-subscription")[];
      /** Whether to replace the existing retry or not. */
      overrideRetryInstruction: boolean;
    };
    "schedule-payment-retry": components["schemas"]["RuleAction"] &
      components["schemas"]["PaymentRetry"];
    "schedule-payment": components["schemas"]["RuleAction"] & {
      scheduleInstruction: components["schemas"]["CommonScheduleInstruction"];
      amountPolicy: "invoice-amount-due";
    };
    /** The calculation instruction of scheduled time. */
    ReminderScheduleInstruction: {
      method: "date-interval" | "day-of-month" | "day-of-week";
    };
    /** Schedule Instructions Collection. */
    ReminderSchedule: {
      instructions: components["schemas"]["ReminderScheduleInstruction"][];
      chronology: "before" | "after";
    };
    "schedule-reminder": components["schemas"]["RuleAction"] & {
      /** The role of Reminder (available only on Order events, other events should use `all`). */
      role: "all" | "renewal" | "trial-end";
      schedule?: components["schemas"]["ReminderSchedule"];
    };
    RulesEmailNotification: {
      /** The message identifier string. */
      id?: string;
      /** The message version (useful for split tests). By default is empty, but if you make multiple versions, you can name or number them to distinguish them. */
      version?: string;
      /**
       * The value for random-weighted picking of a template in the case of a split test.
       * The split test algorithm does not factor localization when making a weighted-random template selection.  Therefore, a version will be selected first, and then after a version is selected a specific localization will be selected.  Take the case where two versions have  different locale content -- the locales of the content is not considered when selecting the version.
       */
      weight?: number;
      /**
       * An array of message templates with the language locale identifiers according to [RFC 5646](https://tools.ietf.org/html/rfc5646). A language will be selected based on the customer's locale.
       *
       * If there is no locale set for the customer, then `en-US` (US English) will be used as the locale.
       *
       * If there is no template with the customer's locale,  then a template locale will be selected by Rebilly using a closest match algorithm (which may be random at worst).
       *
       * If your email message templates are localized into more than one language,  you SHOULD set a customer locale.
       *
       * An invalid placeholder will render to an empty string. For example, `Hello {{invalid.placeholder}}!`  will be rendered to `Hello !`.
       */
      templates: {
        /** The language locale identifier according to [RFC 5646](https://tools.ietf.org/html/rfc5646). */
        locale: string;
        /** The sender address. Template placeholders are allowed.  If a placeholder does not resolve to a **verified** from address, then the default verified from address will be used instead.   # todo add a link to help docs on how to verify an email address. */
        from: string;
        /** The recipients addresses. Template placeholders are allowed. If a placeholder does not resolve to an email address, then no email will be sent. */
        to: string[];
        /** The recipients to be carbon copied addresses. Template placeholders are allowed. If a placeholder does not resolve to an email address, then they will not be added to the cc. */
        cc?: string[];
        /** The blind carbon copy recipients addresses. Template placeholders are allowed. If a placeholder does not resolve to an email address, then they will not be added to the cc. */
        bcc?: string[];
        /** The message subject. Template placeholders are allowed. */
        subject: string;
        /**
         * The message's text body.
         * Leave empty to use content from "html".
         * Template placeholders are allowed.
         */
        text: string;
        /**
         * The message's html body.
         * Leave empty to use content from "text".
         * Template placeholders are allowed.
         */
        html: string;
        /**
         * The source of the message required for the email editor.
         * Not used for sending emails.
         * Used by the editor to reproduce the message for future updates.
         */
        editor?: string;
        /** The message's attachments. */
        attachments?: {
          /** The attachment's resource type. */
          resourceType: string;
          /** The attachment's resource identifier string. Template placeholders are allowed. */
          resourceId: string;
        }[];
      }[];
    };
    "send-email": components["schemas"]["RuleAction"] & {
      /** The action identifier string. */
      id?: string;
      /** The title of the messages (this title will appear in reports). */
      title?: string;
      /** The list of messages. */
      emails: components["schemas"]["RulesEmailNotification"][];
      /** The split test start time. */
      splitTestStartTime?: string;
    };
    /** Stop active subscriptions. */
    "stop-subscriptions": components["schemas"]["RuleAction"];
    /** Tag or untag a customer with specified list of tags. */
    "tag-or-untag-customer": components["schemas"]["RuleAction"] & {
      /** The list of tag ID customer should be tagged with. */
      addingTags: string[];
      /** The list of tag ID customer should be untagged from. */
      removingTags: string[];
    };
    WebhookHeader: {
      name: string;
      status?: components["schemas"]["OnOff"];
      value: string;
    };
    Webhook: {
      method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
      url: string;
      /** The URI parameters. */
      query?: { [key: string]: string };
      body?: string;
      /** Webhook Credential identifier string. */
      credentialHash?: string;
      headers?: components["schemas"]["WebhookHeader"][];
    };
    "trigger-webhook": components["schemas"]["RuleAction"] &
      components["schemas"]["Webhook"];
    /** The rule. */
    Bind: {
      name: string;
      labels?: string[];
      status?: components["schemas"]["OnOff"];
      /** The filter requires a special format. Use "," for multiple allowed values. Use ";" for multiple fields. */
      filter?: string;
      actions: components["schemas"]["RuleAction"][];
    };
    Rule: components["schemas"]["Bind"] & {
      /** Whether rule is final, meaning stop further matching rules if this is matched. */
      final?: boolean;
    };
    /** Set of rules for particular event. */
    RuleSet: {
      version?: number;
      binds?: components["schemas"]["Bind"][];
      rules: components["schemas"]["Rule"][];
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    RuleSetHistoryLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "history";
    };
    RuleSetVersionLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "rules";
    };
    /** Version of rules. */
    RuleSetHistoryItem: {
      version?: number;
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to a resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["RuleSetHistoryLink"]> &
        Partial<components["schemas"]["RuleSetVersionLink"]>)[];
    };
    /** Version of rules. */
    RuleSetVersion: {
      version?: number;
      binds?: components["schemas"]["Bind"][];
      rules?: components["schemas"]["Rule"][];
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    ForgotPassword: {
      /** Email. */
      email: string;
    };
    GatewayAccountDowntimeSchedule: {
      /** The gateway account downtime schedule identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The gateway account downtime schedule status. */
      status?: "pending" | "ongoing" | "finished";
      /** The gateway account downtime schedule reason. */
      reason?:
        | "scheduled-maintenance"
        | "daily-limit-reached"
        | "monthly-limit-reached";
      /** The gateway account scheduled downtime start time. */
      startTime: string;
      /** The gateway account scheduled downtime end time. */
      endTime: string;
      /** Gateway downtime schedule created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Gateway downtime schedule updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    GatewayAccountLimit: {
      /** The gateway account limit identifier. */
      id?: components["schemas"]["ResourceId"];
      /** The gateway account limit status. */
      status?: "monitoring" | "reached";
      /** The limit's current period start time. */
      startTime?: string;
      /** The limit's current period end time. At this time, the limit will reset. */
      endTime?: string;
      /** The limit's period will reset according to the frequency. */
      frequency?: "daily" | "monthly";
      /**
       * The limit can be on `money` or `count` of transactions.
       * If `money` is chosen, the currency is the report currency.
       */
      type?: "count" | "money";
      /**
       * The limit's value cap is the maximum desired value.
       * If type is money, the currency is the report currency.
       * The cap only applies to approved transactions of type `authorize` or `sale`.
       */
      cap: number;
      /** The limit's actual usage during this period. */
      usage?: number;
      /** Gateway account limit created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Gateway account limit updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    GatewayAccountTimeline: {
      /** The Timeline message identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Timeline message type. */
      type?:
        | "gateway-account-created"
        | "gateway-account-changed"
        | "gateway-account-enabled"
        | "gateway-account-disabled"
        | "gateway-account-down"
        | "gateway-account-up"
        | "gateway-account-closed"
        | "gateway-account-limit-reached"
        | "gateway-account-limit-reset";
      /** Shows who or what triggered the Timeline message. */
      triggeredBy?: "rebilly" | "app" | "direct-api";
      /** The message that describes the message details. */
      message?: string;
      extraData?: components["schemas"]["TimelineExtraData"];
      /** Timeline message time. */
      occurredTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Segment: {
      /** ID of current Segment. */
      id?: string;
      /** Owner (creator) of Segment. */
      owner: {
        /** User ID. */
        id?: string;
        /** First and last name. */
        name?: string;
      };
      /**
       * An object containing schema to set up the UI for the segment. This schema is built
       * and consumed by the frontend. It includes such information as Segment name, UI settings, etc.
       */
      data: { [key: string]: any };
      /** Toggle whether this Segment is starred by the current user. */
      isStarred?: boolean;
      /** Toggle whether this Segment is visible to the current user. */
      isVisible?: boolean;
      /** A list of user id's with whom to share, used if scope is set to `shared`. */
      userIds?: components["schemas"]["ResourceId"][];
      /**
       * A list of user's id and first and last names with whom this Segment
       * is shared.
       */
      users?: {
        /** User ID. */
        id?: string;
        /** First and last name. */
        name?: string;
      }[];
      /**
       * If `private`, then only the owner/creator can view this Segment. If set
       * to `public`, then it's shared with anyone in the owner's organization.
       * If set to `shared`, then it is only shared with specific users as specified
       * in the `userIds` field.
       */
      scope: "private" | "public" | "shared";
      /**
       * If the Segment is based off of a system Segment, this will be the id of the system Segment from which it was
       * derived. The scope must be `private` when providing this in the request.
       */
      systemId?: string;
    };
    OAuth2ConnectLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "oauth2Connect";
    };
    Integration: {
      /** The integration service. */
      service?: components["schemas"]["OAuth2CredentialService"];
      /** The number of available rule sets. */
      count?: number;
      /** The list of configurations. */
      configurations?: {
        /** The configuration labels. */
        labels?: string[];
        eventType?: components["schemas"]["EventType"];
        /** The configuration title. */
        title?: string;
      }[];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["OAuth2ConnectLink"]>)[];
    };
    List: {
      /** List ID. */
      id?: components["schemas"]["ResourceId"];
      /** List version. */
      version?: number;
      /** List description. */
      description: string;
      /** List values. */
      values: string[];
      /** List created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** List updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Send a test email. */
    SendTestEmail: components["schemas"]["RulesEmailNotification"];
    /** Trigger a test webhook. */
    SendPreviewWebhook: components["schemas"]["Webhook"];
    /** Rebilly webhooks event type. */
    GlobalWebhookEventType:
      | "aml-list-possibly-matched"
      | "customer-created"
      | "customer-merged"
      | "customer-one-time-password-requested"
      | "customer-updated"
      | "dispute-created"
      | "experian-check-performed"
      | "gateway-account-downtime-ended"
      | "gateway-account-downtime-started"
      | "gateway-account-limit-reached"
      | "gateway-account-requested"
      | "invoice-abandoned"
      | "invoice-created"
      | "invoice-issued"
      | "invoice-modified"
      | "invoice-paid"
      | "invoice-past-due"
      | "invoice-past-due-reminder"
      | "invoice-reissued"
      | "invoice-voided"
      | "kyc-document-accepted"
      | "kyc-document-rejected"
      | "kyc-document-reviewed"
      | "nsf-response-received"
      | "offsite-payment-completed"
      | "order-completed"
      | "payment-card-created"
      | "payment-card-expiration-reminder"
      | "payment-card-expired"
      | "renewal-invoice-issued"
      | "renewal-invoice-payment-canceled"
      | "renewal-invoice-payment-declined"
      | "risk-score-changed"
      | "subscription-activated"
      | "subscription-canceled"
      | "subscription-modified"
      | "subscription-reactivated"
      | "subscription-renewal-reminder"
      | "subscription-renewed"
      | "subscription-trial-converted"
      | "subscription-trial-end-reminder"
      | "subscription-trial-ended"
      | "subscription-trial-end-changed"
      | "transaction-amount-discrepancy-found"
      | "transaction-declined"
      | "transaction-discrepancy-found"
      | "transaction-process-requested"
      | "transaction-processed"
      | "transaction-timeout-resolved"
      | "waiting-gateway-transaction-completed";
    GlobalWebhook: {
      /** The webhook identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** An array of System event type. */
      eventsFilter?: components["schemas"]["GlobalWebhookEventType"][];
      status?: components["schemas"]["OnOff"];
      method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
      /** URL that will be triggered when the given event occurs. */
      url: string;
      headers?: components["schemas"]["WebhookHeader"][];
      /** Hash from Credentials which is used for authentication by the given URL. */
      credentialHash: string;
      /** List created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** List updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Profile: {
      /** The user identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The user email. */
      email?: string;
      /** User's first name. */
      firstName?: string;
      /** User's last name. */
      lastName?: string;
      /** The user business phone number. */
      businessPhone?: string;
      /** The user mobile phone number. */
      mobilePhone?: string;
      /** The user memberships. */
      memberships?: components["schemas"]["Membership"][];
      /** An array of reporting currencies enabled for the merchant. */
      availableCurrencies?: string[];
      /** The user's ISO Alpha-3 code used for reports. */
      reportingCurrency?: string;
      /** The user setting of two-factor authentification. */
      totpRequired?: boolean;
      /** The user TOTP key for authentification app (if TOTP enabled). */
      totpSecret?: string;
      /** The user link to QR-code for TOTP authentification app (if TOTP enabled). */
      totpUrl?: string;
      /**
       * The one time password generated by Google Authenticator (required when enabling/disabling 2FA).
       * Should contain digits only.
       */
      oneTimePassword?: string;
      /** The user country setting - two letter code. */
      country?: string;
      /** User preferences like timezone, language and many more. This is an object with custom properties. */
      preferences?: { [key: string]: any };
      /** True when the current user session has permissions emulation enabled. */
      hasPermissionsEmulation?: boolean;
    };
    UpdatePassword: {
      /** Current user's password - used when requesting password change. */
      currentPassword: string;
      /** New user's password - used when requesting password change. */
      newPassword: string;
    };
    ResetPasswordTokenInfo: {
      /** Token. */
      token?: string;
      /** Creation date/time. */
      sentTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    ResetPassword: {
      /** New password. */
      newPassword: string;
    };
    User: {
      /** The user identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** The user email. */
      email: string;
      /** User's first name. */
      firstName: string;
      /** User's last name. */
      lastName: string;
      /** The user business phone number. */
      businessPhone?: string;
      /** The user mobile phone number. */
      mobilePhone?: string;
      /** User's password. If not provided, password reset email will be sent. */
      password?: string;
      /** The user's permissions. See the format in example. Use wildcard `*` for full access. */
      permissions?: components["schemas"]["AclPermissions"];
      /** The user created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The user updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** The user last login time. */
      loginTime?: components["schemas"]["ServerTimestamp"];
      /** The user's ISO Alpha-3 code used for reports. */
      reportingCurrency?: string;
      /** An array of reporting currencies enabled for the merchant. */
      availableCurrencies?: string[];
      /** The user setting of two-factor authentification. */
      totpRequired?: boolean;
      /** The user TOTP key for authentification app (if TOTP enabled). */
      totpSecret?: string;
      /** The user link to QR-code for TOTP authentification app (if TOTP enabled). */
      totpUrl?: string;
      /** The user status. */
      status?: "active" | "inactive" | "pending-confirmation";
      /** The user country setting - two letter code. */
      country?: string;
      /** User preferences like timezone, language and many more. This is an object with custom properties. */
      preferences?: { [key: string]: any };
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** The email notification send through attribution. */
    SendThroughAttribution: {
      eventType?: components["schemas"]["EventType"];
      /** The email notification action's identifier number. */
      actionId?: string;
      /** The email notification version's identifier number. */
      versionId?: string;
      /** The email notification send number. */
      sent?: number;
      /** The email notification goal number. */
      goal?: number;
    };
    Signin: {
      /** Email. */
      email: string;
      /** Password. */
      password: string;
      /** One time password for 2 factor authentication. Should contain digits only. */
      oneTimePassword?: string;
      /** Session expired time. Defaults to one hour. */
      expiredTime?: string;
    };
    Signup: {
      /** The user email. */
      email: string;
      /** The user company name. */
      company: string;
      /** The user first name. */
      firstName: string;
      /** The user last name. */
      lastName: string;
      /** The user business phone number. */
      businessPhone: string;
      /** The user password. */
      password: string;
      /** The user website address. */
      website: string;
      /** The user country (ISO Alpha-2 code). */
      country?: string;
      /** The currency to be set only once which will be used for conversion in reports. */
      reportingCurrency?: string;
    };
    Status: {
      /** The API status. If everything is ok - value is 'ok'. */
      status?: "ok";
      /** Current time. */
      time?: components["schemas"]["ServerTimestamp"];
    };
    /** Tracking API Requests. */
    ApiTracking: {
      id?: components["schemas"]["ResourceId"];
      /** HTTP response code. */
      status?: number;
      /** API request address. */
      url?: string;
      /** API request route. */
      route?: string;
      /** HTTP method. */
      method?: "HEAD" | "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
      /** Request JSON-string. */
      request?: string;
      /** Response JSON-string. */
      response?: string;
      requestHeaders?: { [key: string]: string };
      responseHeaders?: { [key: string]: string };
      /** The user who has made a request. */
      user?: {
        userId?: components["schemas"]["ResourceId"];
        apiKeyId?: components["schemas"]["ResourceId"];
        /** The user email. */
        email?: string;
        /** The user first name. */
        firstName?: string;
        /** The user last name. */
        lastName?: string;
        /** Client IP address. */
        ipAddress?: string;
        /** The software that is acting on behalf of a user. */
        userAgent?: string;
        /** The user device fingerprint hash. */
        fingerprint?: string;
        /** If user from support. */
        isSupport?: boolean;
      };
      /** The IDs of related resources. */
      relatedIds?: {
        customerId?: components["schemas"]["ResourceId"];
        transactionId?: components["schemas"]["ResourceId"];
        tokenId?: components["schemas"]["ResourceId"];
      };
      /** Request duration in milliseconds. */
      duration?: number;
      /** The log created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    /** Webhook tracking lists up to the 1,000 most-recent webhooks delivered. Filters are limited to only the id or the entityId (the core related-entity's id). The results are sorted in reverse chronological order. Sort order may not be further controlled. */
    WebhookTracking: {
      id?: components["schemas"]["ResourceId"];
      eventType?: components["schemas"]["EventType"];
      /** The id of the main entity related to the event type. */
      entityId?: string;
      /** Url where webhook was sent. */
      url?: string;
      /** HTTP method which was used to send webhook. */
      method?: string;
      /** HTTP headers which were used to send webhook. */
      headers?: { [key: string]: string };
      /** HTTP code response. */
      responseCode?: number;
      /** Response body received. */
      responseBody?: string;
      /** Webhook's payload. */
      payload?: string;
      /** The Webhook's source. */
      source?: "webhooks" | "rules";
      /** The Webhook's attempt number. */
      attempt?: number;
      /** Sent time. */
      sentTime?: components["schemas"]["ServerTimestamp"];
      /** Initiated time. */
      initiatedTime?: components["schemas"]["ServerTimestamp"];
      /** The log created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** The links related to resource. */
      _links?: components["schemas"]["SelfLink"][];
    };
    Website: {
      /** The website identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Organization ID. */
      organizationId: components["schemas"]["ResourceId"];
      /** The website name. */
      name: string;
      /** The website domain address. */
      url: string;
      /** The website customer service phone number. */
      servicePhone: string;
      /** The website customer service email address. */
      serviceEmail: string;
      /** Website created time. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Website updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      customFields?: components["schemas"]["ResourceCustomFields"];
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["SelfLink"]> &
        Partial<components["schemas"]["OrganizationLink"]>)[];
    };
    CustomerInformation: {
      /** Currency (three letter ISO 4217 alpha code). For example, USD, EUR. */
      currency?: string;
      /** Sum of all refunded transactions. */
      refundsAmount?: number;
      /** Sum of overall sales and captures that were approved. */
      revenueAmount?: number;
      /** Sum of all disputed transactions. */
      disputesAmount?: number;
    };
    DataExport: {
      /** The export identifier string. */
      id?: components["schemas"]["ResourceId"];
      /** Export name. */
      name: string;
      /** The type of resource being exported (e.g. transactions). */
      resource: "transactions" | "customers" | "subscriptions";
      /** Export result format. */
      format: "csv" | "json" | "json-api" | "xml";
      /** Export request arguments that can be passed to filter and/or sort the result set. See the [arguments guide](https://docs-reconciliation.rebilly.com/getting-started/arguments) for more options and examples. */
      arguments?: {
        /** The collection items filter requires a special format. Use "," for multiple allowed values. Use ";" for multiple fields. */
        filter?: string;
        /** The collection items sort field and order (prefix with "-" for descending sort). */
        sort?: string;
        /** The partial search of the text fields. */
        q?: string;
      };
      /** The date range (can be in relative formats).  If omitted, all time will be included. See the [Date Range guide](https://docs-reconciliation.rebilly.com/getting-started/date-range) for more options and examples. */
      dateRange?: {
        /** Any valid datetime arguments including [relative datetime arguments](http://php.net/manual/en/datetime.formats.php). */
        start: string;
        /** Any valid datetime arguments including [relative datetime arguments](http://php.net/manual/en/datetime.formats.php). */
        end: string;
        /** The field to apply date range to. */
        field?: string;
      };
      /** List of emails to be notified when export is completed. */
      emailNotification?: string[];
      /** List of fields to include in the export.  See supporting documentation for more info.  If omitted, default fields will be included. */
      fields?: string[];
      /** Exports can reoccur according to your own schedule. */
      recurring?: {
        /** RRule RFC 5545 formatted string used for recurring exports. */
        instruction: string;
        /** The date and time when the first recurring scheduled export will occur. Defaults to now. */
        start?: string;
      };
      /** The ID of the User who requested the data export. */
      userId?: string;
      /** The number of records in the export (excluding the header row). */
      recordCount?: number;
      /** The date and time this data export is scheduled to generate a file. */
      scheduledTime?: components["schemas"]["ServerTimestamp"];
      /** The time the data export was requested. */
      createdTime?: components["schemas"]["ServerTimestamp"];
      /** Data export updated time. */
      updatedTime?: components["schemas"]["ServerTimestamp"];
      /** Status of export request. */
      status?: "pending" | "queued" | "processing" | "completed";
      /** The links related to resource. */
      _links?: (Partial<components["schemas"]["LinkSelf"]> &
        Partial<components["schemas"]["LinkUser"]> &
        Partial<components["schemas"]["LinkFileDownload"]> &
        Partial<components["schemas"]["LinkSignedLink"]>)[];
    };
    /** Customers resource type to export. */
    customers: components["schemas"]["DataExport"] & {
      dateRange?: {
        field?: string;
      };
    };
    /** Orders resource type to export. */
    subscriptions: components["schemas"]["DataExport"] & {
      dateRange?: {
        field?: string;
      };
    };
    /** Transactions resource type to export. */
    transactions: components["schemas"]["DataExport"] & {
      dateRange?: {
        field?: string;
      };
    };
    LinkSelf: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "self";
    };
    LinkUser: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "user";
    };
    LinkFileDownload: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "download";
    };
    LinkSignedLink: components["schemas"]["Link"] & {
      /** The link type. */
      rel: "signedLink";
    };
    HistogramData: {
      data?: {
        /** Entry date-time. */
        date?: string;
        /** Entry value. */
        value?: number;
      }[];
    };
    APILogSummary: {
      data?: {
        /** Route string pattern. */
        route?: string;
        /** Total count of requests. */
        total?: number;
        /** Count of GET requests. */
        get?: number;
        /** Count of POST requests. */
        post?: number;
        /** Count of PUT requests. */
        put?: number;
        /** Count of PATCH requests. */
        patch?: number;
        /** Count of DELETE requests. */
        delete?: number;
        /** Count of HEAD requests. */
        head?: number;
        /** Count of OPTIONS requests. */
        options?: number;
      }[];
    };
    CumulativeSubscriptions: {
      data?: {
        /** Date in format YYYY-MM (monthly aggregation) or YYYY-MM-DD (daily aggregation). */
        aggregationValue?: string;
        /** Number of new subscriptions within the aggregation. */
        newCount?: number;
        /** Number of canceled subscriptions within the aggregation. */
        canceledCount?: number;
        /**
         * Number of cumulative subscriptions from the previous aggregation +
         * number of new subscriptions - number of canceled subscriptions within the aggregation.
         */
        cumulativeCount?: number;
      }[];
    };
    DashboardResponse: {
      /** Metric type. */
      metric?:
        | "approvalRate"
        | "salesCount"
        | "salesValue"
        | "refundsValue"
        | "chargebacksCount"
        | "chargebacksValue"
        | "transactionsCount"
        | "redeemedCouponsCount"
        | "newLeadsCount"
        | "newCustomersCount"
        | "appliedCouponsCount"
        | "trialConversionsCount"
        | "trialConversionsRate"
        | "renewalSuccessRate"
        | "renewalsCount"
        | "newTrialsCount"
        | "reactivationsCount"
        | "successfulRetriesCount"
        | "invoicedRevenue"
        | "churnCount"
        | "churnRate"
        | "cancellationsCount"
        | "cancellationsRate"
        | "activeSubscriptionsCount"
        | "newSubscriptionsCount"
        | "upgradesCount"
        | "downgradesCount";
      /** Metric name to display. */
      humanName?: string;
      /** True when the higher value means a better performance thus positive for a merchant, false otherwise. */
      increaseIsGood?: boolean;
      segments?: {
        /** Segment name. */
        name?: string;
        /** Segment value for the given date range. */
        value?: number;
        /** Segment value for the previous date range (relative to the given date range). */
        previousValue?: number;
        /** Human readable segment value (formatted with a currency sign). */
        humanValue?: string;
        /** Ratio of current value per previous value null is infinity. */
        changeRatio?: number;
        /** Human readable change ratio (formatted percentage with a "%" sign), null is infinity. */
        humanChangeRatio?: string;
        timeseries?: {
          /** Entry date-time. */
          date?: string;
          /** Entry value. */
          value?: number;
        }[];
      }[];
    }[];
    DccMarkup: {
      data?: {
        /** Value by which the report provides aggregated data. The date values are displayed as following: Day: YYYY-MM-DD; Month: YYYY-MM. */
        aggregationValue?: string;
        /** Number of selected offers in the aggregation. */
        selectedCount?: number;
        /** Amount of selected offers in the aggregation. */
        selectedSum?: number;
        /** Number of rejected offers in the aggregation. */
        rejectedCount?: number;
        /** Amount of rejected offers in the aggregation. */
        rejectedSum?: number;
        /** Number of offers in the aggregation which weren't selected nor rejected. */
        unknownCount?: number;
        /** Amount of offers in the aggregation which weren't selected nor rejected. */
        unknownSum?: number;
      }[];
    };
    ReportDisputes: {
      data?: {
        /**
         * Selected aggregation field value (defined by query). It can be, for example, website or country.
         * You define it in aggregationField param in query.
         */
        aggregationValue?: string;
        /** Disputes count on Visa. */
        countVisa?: number;
        /** Disputes count / Settled transactions count. */
        ratioCountVisa?: number;
        /** Disputes amount / Settled transactions amount. */
        ratioAmountVisa?: number;
        /** Disputes count on Mastercard. */
        countMastercard?: number;
        /** Disputes count / Settled transactions count. */
        ratioCountMastercard?: number;
        /** Disputes amount / Settled transactions amount. */
        ratioAmountMastercard?: number;
      }[];
    };
    ReportEventsTriggeredSummary: {
      data?: {
        /** System event name. */
        eventName?:
          | "dispute-created"
          | "gateway-account-requested"
          | "transaction-processed"
          | "subscription-canceled"
          | "subscription-renewed"
          | "payment-card-expired"
          | "payment-declined"
          | "transaction-process-requested"
          | "risk-score-changed";
        /** Count of event triggered. */
        count?: number;
      }[];
    };
    ReportRulesMatchedSummary: {
      data?: {
        /** Rule matched name. */
        rule?: string;
        /** Count of matched rule. */
        count?: number;
        /** Transaction approval rate by rule. */
        approvalRate?: number;
      }[];
    };
    FutureRenewals: {
      data?: {
        /** Date in format YYYY-MM. */
        date?: string;
        /** Amount of future renewals in user's reporting currency. */
        sum?: number;
        plansCount?: {
          /** Plan identifier. */
          planId?: components["schemas"]["ResourceId"];
          /** Amount of plan's future renewals. */
          count?: number;
        }[];
      }[];
    };
    RenewalSales: {
      data?: {
        /** Date in format YYYY-MM. */
        aggregationValue?: string;
        /** Amount of new sales. */
        newSales?: number;
        /** Amount of new refunds. */
        newRefunds?: number;
        /** Amount of renewal sales. */
        renewalSales?: number;
        /** Amount of renewal refunds. */
        renewalRefunds?: number;
      }[];
    };
    ReportRetentionPercentage: {
      data?: {
        /**
         * Value by which the report provides retention periods and percentages.
         * The date values are displayed as following:
         * Day: YYYY-MM-DD;
         * Month: YYYY-MM;
         * Quarter: YYYY-MM/YYYY-MM;
         * Year: YYYY.
         */
        aggregationValue?: string;
        /** Number of subscriptions created within the aggregation. */
        subscriptionsCount?: number;
        periods?: {
          /** Retention period (0 - first, 1 - second etc) since the beginning boundary of the aggregation. */
          period?: number;
          /** Ratio % of remaining subscriptions (not canceled) at the moment of retention period to all subscriptions created in the aggregation period. */
          retentionRatio?: number;
          /** Number of canceled subscriptions within the given retention period. */
          canceledSubscriptionsCount?: number;
        }[];
      }[];
    };
    ReportRetentionValue: {
      data?: {
        /**
         * Value by which the report provides retention periods and values. The date values are displayed as following:
         * Day: YYYY-MM-DD;
         * Month: YYYY-MM;
         * Quarter: YYYY-MM/YYYY-MM;
         * Year: YYYY.
         */
        aggregationValue?: string;
        /** Number of customers within the aggregation with their first payment. */
        customersCount?: number;
        periods?: {
          /** Retention period (0 - first, 1 - second etc) since the beginning boundary of the aggregation. */
          period?: number;
          /** Summary amount of all transactions for all periods up to the current one divided by the aggregation customers number. */
          retentionAverage?: number;
          /** The number of transactions happened in the retention period (e.g. in 3 rebills). */
          transactionsCount?: number;
          /** The amount of transactions (income transactions - loss transactions). */
          transactionsValue?: number;
        }[];
      }[];
    };
    ReportPaymentRetry: {
      data?: {
        /** Retry attempts number. */
        retryNumber?: number;
        /** Attempts count. */
        attempts?: number;
        /** Successful transactions count. */
        successfulTransactions?: number;
        /** Successful transactions ratio. */
        successRate?: number;
      }[];
    };
    SubscriptionCancellationReport: {
      data?: {
        /** Aggregation value. */
        aggregationValue?: string;
        /** Count of canceled subscriptions. */
        count?: number;
        /** Average length of canceled subscription from start to end within the aggregation in seconds. */
        averageLength?: number;
        /** Median length of canceled subscription from start to end within the aggregation in seconds. */
        medianLength?: number;
      }[];
    };
    SubscriptionRenewal: {
      data?: {
        /** Plan identifier for which subscriptions are counted. */
        planId?: components["schemas"]["ResourceId"];
        /** All renewed subscriptions number. */
        allRenewalCount?: number;
        /** All dunned subscriptions number. */
        allDunningCount?: number;
        /** Abandon subscriptions number. */
        abandonedCount?: number;
        /** Number of paid renewed subscriptions. Divide by allRenewalCount to know the renewal success rate. */
        paidRenewalCount?: number;
        /** Number of paid dunned subscriptions. Divide by allDunningCount to know the dun success rate. */
        paidDunningCount?: number;
        /** Number of paid renewed subscriptions. Divide by allRenewalCount to know the renewal refund rate. */
        refundedRenewalCount?: number;
        /** Number of paid dunned subscriptions. Divide by allDunningCount to know the dun refund rate. */
        refundedDunningCount?: number;
        /** Number of paid renewed subscriptions. Divide by allRenewalCount to know the renewal chargeback rate. */
        chargebackRenewalCount?: number;
        /** Number of paid dunned subscriptions. Divide by allDunningCount to know the dun chargeback rate. */
        chargebackDunningCount?: number;
      }[];
    };
    TimeSeriesTransaction: {
      data?: {
        /** Date in format YYYY-MM-DD. */
        date?: string;
        /** Amount or count of all transactions within the aggregation. */
        total?: number;
        /** Subaggregates which have appropriate transactions within the range. */
        subaggregates?: {
          /** Subaggregate identifier. */
          subaggregate?: string;
          /** Amount or count of the subaggregate's transactions within the aggregation. */
          value?: number;
        };
      }[];
    };
    ReportDisputeDelays: {
      data?: {
        /**
         * Selected aggregation field value (defined by query). It can be, for example, website or country.
         * You define it in aggregationField param in query.
         */
        aggregationFieldValue?: string;
        /** 25th percentile. */
        "25th"?: number;
        /** 50th percentile. */
        "50th"?: number;
        /** 75th percentile. */
        "75th"?: number;
      }[];
    };
    ReportTransactions: {
      data?: {
        /** Selected aggregation field value. */
        aggregationFieldValue?: string;
        /** Approved auth transactions to all transactions percentage. */
        authApprovedThroughput?: number;
        /** Approved sale transactions to all transactions percentage. */
        approvedThroughput?: number;
        /** Approved auth transactions count. */
        authApprovalCount?: number;
        /** Disputed transactions to all approved sale and capture transactions percentage. */
        disputesRate?: number;
        /** Disputed transactions to all approved sale and capture transactions count. */
        disputesCount?: number;
        /** Sales count. */
        salesCount?: number;
        /** Sales value. */
        salesValue?: number;
        /** Sales average value. */
        salesAverage?: number;
        /** Refunds count. */
        refundsCount?: number;
        /** Refunds value. */
        refundsValue?: number;
        /** Amount. */
        amount?: number;
        /** Transactions count. */
        count?: number;
      }[];
    };
    SubscriptionSummaryMetrics: {
      /** Currency (three letter ISO 4217 alpha code). */
      currency?: string;
      /** Sum of all issued, past due, or paid invoices. */
      invoicedAmount?: number;
      /** Sum of all paid invoices. */
      collectedAmount?: number;
      /** Number of issued, past due, or paid invoices. */
      invoiceCount?: number;
    };
  };
  responses: {
    /** Unauthorized access, invalid credentials was used. */
    Unauthorized: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Access forbidden. */
    Forbidden: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Invalid data was sent. */
    ValidationError: {
      content: {
        "application/json": components["schemas"]["InvalidError"];
      };
    };
    /** Resource was not found. */
    NotFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Conflict. */
    Conflict: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Customer. */
    Customer: {
      headers: {
        // Rate-Limit-Limit": components["headers"]["Rate-Limit-Limit"];
        // "Rate-Limit-Remaining": components["headers"]["Rate-Limit-Remaining"];
        // "Rate-Limit-Remaining": components["headers"]["Rate-Limit-Reset"];
      };
      content: {
        "application/json": components["schemas"]["Customer"];
      };
    };
    /** Resource was moved. */
    Found: {
      headers: {
        Location: string;
      };
    };
    /** Request was accepted, but no response body is returned. */
    NoContent: {};
  };
}
